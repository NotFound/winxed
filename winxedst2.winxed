#! winxed

/***********************************************************************
                   Winxed stage 2 compiler
***********************************************************************/

namespace Winxed
{
namespace Compiler
{

const int VERSION_MAJOR = 1;
const int VERSION_MINOR = 8;
const int VERSION_BUILD = -1;

//*********************************************
//          Character test functions
//*********************************************

inline isspace(string c) return int
{
    return c == ' ' || c == "\n" || c == "\t";
}

inline isdigit(string c) return int
{
    return indexof('0123456789', c) > -1;
}

inline hexdigit(string c) return int
{
    int i = indexof('0123456789abcdef0123456789ABCDEF', c);
    if (i >= 0) i = i % 16;
    return i;
}

inline isidentstart(string c) return int
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_',
        c) > -1;
}

inline isident(string c) return int
{
    return indexof(
        'abcdefghijklmnopqrstuvwxyz' +
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '_$' +
        '0123456789',
        c) > -1;
}

function sformat(string format, args[slurpy])
{
    var builder = new ['StringBuilder'];
    builder.append_format(format, args:[flat]);
    return string(builder);
}

// Algorithms

inline for_each(var src, var func)
{
    for (var item in src)
        func(item);
}

inline transform(var src, var dest, var func) return var
{
    for (var item in src)
        push(dest, func(item));
    return dest;
}

inline find_same(var src, var value) return var
{
    for (var item in src)
        if (item === value)
            return item;
    return null;
}

inline find_if(var src, var fun) return var
{
    for (var item in src)
        if (fun(item))
            return item;
    return null;
}

function bindfirst(fun, argfirst[slurpy])
{
    return function(arglast[slurpy])
    {
        return fun(argfirst:[flat], arglast:[flat]);
    };
}

function bindlast(fun, arglast[slurpy])
{
    return function(argfirst[slurpy])
    {
        return fun(argfirst:[flat], arglast:[flat]);
    };
}

function bindmethod(string name)
{
    return function(obj, args[slurpy])
    {
        return obj.*name(args:[flat]);
    };
}

function method_fun(obj, string methodname)
{
    var method = find_method(obj, methodname);
    return function (args[slurpy])
    {
        return obj.*method(args:[flat]);
    };
}

function addprefix(string prefix)
{
    return function (string str) { return prefix + str; };
}

inline clone_array(var src, var owner) return var
{
    return transform(src, [], bindlast(bindmethod("clone"), owner));
}

//*********************************************
//        Error handling exceptions
//*********************************************

const string
    ERR_INTERNAL = 'internal',
    ERR_TOKEN    = 'tokenizer',
    ERR_PARSER   = 'parser';

class WinxedCompilerError
{
    // Payload for compiler exceptions.
    var type;     // internal, tokenizer, parser
    var filename;
    var line;
    var message;

    function WinxedCompilerError(
            string type,
            string message,
            string filename[optional],
            int line[optional])
    {
        self.type = type;
        self.message = message;
        self.filename = filename;
        self.line = line;
    }
}

function Warn(string msg, var pos [optional])
{
    var stderr = getstderr();
    stderr.print('WARNING: ');
    stderr.print(msg);
    if (pos != null) {
        stderr.print(' near ');
        stderr.print(pos.show());
    }
    stderr.print("\n");
}

function InternalError(string msg, var pos [optional], int has_pos [opt_flag])
{
    if (has_pos) {
        pos = pos.getstart();
        string desc = pos.show();
        msg = msg + ' near ' + desc;
    }
    var payload = has_pos ?
        new WinxedCompilerError(ERR_INTERNAL, msg,
                pos.filename(), pos.linenum()) :
        new WinxedCompilerError(ERR_INTERNAL, msg);
    throw Error(msg, 2, __WINXED_ERROR__, payload);
}

function SyntaxError(string msg, var pos)
{
    if (pos != null)
        pos = pos.getstart();
    int line = pos != null ? pos.linenum() : -1;
    string file = pos != null ? pos.filename() : "UNKNOWN";
    string desc = ' near ' + string(pos.viewable());
    throw Error(msg + ' in ' + file + ' line ' + string(line) + desc,
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_PARSER, msg + desc,
                   file, line));
}

function NoLeftSide(var pos)
{
    SyntaxError('Not a left-side expression', pos);
}

function Expected(string msg, var t)
{
    SyntaxError("Expected " + msg, t);
}

function Unexpected(string msg, var t)
{
    SyntaxError("Unexpected " + msg, t);
}

function ExpectedIdentifier(var t)
{
    SyntaxError("Expected identifier", t);
}

function ExpectedOp(string msg, var t)
{
    SyntaxError("Expected '" + msg + "'", t);
}

function RequireOp(string name, var t)
{
    if (! t.isop(name))
        ExpectedOp(name, t);
}

function RequireKeyword(string name, var t)
{
    if (! t.iskeyword(name))
        ExpectedOp(name, t);
}

function RequireIdentifier(var t)
{
    if (! t.isidentifier())
        ExpectedIdentifier(t);
}

function ExpectOp(string name, var tk)
{
    var t = tk.get();
    RequireOp(name, t);
}

function ExpectKeyword(string name, var tk)
{
    var t = tk.get();
    RequireKeyword(name, t);
}

function UndefinedVariable(string name, var t)
{
    SyntaxError("Variable '" + name + "' is not defined", t);
}

//*********************************************
//                Token
//*********************************************

class Token
{
    var file;
    var line;
    function Token(string file, int line)
    {
        self.file = file;
        self.line = line;
    }
    function getstart() { return self; }

    function iseof()          { return false; }
    function iscomment()      { return false; }
    function isidentifier()   { return false; }
    function isint()          { return false; }
    function isfloat()        { return false; }
    function isstring()       { return false; }
    function issinglequoted() { return false; }

    function getintvalue()
    {
        InternalError('Not a literal int', self);
    }
    function rawstring()
    {
        InternalError('Not a literal string', self);
    }
    function getidentifier()
    {
        ExpectedIdentifier(self);
    }
    function iskeyword(string name) { return false; }
    function checkkeyword()         { return false; }
    function isop(string name)      { return false; }
    function checkop() { return ''; }
    function viewable() { return '(unknown)'; }
    function filename() { return self.file; }
    function linenum() { return self.line; }
    function show()
    {
        string r = self.viewable();
        return r + ' at ' + string(self.file) + ' line ' + string(self.line);
    }
}

class TokenEof : Token
{
    function TokenEof(string file)
    {
        self.Token(file, 0);
    }
    function iseof() { return true; }
    function viewable() { return '(End of file)'; }
}

class TokenWithVal : Token
{
    var str;
    function TokenWithVal(string file, int line, string str)
    {
        self.Token(file, line);
        self.str = str;
    }
    function get_string[vtable]() { return self.str; }
    function viewable()
    {
        return self.str;
    }
}

class TokenComment : TokenWithVal
{
    function TokenComment(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function iscomment() { return true; }
}

class TokenOp : TokenWithVal
{
    function TokenOp(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isop(string name)
    {
        return self.str == name;
    }
    function checkop()
    {
        return string(self.str);
    }
}

class TokenIdentifier : TokenWithVal
{
    function TokenIdentifier(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isidentifier() { return true; }
    function getidentifier()
    {
        return self.str;
    }
    function checkkeyword()
    {
        return string(self.str);
    }
    function iskeyword(string name)
    {
        return self.str == name;
    }
}

class TokenString : TokenWithVal
{
    function isstring() { return true; }
    function rawstring()
    {
        return self.str;
    }
}

class TokenQuoted : TokenString
{
    function TokenQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function get_string[vtable]()
    {
        return '"' + string(self.str) + '"';
    }
    function viewable()
    {
        return '"' + string(self.str) + '"';
    }
    function getasquoted()
    {
        return self.str;
    }
    function getPirString()
    {
        string str = self.str;
        string strunesc;
        try {
            strunesc = unescape(str);
        }
        catch () {
            SyntaxError("Invalid escape sequence in literal string", self);
        }
        int need_encoding = false;
        for (int code in strunesc) {
            if (code > 127) {
                need_encoding = true;
                break;
            }
        }
        str = escape(strunesc);
        string encoding = need_encoding ? "utf8:" : "";
        return encoding + '"' + str + '"';
    }
}

class TokenSingleQuoted : TokenString
{
    function TokenSingleQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function issinglequoted() { return true; }
    function get_string[vtable]()
    {
        return "'" + string(self.str) + "'";
    }
    function viewable()
    {
        return "'" + string(self.str) + "'";
    }
    function getasquoted()
    {
        string s = '';
        for (string c in self.str) {
            switch (c) {
              case '"':
              case '\':
              case "'":
                c = '\' + c;
                break;
            }
            s += c;
        }
        return s;
    }
    function getPirString()
    {
        string str = self.str;
        string quote = "'";
        int need_escape = false;
        for (int code in str) {
            if (code < 32 || code > 127) {
                need_escape = true;
                break;
            }
        }
        int need_encoding = false;
        if (need_escape) {
            quote = '"';
            string result = '';
            for (string c in str) {
                if (c == '\')
                    result += '\\';
                else
                {
                    int n = ord(c);
                    if (n < 32 || n > 127) {
                        if (n > 127)
                            need_encoding = true;
                        string h = n.get_as_base(16);
                        result += '\x{' + h + '}';
                    }
                    else
                        result += c;
                }
            }
            str = result;
        }
        str = quote + str + quote;
        if (need_encoding)
            str = 'utf8:' + str;
        return str;
    }
}

class TokenInteger : TokenWithVal
{
    function TokenInteger(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isint() { return true; }
    function getintvalue()
    {
        return int(self.str);
    }
}

class TokenFloat : TokenWithVal
{
    function TokenFloat(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isfloat() { return true; }
    function getfloatvalue()
    {
        return float(self.str);
    }
}


//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function TokenError(string msg, tk, int line)
{
    throw Error(msg + ' in ' + string(tk.filename) + ' line ' + string(line),
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_TOKEN, msg, tk.filename, line));
}

function UnterminatedString(tk, int line)
{
    TokenError('Unterminated string', tk, line);
}

function UnterminatedHeredoc(tk, int line)
{
    TokenError('Unterminated heredoc', tk, line);
}

function UnclosedComment(tk, int line)
{
    TokenError("Unclosed comment", tk, line);
}

function getquoted(tk, string start, int line)
{
    string s = '';
    string c;
    for (c = tk.getchar(); c != '"'; c = tk.getchar()) {
        switch (c) {
          case "":
          case "\n":
            UnterminatedString(tk, line);
          case '\':
            // Quick fix for escaped double quotes.
            string c2 = tk.getchar();
            if (c2 == '' || c2 == "\n")
                UnterminatedString(tk, line);
            s += c + c2;
            break;
          default:
            s += c;
        }
    }
    return new TokenQuoted(tk.filename, line, s);
}

function getsinglequoted(tk, string start, int line)
{
    string s = '';
    string c;
    for (c = tk.getchar(); c != "'"; c = tk.getchar()) {
        if (c == "" || c == "\n")
            UnterminatedString(tk, line);
        s += c;
    }
    return new TokenSingleQuoted(tk.filename, line, s);
}

function getheredoc(tk, string start, int linenum)
{
    string mark = '';
    string c;
    for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
        switch (c) {
          case '':
            UnterminatedHeredoc(tk, linenum);
          case '"':
          case '\':
            // Encode the mark the same way as the heredoc content
            // to simplify its detection
            c = '\' + c;
            break;
        }
        mark = mark + c;
    }
    mark = mark + ':>>';

    string content = '';
    string line;
    do {
        line = '';
        for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
            switch (c) {
              case '':
                UnterminatedHeredoc(tk, linenum);
              case '"':
              case '\':
                c = '\' + c;
                break;
            }
            line += c;
        }
        if (line != mark)
            content += line + '\n';
    } while (line != mark);
    return new TokenQuoted(tk.filename, linenum, content);
}

function getident(tk, string start, int line)
{
    string s = start;
    string c;
    for (c = tk.getchar(); isident(c); c = tk.getchar())
        s += c;
    tk.ungetchar(c);
    return new TokenIdentifier(tk.filename, line, s);
}

function getnumber(tk, string start, int line)
{
    string s;
    string c = start;
    do {
        s += c;
        c = tk.getchar();
    } while (isdigit(c));
    if (s == '0' && (c == 'x' || c == 'X')) {
        int hexval = 0, h;
        for (c = tk.getchar(); (h = hexdigit(c)) >= 0; c = tk.getchar()) {
            hexval = hexval * 16 + h;
            s += c;
        }
        tk.ungetchar(c);
        s = hexval;
        return new TokenInteger(tk.filename, line, s);
    }
    if (c == '.') {
        do {
            s += c;
            c = tk.getchar();
        } while (isdigit(c));
        if (c == 'e' || c == 'E') {
            s += 'E';
            if ((c = tk.getchar()) == '+' || c == '-') {
                s += c;
                c = tk.getchar();
            }
            for ( ; isdigit(c); c = tk.getchar())
                s += c;
        }
        tk.ungetchar(c);
        return new TokenFloat(tk.filename, line, s);
    }
    else {
        if (c == 'e' || c == 'E') {
            s += 'E';
            if ((c = tk.getchar()) == '+' || c == '-') {
                s += c;
                c = tk.getchar();
            }
            for ( ; isdigit(c); c = tk.getchar())
                s += c;
            tk.ungetchar(c);
            return new TokenFloat(tk.filename, line, s);
        }
        else {
            tk.ungetchar(c);
            return new TokenInteger(tk.filename, line, s);
        }
    }
}

function getlinecomment(tk, string start, int line)
{
    string s = start;
    for (string c = tk.getchar(); c != '' && c != "\n"; c = tk.getchar())
        s += c;
    return new TokenComment(tk.filename, line, s);
}

function getcomment(tk, string start, int line)
{
    string s = start;
    string c = tk.getchar();
    do {
       for ( ; c != '' && c != '*'; c = tk.getchar())
            s += c;
        if (c == '')
            UnclosedComment(tk, line);
        s += c;
        c = tk.getchar();
        if (c == '')
            UnclosedComment(tk, line);
    } while (c != '/');
    s += '/';
    return new TokenComment(tk.filename, line, s);
}

function getop(tk, string start, int line)
{
    string s = start;
    return new TokenOp(tk.filename, line, s);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var warnings;
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function Tokenizer(handle, string filename, int nowarn)
    {
        self.warnings = new ["Boolean"](! nowarn);
        self.h = handle;
        self.pending = '';
        self.stacked = [];
        self.filename = filename;
        self.line = 1;
        var select = {
            '$': { '': getident, '{': getop },
            '"': getquoted,
            "'": getsinglequoted,
            '=': {
                '=': { '': getop, '=': getop },
                ':': getop
            },
            '+': { '+': getop, '=': getop },
            '-': { '-': getop, '=': getop },
            '*': { '=': getop },
            '|': { '|': getop },
            '&': { '&': getop },
            '<': {
                '<': { '': getop, ':': getheredoc },
                '=': getop
            },
            '>': {
                '>': { '': getop, '>': getop },
                '=': getop
            },
            '!': {
                '=': { '': getop, '=': getop }
            },
            '%': { '%': getop, '=': getop },
            '/': { '=': getop, '/': getlinecomment, '*': getcomment },
            '#': getlinecomment
        };
        self.select = select;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function getchar()
    {
        var pending = self.pending;
        string c = pending;
        if (c != '')
            pending =: '';
        else {
            var h = self.h;
            c = h.read(1);
            if (c == "\n")
                ++self.line;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending =: c;
    }
    function get_token()
    {
        if (self.stacked)
            return self.stacked.pop();

        string c = self.getchar();
        while (isspace(c))
                c = self.getchar();
        int line = self.line;
        if (c == '')
            return new TokenEof(self.filename);
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);

        string op = c;
        var select = self.select;
        var current = select[c];

        while (current != null && (current instanceof 'Hash')) {
            c = self.getchar();
            select = current;
            current = select[c];
            if (current == null) {
                self.ungetchar(c);
                current = select[''];
            }
            else
                op += c;
        }
        return current != null ?
            current(self, op, line) :
            getop(self, op, line);
    }
    function get(int withcomments [optional])
    {
        var t = self.get_token();
        while (!t.iseof() && !withcomments && t.iscomment())
           t = self.get_token();
        return t;
    }
    function unget(t)
    {
        push(self.stacked, t);
    }
}

//*********************************************
//          PIR generation values
//*********************************************

// Register types
const string
    REGint =     'I',
    REGfloat =   'N',
    REGstring =  'S',
    REGvar =     'P',
// Pseudotypes for builtins
    REGarglist = '*',
    REGany     = '?',
    REGsame    = ':', // same as argument
    REGs_v     = 'p', // string or var
    REGraw1    = '!', // raw mode one arg
    REGnone    = 'v'; // void return

// Register reserved for temporal and dicardable results
const string DISCARD_IREG = "$I0";
const string DISCARD_NREG = "$N0";
const string DISCARD_SREG = "$S0";
const string DISCARD_PREG = "$P0";

function typetoregcheck(string type)
{
    switch (type) {
    case 'int':    return REGint;
    case 'float':  return REGfloat;
    case 'string': return REGstring;
    case 'var':    return REGvar;
    default:       return '';
    }
}

function typetopirname(string regtype)
{
    switch (regtype) {
    case REGint:    return 'int';
    case REGfloat:  return 'num';
    case REGstring: return 'string';
    case REGvar:    return 'pmc';
    default:        InternalError('Invalid reg type');
    }
}

//*********************************************
//            Emit
//*********************************************

const string INDENT =      '    ';
const string INDENTLABEL = '  ';

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    var debug;
    var noan;
    var warnings;

    function Emit(var handle, int nowarn)
    {
        self.handle = handle;
        self.file = "";
        self.line = 0;
        self.pendingf = false;
        self.pendingl = false;
        self.warnings = new ["Boolean"](! nowarn);
    }
    function setDebug()
    {
        self.debug = true;
    }
    function getDebug()
    {
        return self.debug != null;
    }
    function disable_annotations()
    {
        self.noan = true;
    }
    function close()
    {
        self.handle = null;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(join("", [
                ".annotate 'file', '",
                self.file,
                "'\n" ]
            ));
            self.pendingf =: false;
        }
        if (self.pendingl) {
            self.handle.print(join("", [
                ".annotate 'line', ",
                self.line,
                "\n" ]
            ));
            self.pendingl =: false;
        }
    }
    function vprint(var args)
    {
        for_each(args, method_fun(self.handle, "print"));
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.noan == null)
        {
            var file = self.file;
            var line = self.line;
            string tfile = t.file;
            int tline = t.line;
            if (file != tfile) {
                file =: tfile;
                self.pendingf =: true;
                line =: 0;
            }
            if (line != tline) {
                line =: tline;
                self.pendingl =: true;
            }
        }
    }
    function comment(string s)
    {
        self.updateannot();
        self.handle.print("# " + s + "\n");
    }
    function emitlabel(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENTLABEL);
        handle.print(label);
        handle.print(":");
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }
    function emitgoto(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENT + "goto ");
        handle.print(label);
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }

    function emitarg1(string op, string arg1)
    {
        self.say(INDENT, op, " ", arg1);
    }
    function emitarg2(string op, string arg1, string arg2)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2);
    }
    function emitarg3(string op, string arg1, string arg2, string arg3)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", arg3);
    }
    function emitcompare(string op, string arg1, string arg2, string label)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", label);
    }
    function emitif(string value, string label)
    {
        self.say(INDENT + "if ", value, " goto ", label);
    }
    function emitunless(string value, string label)
    {
        self.say(INDENT + "unless ", value, " goto ", label);
    }
    function emitif_null(string value, string label)
    {
        self.say(INDENT + "if_null ", value, ", ", label);
    }
    function emitunless_null(string value, string label)
    {
        self.say(INDENT + "unless_null ", value, ", ", label);
    }
    function emitnull(string dst)
    {
        self.say(INDENT + "null ", dst);
    }

    function emitinc(string arg)
    {
        self.say(INDENT + "inc ", arg);
    }
    function emitdec(string arg)
    {
        self.say(INDENT + "dec ", arg);
    }
    function emitset(string dst, string src)
    {
        self.say(INDENT + "set ", dst, ", ", src);
    }
    function emitassign(string dst, string src)
    {
        self.say(INDENT + "assign ", dst, ", ", src);
    }
    function emitbox(string dst, string src)
    {
        self.say(INDENT + "box ", dst, ", ", src);
    }
    function emitunbox(string dst, string src)
    {
        self.say(INDENT + "unbox ", dst, ", ", src);
    }
    function emitbinop(string op, string res, string dst, string src)
    {
        self.say(INDENT, op, " ", res, ", ", dst, ", ", src);
    }
    function emitaddto(string dst, string src)
    {
        self.say(INDENT + "add ", dst, ", ", src);
    }
    function emitsubto(string dst, string src)
    {
        self.say(INDENT + "sub ", dst, ", ", src);
    }
    function emitadd(string dst, string src1, string src2)
    {
        self.say(INDENT + "add ", dst, ", ", src1, ", ", src2);
    }
    function emitsub(string dst, string src1, string src2)
    {
        self.say(INDENT + "sub ", dst, ", ", src1, ", ", src2);
    }
    function emitmul(string dst, string src1, string src2)
    {
        self.say(INDENT + "mul ", dst, ", ", src1, ", ", src2);
    }
    function emitdiv(string dst, string src1, string src2)
    {
        self.say(INDENT + "div ", dst, ", ", src1, ", ", src2);
    }
    function emitconcat1(string dst, string src)
    {
        self.say(INDENT + "concat ", dst, ", ", dst, ", ", src);
    }
    function emitconcat(string dst, string src1, string src2)
    {
        self.say(INDENT + "concat ", dst, ", ", src1, ", ", src2);
    }
    function emitrepeat(string dst, string src1, string src2)
    {
        self.say(INDENT + "repeat ", dst, ", ", src1, ", ", src2);
    }
    function emitprint(string arg)
    {
        self.say(INDENT + "print ", arg);
    }
    function emitsay(string arg)
    {
        self.say(INDENT + "say ", arg);
    }
    function emitget_hll_namespace(string reg, string key)
    {
        self.say(INDENT + "get_hll_namespace ", reg, ", " + key);
    }
    function emitget_root_namespace(string reg, string key)
    {
        self.say(INDENT + "get_root_namespace ", reg, ", " + key);
    }
    function emitget_hll_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_hll_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitget_root_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_root_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitfind_lex(string reg, string name)
    {
        self.say(INDENT + "find_lex ", reg, ", ", name);
    }
    function emitstore_lex(string name, string reg)
    {
        self.say(INDENT + "store_lex ", name, ", ", reg);
    }
}

//*********************************************
//         Helper functions and constants
//*********************************************

// Scope search flags
const int
    SEARCH_NAMESPACE = 1,
    SEARCH_CLASS     = 2;

// Var flags
const int
    VAR_is_volatile = 1,      // volatile qualifier
    VAR_is_lexical  = 2,      // lexicalized local variable
    VAR_is_extern   = 4;      // externaly defined constant, do not export

const string
    NULL = 'null',
    SELF = 'self';


function integerValue(var owner, var start, int value)
{
    return new IntegerLiteral(owner, start, value);
}

function floatValue(var owner, var start, float value)
{
    var t = new TokenFloat(start.file, start.line, value);
    return new FloatLiteral(owner, t);
}

function stringQuotedValue(var owner, var start, string value)
{
    var t = new TokenQuoted(start.file, start.line, value);
    return new StringLiteral(owner, t);
}

function floatresult(string r1, string r2)
/*
    Check if the passed types can give a float result in arithmetic
    operations.
*/
{
    int result = (r1 == REGfloat && (r2 == REGfloat || r2 == REGint)) ||
           (r2 == REGfloat && (r1 == REGfloat || r1 == REGint));
    return result;
}

function floatAsString(float n)
/*
    Make sure that a float value is recognized as such by the
    PIR compiler, adding a dot if needed.
*/
{
    string aux = n;
    if (aux.is_integer(aux))
        aux += '.0';
    return aux;
}


// Predefined constants

// Fake filename and line number for the tokens.
const string PREDEFCONST_FILENAME = '__predefconst__';
const int PREDEFCONST_LINENUM = 0;

function createPredefConstInt(scope, string name, int value)
{
    var tid = new TokenIdentifier(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGint, VAR_is_extern);
    cst.setvalue(integerValue(scope, tid, value));
}

function createPredefConstString(scope, string name, string value)
{
    var tid = new TokenIdentifier(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGstring, VAR_is_extern);
    cst.setvalue(new StringLiteral(scope,
        new TokenQuoted(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM, value)));
}

//*********************************************
//             Builtins
//*********************************************

const int
    BULTIN_arglist = -1,
    BULTIN_raw1    = -2;

// Helpers for compile time evaluation

function string_from_literal(arg)
{
    string value;
    switch {
      case arg.isintegerliteral():
        value = arg.numval;
        break;
      case arg.isfloatliteral():
        value = arg.getFloatValue();
        break;
      case arg.isstringliteral():
        value = arg.get_value();
        break;
      default:
        InternalError('wrong call to string_from_literal', arg);
    }
    return value;
}

function int_from_literal(arg)
{
    int value;
    switch {
      case arg.isintegerliteral():
        value = arg.numval;
        break;
      case arg.isfloatliteral():
        value = arg.getFloatValue();
        break;
      case arg.isstringliteral():
        value = arg.get_value();
        break;
      default:
        InternalError('wrong call to int_from_literal', arg);
    }
    return value;
}

function float_from_literal(arg)
{
    float value;
    switch {
      case arg.isintegerliteral():
      case arg.isfloatliteral():
        value = arg.getFloatValue();
        break;
      case arg.isstringliteral():
        value = arg.get_value();
        break;
      default:
        InternalError('wrong call to float_from_literal', arg);
    }
    return value;
}

/*
    Get a literal from a builtin with just one param.
    The argument list validity should be checked before, so
    check here only in debug builds.
*/
function int_from_literal_arg1(args)
{
    if (__DEBUG__) {
        if (elements(args) != 1)
            InternalError("call to " + __FUNCTION__ + " with invalid args");
    }
    return int_from_literal(args[0].arg);
}
function string_from_literal_arg1(args)
{
    if (__DEBUG__) {
        if (elements(args) != 1)
            InternalError("call to " + __FUNCTION__ + " with invalid args");
    }
    return string_from_literal(args[0].arg);
}

// Invokable object generated from a string body
class Builtin_frombody
{
    const string resultmark = '%0';
    var body;
    var typeresult;
    function Builtin_frombody(string typeresult, string bodystr)
    {
        if (__DEBUG__) {
            // Minimal sanity check
            int pos = indexof(bodystr, resultmark);
            if (typeresult == REGnone && pos != -1)
                InternalError('void builtin with ' + resultmark);
            if (typeresult != REGnone && pos == -1)
                InternalError('non void builtin without ' + resultmark);
            switch (typeresult) {
              case REGint: case REGfloat: case REGstring:
              case REGvar: case REGnone:
                break;
              case REGsame:
                // TODO: must check it has one argument
                break;
              default:
                InternalError("Invalid result type in builtin");
            }
        }

        // Predecorate output
        int l = length(bodystr) - 1;
        if (substr(bodystr, l, 1) == "\n")
            bodystr = substr(bodystr, 0, l);
        bodystr = INDENT + join("\n" + INDENT, split("\n", bodystr));
        self.body = bodystr;
        self.typeresult = typeresult;
    }
    function invoke [vtable](e, owner, start, string result, args)
    {
        string typeresult = self.typeresult;

        if (typeresult == REGnone) {
            if (result != null && result != '')
                SyntaxError('using return value from void builtin', start);
        }
        else {
            if (result == null || result == '')
                InternalError('Bad result in non void builtin');
        }

        e.annotate(start);
        e.say(sformat(self.body, result, args:[flat]));
    }
}

class BuiltinBase
{
    var name;
    var body;
    var typeresult;
    var type0;
    var type1;
    var type2;
    var type3;
    var nparams;

    function BuiltinBase(string name, body,
        string typeresult,
        string type0,
        string type1,
        string type2,
        string type3)
    {
        self.name = name;
        if (body instanceof 'String')
            self.body = new Builtin_frombody(typeresult, body);
        else
            self.body = body;
        self.typeresult = typeresult;
        int n = 0;
        if (type0 != null) {
            self.type0 = type0;
            switch (type0) {
              case REGarglist:
                n = BULTIN_arglist;
                break;
              case REGraw1:
                n = BULTIN_raw1;
                if (type1 != null)
                    InternalError("Invalid builtin '" + name + '"');
                break;
              default:
                n = 1;
                if (type1 != null) {
                    self.type1 = type1;
                    ++n;
                }
                if (type2 != null) {
                    self.type2 = type2;
                    ++n;
                }
                if (type3 != null) {
                    self.type3 = type3;
                    ++n;
                }
            }
        }
        self.nparams = n;
    }
    function iscompileevaluable()
    {
        return false;
    }
    function name()
    {
        string name = self.name;
        return name;
    }
    function result()
    {
        return self.typeresult;
    }
    function params() { return self.nparams; }
    function paramtype(int i)
    {
        string type;
        switch (i) {
        case 0: type = self.type0; break;
        case 1: type = self.type1; break;
        case 2: type = self.type2; break;
        case 3: type = self.type3; break;
        default:
            InternalError('Invalid builtin arg');
        }
        return type;
    }
    function expand(var e, var owner, var start, string result, args)
    {
        string name = self.name;

        if (e.getDebug()) {
            // Special case for a now.
            if (name != '__ASSERT__')
                e.comment('builtin ' + name);
        }

        string typeresult = self.typeresult;
        if (typeresult != REGnone && result == '')
            result = owner.tempreg(typeresult);
        var fun = self.body;
        fun(e, owner, start, result, args);
    }
}

class BuiltinFunction : BuiltinBase
{
    function BuiltinFunction(string name, body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
    }
}

class BuiltinFunctionEval : BuiltinBase
{
    var evalfun;
    function BuiltinFunctionEval(string name, evalfun, body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
        self.evalfun = evalfun;
    }
    function iscompileevaluable()
    {
        return true;
    }
}

class Builtin_typecast
{
    var type;
    function Builtin_typecast(string type)
    {
        self.type = type;
    }
    function invoke [vtable](e, owner, start, string result, args)
    {
        string type = self.type;
        if (elements(args) != 1)
            InternalError("Invalid Builtin_typecast.invoke call");
        var rawarg = args[0];
        string argtype = rawarg.checkresult();
        switch {
          case argtype == type:
          case rawarg instanceof IndexExpr:
          case rawarg instanceof CallExpr:
            rawarg.emit(e, result);
            break;
          default:
            string arg = rawarg.emit_get(e);
            e.annotate(start);
            // Special case
            if (arg == NULL)
                e.emitnull(result);
            else
                e.emitset(result, arg);
        }
    }
}

function builtineval_stringcast(owner, start, args)
{
    return stringQuotedValue(owner, start, string_from_literal_arg1(args));
}

function builtineval_intcast(owner, start, args)
{
    int value = int_from_literal_arg1(args);
    return integerValue(owner, start, value);
}

function Builtin_varcast(e, owner, start, string result, args)
{
    if (elements(args) != 1)
        InternalError("Invalid var cast");
    var arg = args[0];
    string argtype = arg.checkresult();
    if (argtype == REGvar) {
        string name;
        var sym;
        switch {
          case arg instanceof IdentifierExpr:
            name = arg.getName();
            string id = arg.checkIdentifier();
            var desc = arg.checkVar();
            if (id != '' && desc != null && ! desc.issubid()) {
                // The cast is redundant in this case
                arg.emit(e, result);
            }
            else {
                sym = arg.scopesearch([name], 0);
                if (sym != null && sym instanceof FunctionStatement) {
                    var path = sym.owner.getpath();
                    e.emitget_hll_global(result, name, getparrotkey(path));
                }
            }
            break;
          case arg instanceof MemberExpr:
            // If it's a known function avoid using it bt subid,
            // else, look up in the hll namespace at runtime.
            string key[];
            arg.buildkey(key);
            sym = owner.scopesearch(key, 0);
            if (sym != null && sym instanceof FunctionStatement) {
                var path = sym.owner.getpath();
                e.annotate(start);
                e.emitget_hll_global(result, name, getparrotkey(path));
            }
            name = key.pop();
            e.annotate(start);
            e.emitget_hll_global(result, name, getparrotkey(key));
            break;
          default:
            e.annotate(start);
            arg.emit(e, result);
        }
    }
    else {
        string reg = arg.emit_get(e);
        e.annotate(start);
        if (reg == NULL)
            e.emitnull(result);
        else
            e.emitbox(result, reg);
    }
}

function Builtin_say(e, owner, start, string result, args)
{
    e.annotate(start);
    int n = elements(args) - 1;
    if (n >= 0) {
        for (int i = 0; i < n; ++i)
            e.emitprint(args[i]);
        e.emitsay(args[n]);
    }
    else
        e.emitsay("''");
}

function Builtin_cry(e, owner, start, string result, args)
{
    e.annotate(start);
    e.say(sformat(
<<:
    getstderr $P0
%0
    print $P0, "\n"
:>>
        , join("\n", transform(args, [], addprefix(INDENT + "print $P0, ")))));
}

function Builtin_print(e, owner, start, string result, args)
{
    e.annotate(start);
    for_each(args, method_fun(e, "emitprint"));
}

function Builtin_abs(e, owner, start, string result, args)
{
    var arg = args[0];
    string argreg = arg.emit_get(e);
    if (arg.checkresult() == REGstring) {
        string aux = owner.tempreg(REGfloat);
        e.annotate(start);
        e.emitset(aux, argreg);
        e.emitarg2('abs', aux, aux);
        e.emitset(result, aux);
    }
    else {
        e.annotate(start);
        e.emitarg2('abs', result, argreg);
    }
}

function Builtin_ASSERT(e, owner, start, string result, args)
{
    __ASSERT__(elements(args) == 1); // Best place to use it

    if (e.getDebug()) {
        e.annotate(start);
        string label = owner.genlabel();
        var arg = args[0];
        var reg = arg.emit_getint(e);
        e.emitif(reg, label);
        e.print(sformat(
<<:
    getstderr $P0
    print $P0, "Assertion failed at '%0' line "
    print $P0, %1
    print $P0, "\n"
    exit 1
:>>
            , start.filename(), start.linenum()));
        e.emitlabel(label);
    }
}

// invoke is a quick & dirty way to allow use of multiple return values.
// It's a wrap around the call that gives the signature object returned.
function Builtin_invoke(e, owner, start, string result, args)
{
    var arg = args[0];
    if (! (arg instanceof CallExpr))
        SyntaxError("invoke argument must be callable", start);
    arg.emit(e, "(" + result + " :call_sig)");
}

function builtineval_length(owner, start, args)
{
    string s = string_from_literal_arg1(args);
    return integerValue(owner, start, length(s));
}

function builtineval_bytelength(owner, start, args)
{
    string s = string_from_literal_arg1(args);
    return integerValue(owner, start, bytelength(s));
}

function builtineval_ord(owner, start, args)
{
    int nargs = elements(args);
    var arg = args[0].arg;
    string s = string_from_literal(arg);
    int pos = 0;
    if (nargs > 1) {
        var argpos = args[1].arg;
        pos = int_from_literal(argpos);
    }
    return integerValue(owner, start, ord(s, pos));
}

function builtineval_chr(owner, start, args)
{
    return stringQuotedValue(owner, start, chr(int_from_literal_arg1(args)));
}

function builtineval_substr(owner, start, args)
{
    int nargs = elements(args);
    var argstr = args[0].arg;
    var argpos = args[1].arg;
    string str = string_from_literal(argstr);
    int pos = int_from_literal(argpos);
    string result;
    if (args > 2) {
        var arglen = args[2].arg;
        int len = int_from_literal(arglen);
        result = substr(str, pos, len);
    }
    else
        result = substr(str, pos);
    return stringQuotedValue(owner, start, result);
}

function builtineval_indexof(owner, start, args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    string strfrom = string_from_literal(argstrfrom);
    string strsearch = string_from_literal(argstrsearch);
    return integerValue(owner, start, indexof(strfrom, strsearch));
}

function builtineval_indexof_pos(owner, start, args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    var argpos = args[2].arg;
    string strfrom = string_from_literal(argstrfrom);
    string strsearch = string_from_literal(argstrsearch);
    int pos = int_from_literal(args[2].arg);
    return integerValue(owner, start, indexof(strfrom, strsearch, pos));
}

function builtineval_upcase(owner, start, args)
{
    return stringQuotedValue(owner, start,
            upcase(string_from_literal_arg1(args)));
}

function builtineval_downcase(owner, start, args)
{
    return stringQuotedValue(owner, start,
            downcase(string_from_literal_arg1(args)));
}

function builtineval_escape(owner, start, args)
{
    // This is a unescaped string. To get a escaped string
    // in the output we need to escape twice.
    return stringQuotedValue(owner, start,
            escape(escape(string_from_literal_arg1(args))));
}

function builtin_sleep(e, owner, start, result, args)
{
    var expr = args[0];
    string reg;
    string type = expr.checkresult();
    switch (type) {
      case REGint:
        reg = expr.emit_getint(e);
        break;
      case REGfloat:
        reg = expr.emit_get(e);
        break;
      default:
        if (expr.isnull())
            reg = "0";
        else {
            string aux = expr.emit_get(e);
            reg = DISCARD_NREG;
            e.annotate(start);
            e.emitset(reg, aux);
        }
    }
    e.annotate(start);
    e.emitarg1('sleep', reg);
}

function getbuiltins(builder)
{
    builder.add(new BuiltinFunctionEval('int',
        builtineval_intcast,
        new Builtin_typecast(REGint),
        REGint, REGraw1
    ));
    builder.add(new BuiltinFunction('float',
        new Builtin_typecast(REGfloat),
        REGfloat, REGraw1
    ));
    builder.add(new BuiltinFunctionEval('string',
        builtineval_stringcast,
        new Builtin_typecast(REGstring),
        REGstring, REGraw1
    ));
    builder.add(new BuiltinFunction('var',
        Builtin_varcast,
        REGvar, REGraw1
    ));
    builder.add(new BuiltinFunction('die',
        'die %1',
        REGnone, REGstring
    ));
    builder.add(new BuiltinFunction('exit',
        'exit %1',
        REGnone, REGint
    ));
    builder.add(new BuiltinFunction('time',
        'time %0',
        REGint
    ));
    builder.add(new BuiltinFunction('floattime',
        'time %0',
        REGfloat
    ));
    builder.add(new BuiltinFunction('sleep',
        builtin_sleep,
        REGnone, REGraw1
    ));
    builder.add(new BuiltinFunction('spawnw',
        'spawnw %0, %1',
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction('getstdin',
        'getstdin %0',
        REGvar
    ));
    builder.add(new BuiltinFunction('getstdout',
        'getstdout %0',
        REGvar
    ));
    builder.add(new BuiltinFunction('getstderr',
        'getstderr %0',
        REGvar
    ));
    builder.add(new BuiltinFunction('open',
<<:
root_new %0, ['parrot';'FileHandle']
%0.'open'(%1)
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('open',
<<:
root_new %0, ['parrot';'FileHandle']
%0.'open'(%1,%2)
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('Error',
<<:
root_new %0, ['parrot';'Exception']
%0['message'] = %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('Error',
<<:
root_new %0, ['parrot';'Exception']
%0['message'] = %1
%0['severity'] = %2
:>>
        , REGvar, REGstring, REGint
    ));
    builder.add(new BuiltinFunction('Error',
<<:
root_new %0, ['parrot';'Exception']
%0['message'] = %1
%0['severity'] = %2
%0['type'] = %3
:>>
        , REGvar, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction('Error',
<<:
root_new %0, ['parrot';'Exception']
%0['message'] = %1
%0['severity'] = %2
%0['type'] = %3
%0['payload'] = %4
:>>
        , REGvar, REGstring, REGint, REGint, REGvar
    ));
    builder.add(new BuiltinFunction('elements',
        'elements %0, %1',
        REGint, REGvar
    ));
    builder.add(new BuiltinFunctionEval('length',
        builtineval_length,
        'length %0, %1',
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval('bytelength',
        builtineval_bytelength,
        'bytelength %0, %1',
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval('chr',
        builtineval_chr,
<<:
chr $S0, %1
find_encoding $I0, 'utf8'
trans_encoding %0, $S0, $I0
:>>
        , REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval('ord',
        builtineval_ord,
        'ord %0, %1',
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval('ord',
        builtineval_ord,
        'ord %0, %1, %2',
        REGint, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval('substr',
        builtineval_substr,
        'substr %0, %1, %2',
        REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval('substr',
        builtineval_substr,
        'substr %0, %1, %2, %3',
        REGstring, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction('replace',
        'replace %0, %1, %2, %3, %4',
        REGstring, REGstring, REGint, REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval('indexof',
        builtineval_indexof,
        'index %0, %1, %2',
        REGint, REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval('indexof',
        builtineval_indexof_pos,
        'index %0, %1, %2, %3',
        REGint, REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunction('join',
        'join %0, %1, %2',
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunctionEval('escape',
        builtineval_escape,
        'escape %0, %1',
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('unescape',
<<:
$P0 = new ['String']
$P0 = %1
%0 = $P0.'unescape'('utf8')
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('unescape',
<<:
$P0 = new ['String']
$P0 = %1
%0 = $P0.'unescape'(%2)
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('trans_encoding',
<<:
find_encoding $I0, %2
trans_encoding %0, %1, $I0
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('encoding_name',
<<:
encoding $I0, %1
encodingname %0, $I0
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval('upcase',
        builtineval_upcase,
        'upcase %0, %1',
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval('downcase',
        builtineval_downcase,
        'downcase %0, %1',
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('titlecase',
        'titlecase %0, %1',
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('split',
        'split %0, %1, %2',
        REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('chomp',
<<:
$P0 = get_root_global ['parrot';'String';'Utils'], 'chomp'
%0 = $P0(%1)
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('chomp',
<<:
$P0 = get_root_global ['parrot';'String';'Utils'], 'chomp'
%0 = $P0(%1, %2)
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('push',
        'push %1, %2',
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction('unshift',
        'unshift %1, %2',
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction('pop_var',
        'pop %0, %1',
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction('shift_var',
        'shift %0, %1',
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction('pop_int',
        'pop %0, %1',
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction('shift_int',
        'shift %0, %1',
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction('pop_float',
        'pop %0, %1',
        REGfloat, REGvar
    ));
    builder.add(new BuiltinFunction('shift_float',
        'shift %0, %1',
        REGfloat, REGvar
    ));
    builder.add(new BuiltinFunction('pop_string',
        'pop %0, %1',
        REGstring, REGvar
    ));
    builder.add(new BuiltinFunction('shift_string',
        'shift %0, %1',
        REGstring, REGvar
    ));
    builder.add(new BuiltinFunction('abs',
        Builtin_abs,
        REGsame, REGraw1
    ));
    builder.add(new BuiltinFunction('sqrt',
        'sqrt %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('pow',
        'pow %0, %1, %2',
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('exp',
        'exp %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('ln',
        'ln %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('sin',
        'sin %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('cos',
        'cos %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('tan',
        'tan %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('asin',
        'asin %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('acos',
        'acos %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('atan',
        'atan %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('atan',
        'atan %0, %1, %2',
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('sinh',
        'sinh %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('cosh',
        'cosh %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('tanh',
        'tanh %0, %1',
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction('getinterp',
        'getinterp %0',
        REGvar
    ));
    builder.add(new BuiltinFunction('getcontext',
/* Experimental:
Parrot will probably have a getcontext op in the near future.
At that point this bulitin will just map to that op.
In the meantime, get the conext via getinterp and the
ParrotInterpreter PMC.
*/
<<:
getinterp $P0
%0 = $P0["context"]
:>>
        , REGvar
    ));
    builder.add(new BuiltinFunction('get_class',
        'get_class %0, %1',
        REGvar, REGs_v
    ));
    builder.add(new BuiltinFunction('typeof',
        'typeof %0, %1',
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction('getattribute',
        'getattribute %0, %1, %2',
        REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('getattribute',
        'getattribute %0, %1, %2, %3',
        REGvar, REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('setattribute',
        'setattribute %1, %2, %3, %4',
        REGnone, REGvar, REGvar, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction('find_method',
        'find_method %0, %1, %2',
        REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('callmethodwithargs',
        '%0 = %1.%2(%3 :flat)',
        REGvar, REGvar, REGvar, REGvar
    ));
    builder.add(new BuiltinFunction('clone',
        'clone %0, %1',
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction('compreg',
        'compreg %0, %1',
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('compreg',
        'compreg %1, %2',
        REGnone, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction('load_language',
<<:
load_language %1
compreg %0, %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('load_language',
<<:
load_language %1
compreg %0, %2
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('loadlib',
        'loadlib %0, %1',
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('load_bytecode',
        'load_bytecode %1',
        REGnone, REGstring
    ));
    builder.add(new BuiltinFunction('load_packfile',
        'load_bytecode %0, %1',
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction('dlfunc',
        'dlfunc %0, %1, %2, %3',
        REGvar, REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction('sprintf',
        'sprintf %0, %1, %2',
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction('print',
        Builtin_print,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction('say',
        Builtin_say,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction('cry',
        Builtin_cry,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction('__ASSERT__',
        Builtin_ASSERT,
        REGnone, REGraw1
    ));
    builder.add(new BuiltinFunction('invoke',
        Builtin_invoke,
        REGvar, REGraw1
    ));
}

//*********************************************
//               Auxiliar functions
//*********************************************

inline optimize_array(var arr)
{
    int n = arr != null ? elements(arr) : 0;
    for (int i = 0; i < n; ++i)
        arr[i] = arr[i].optimize();
}

inline emit_array(var e, var arr)
{
    for_each(arr, bindlast(bindmethod("emit"), e));
}

function parseDotted(tk)
{
    var list = [];
    var t = tk.get();
    if (t.isidentifier()) {
        push(list, t);
        while ((t = tk.get()).isop('.')) {
            t = tk.get();
            push(list, t);
        }
    }
    tk.unget(t);
    return list;
}

function parseList(tk, owner, fn, string oper_end[optional])
/*
  Parse a comma separated list of items.
  Calls the passed fn to parse each item.
*/
{
    var list = [];
    var t;
    do {
        var value = fn(tk, owner);
        push(list, value);
    } while ((t = tk.get()).isop(','));
    if (oper_end == null)
        tk.unget(t);
    else
        if (! t.isop(oper_end))
            SyntaxError("Unfinished argument list", t);
    return list;
}

// Helper to parse identifier lists using parseList
function parseIdentifier(tk, unused)
{
    var t = tk.get();
    if (!t.isidentifier())
        ExpectedIdentifier(t);
    return t;
}

function toIdentifierList(var tlist)
{
    string list[];
    transform(tlist, list, bindmethod("getidentifier"));
    return list;
}

//*********************************************
//               CommonBase
//*********************************************

class CommonBase
{
    var start;
    var owner;

    function initbase(start, owner)
    {
        self.start = start;
        self.owner = owner;
    }
    function clone(owner)
    {
        SyntaxError("Cannot use " + string(typeof(self)) + " in inline (yet)",
                self);
    }
    function getstart()
    {
        return self.start;
    }
    function viewable()
    {
        if (self.start != null)
            return self.start.viewable();
        else
            return "";
    }
    function annotate(e)
    {
        e.annotate(self.start);
    }
    function getpath()
    {
        return self.owner.getpath();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function usesubid(string id)
    {
        self.owner.usesubid(id);
    }
    function addlocalfunction(fn)
    {
        return self.owner.addlocalfunction(fn);
    }
    function scopesearch(key, int flags)
    {
        return self.owner.scopesearch(key, flags);
    }
    function dowarnings()
    {
        return self.owner.dowarnings();
    }
}

//*********************************************
//             CollectValues
// Emit an get registers for a collection of
// values avoiding redundant setting of null
// registers.
//*********************************************

class CollectValues
{
    var owner;
    var e;
    var pnull;
    function CollectValues(owner, e)
    {
        self.owner = owner;
        self.e = e;
    }
    function add(var value)
    {
        __ASSERT__(value instanceof Expr);
        var e = self.e;
        string valuereg;
        if (value.isnull()) {
            var pnull = self.pnull;
            if (pnull == null) {
                string regnull = self.owner.tempreg(REGvar);
                e.emitnull(regnull);
                self.pnull = pnull = regnull;
            }
            valuereg = pnull;
        }
        else
            valuereg = value.emit_get(e);
        return valuereg;
    }
}

//*********************************************
//          SimpleArgList
//*********************************************

// A list of arguments without modifiers.

class SimpleArgList
{
    var args;

    function SimpleArgList(var tk, var owner, string oper_end)
    {
        self.args = parseList(tk, owner, parseExpr, oper_end);
    }
    function clone(owner)
    {
        var cloned = new SimpleArgList;
        cloned.args = clone_array(self.args, owner);
        return cloned;
    }

    function numargs()
    {
        return elements(self.args);
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }

    function optimizeargs()
    {
        optimize_array(self.args);
    }
    function getargvalues(var e)
    {
        return transform(self.args, [], bindlast(bindmethod("emit_get"), e));
    }
    function emitargs(var e)
    {
        e.print(join(', ', self.getargvalues(e)));
    }
}

//*********************************************
//            Modifiers
//*********************************************

class Modifier
{
    var name;
    var args;

    function getname() { return self.name; }
    function numargs()
    {
        var args = self.args;
        int nargs = args == null ? 0 : args.numargs();
        return nargs;
    }
    function getarg(int argnum)
    {
        var args = self.args;
        if (argnum >= args.numargs())
            InternalError('Wrong modifier arg number');
        return args.getarg(argnum);
    }
    function Modifier(string name, var args)
    {
        self.name = name;
        if (args != null)
            self.args = args;
    }
    function optimize()
    {
        if (self.args != null)
            self.args.optimizeargs();
        return self;
    }
}

function parseModifier(tk, owner)
{
    var t = tk.get();
    string name = t.getidentifier();
    t = tk.get();
    var args;
    if (t.isop('('))
        args = new SimpleArgList(tk, owner, ')');
    else
        tk.unget(t);
    return new Modifier(name, args);
}


class ModifierList
{
    var list;

    function ModifierList(var tk, var owner)
    {
        self.list = parseList(tk, owner, parseModifier, ']');
    }
    function optimize()
    {
        optimize_array(self.list);
    }
    function getlist() { return self.list; }
    function pick(string name)
    {
        for (var mod in self.list) {
            if (mod.getname() == name)
                return mod;
        }
        return null;
    }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

inline getparrotkey(var path) return string
{
    string r;
    if (elements(path) != 0)
        r = "[ '" + string(join("'; '", path)) + "' ]";
    return r;
}

function parseUsing(t, tk, owner)
{
    var taux = tk.get();
    switch {
      case taux.iskeyword('extern'):
        return new ExternStatement(t, tk, owner);
      case taux.iskeyword('static'):
        return new StaticStatement(t, tk, owner);
      case taux.iskeyword('namespace'):
        return new UsingNamespaceStatement(taux, tk, owner);
      default:
        tk.unget(taux);
        return new UsingStatement(t, tk, owner);
    }
}

function parseSig(start, tk, owner)
{
    var params = new SigParameterList(tk, owner);
    var t = tk.get();
    if (! t.isop('='))
        Expected("'='", t);
    var expr = parseExpr(tk, owner);
    return new MultiAssignStatement(start, owner, params, expr);
}

function parseClassSpecifier(tk, owner)
{
    var t = tk.get();
    if (t.isstring())
        return new ClassSpecifierStr(owner, t);
    if (t.isop('['))
        return new ClassSpecifierParrotKey(tk, owner, t);
    if (t.isidentifier())
        return new ClassSpecifierId(tk, owner, t);
    SyntaxError('Invalid class', t);
}

function parseStatement(tk, owner)
{
    var t = tk.get();
    var t2;
    if (t.isop(';'))
        return new EmptyStatement;
    if (t.isop('{'))
        return new CompoundStatement(t, tk, owner);
    if (t.isop('${'))
        return new PiropStatement(t, tk, owner);
    if (t.isop(':')) {
        var open = tk.get();
        if (! open.isop('('))
            Unexpected("':'", t);
        return parseSig(t, tk, owner);
    }

    switch (t.checkkeyword()) {
      case 'using':
        return parseUsing(t, tk, owner);
      case 'const':
        return parseConst(t, tk, owner);
        break;
      case 'volatile':
        return parseVolatile(t, tk, owner);
        break;
      case 'var':
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseVar(t, tk, owner);
        break;
      case 'string':
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseString(t, tk, owner);
        break;
      case 'int':
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseInt(t, tk, owner);
        break;
      case 'float':
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseFloat(t, tk, owner);
        break;
      case 'return':
        return parseReturn(t, tk, owner);
      case 'yield':
        return new YieldStatement(t, tk, owner);
      case 'goto':
        return new GotoStatement(t, tk, owner);
      case 'if':
        return new IfStatement(t, tk, owner);
      case 'while':
        return new WhileStatement(t, tk, owner);
      case 'do':
        return new DoStatement(t, tk, owner);
      case 'continue':
        return new ContinueStatement(t, tk, owner);
      case 'break':
        return new BreakStatement(t, tk, owner);
      case 'switch':
        return parseSwitch(t, tk, owner);
      case 'for':
        return parseFor(t, tk, owner);
      case 'throw':
        return new ThrowStatement(t, tk, owner);
      case 'try':
        return new TryStatement(t, tk, owner);
    }

    if (t.isidentifier()) {
        var t2 = tk.get();
        if (t2.isop(':'))
            return new LabelStatement(t, owner);
        tk.unget(t2);
    }
    tk.unget(t);
    return new ExprStatement(t, tk, owner);
}

//*********************************************
//            Statement
//*********************************************

class Statement : CommonBase
{
    function Statement(start, owner)
    {
        self.initbase(start, owner);
    }
    function isempty() { return false; }
    function allowtailcall()
    {
        return self.owner.allowtailcall();
    }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function getlabel(string name)
    {
        return self.owner.getlabel(name);
    }
    function createlabel(name)
    {
        return self.owner.createlabel(name);
    }
    function createconst(name, string type, int flags [optional])
    {
        return self.owner.createconst(name, type, flags);
    }
    function createvar(name, string type, int flags[optional])
    {
        return self.owner.createvar(name, type, flags);
    }
    function createvarused(name, data)
    {
        return self.owner.createvarused(name, data);
    }
    function createvarnamed(name, string type, string pirname)
    {
        return self.owner.createvarnamed(name, type, pirname);
    }
    function getvar(name)
    {
        return self.owner.getvar(name);
    }
    function checkclass(string name)
    {
        return self.owner.checkclass(name);
    }
    function usenamespace(ns)
    {
        self.owner.usenamespace(ns);
    }

    function getouter()
    {
        // Returns the nearest outer scope. In this base case,
        // just propagate it. Deriveds that are appropiate
        // scopes will override.
        return self.owner.getouter();
    }
    function getcontinuelabel(pos)
    {
        return self.owner.getcontinuelabel(pos);
    }
    function getbreaklabel(pos)
    {
        return self.owner.getbreaklabel(pos);
    }
    function optimize()
    {
        InternalError('**checking**', self.start);
        // Return unchanged by default
        return self;
    }
}

class EmptyStatement : Statement
{
    function isempty() { return true; }
    function clone(owner) { return self; }
    function annotate(e)
    {
        InternalError('Attempt to annotate empty statement');
    }
    function optimize() { return self; }
    function emit(e)
    {
        // Do nothing
    }
}

class MultiStatementBase
{
    var statements;

    function optimize()
    {
        var statements = self.statements;
        int n = elements(statements);
        int empty = true;
        for (int i = 0; i < n; ++i) {
            var st = statements[i].optimize();
            if (empty && ! st.isempty())
                empty = false;
            statements[i] = st;
        }
        return empty ? new EmptyStatement : self;
    }
}

class MultiStatement : MultiStatementBase
{
    function MultiStatement(var st1, var st2)
    {
        self.statements = [st1, st2];
    }
    function clone(owner)
    {
        var cloned = new MultiStatement;
        cloned.statements = clone_array(self.statements, owner);
        return cloned;
    }
    function isempty() { return false; }
    function push(var statement)
    {
        push(self.statements, statement);
        return self;
    }
    function emit(e)
    {
        emit_array(e, self.statements);
    }
}

inline addtomulti(var multi, var newst) return var
{
    switch {
      case multi == null:
        return newst;
      case multi instanceof MultiStatement:
        return multi.push(newst);
      default:
        return new MultiStatement(multi, newst);
    }
}

//*********************************************
//           PiropStatement
//*********************************************

function parsePiropArg(tk, owner)
{
    var arg;
    var t = tk.get();
    if (t.isop(':')) {
        t = tk.get();
        if (! t.isidentifier())
            SyntaxError("Label expected", t);
        arg = new Reflabel(owner, t);
    }
    else {
        tk.unget(t);
        arg = parseExpr(tk, owner);
    }
    return arg;
}

class PiropStatement : Statement
{
    var opname;
    var args;

    function PiropStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        int dotted = t.isop('.');
        if (dotted)
            t = tk.get();
        string opname = t.getidentifier();
        self.opname = (dotted ? '.' : '') + opname;
        t = tk.get();
        if (! t.isop('}')) {
            tk.unget(t);
            self.args = parseList(tk, owner, parsePiropArg, '}');
        }
        ExpectOp(';', tk);
    }
    function clone(owner)
    {
        var cloned = new PiropStatement;
        cloned.Statement(self.start, owner);
        cloned.opname = self.opname;
        cloned.args = clone_array(self.args, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.args);
        return self;
    }
    function emit(e)
    {
        string opname = self.opname;
        self.annotate(e);
        if (e.getDebug())
            e.comment('pirop ' + opname);
        var args = self.args;
        e.print(INDENT);
        if (args == null)
            e.say(opname);
        else
            e.say(opname, ' ', join(', ',
                    transform(args, [], bindlast(bindmethod("emit_get"), e))
            ));
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement : Statement
{
    var path;
    function ExternStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(';', tk);
        self.path = toIdentifierList(path);
        return self;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        e.say(INDENT, "load_bytecode '", join('/', self.path), ".pbc'");
    }
}

//*********************************************
//            StaticStatement
//*********************************************

class StaticStatement : Statement
{
    var names;
    function StaticStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var names = parseList(tk, null, parseIdentifier, ';');
        for (var name in names) {
            string id = self.generatesubid();
            self.createvarnamed(name, REGvar, id);
        }
        self.names = names;
    }
    function optimize()
    {
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        for (var name in self.names)
            e.say(".const 'Sub' ", self.getvar(name).getreg(),
                    " = '", name, "'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement : Statement
{
    var path;
    var subid;

    function UsingStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(';', tk);
        self.path = path;
    }
    function optimize()
    {
        var path = self.path;
        var name = path[-1];

        var symbol = self.scopesearch(path, 0);
        switch {
          case symbol == null:
            if (elements(path) != 0) {
                var p = clone(path);
                p.pop();
                var ns = self.scopesearch(p, SEARCH_NAMESPACE);
                if (ns != null) {
                    symbol = ns.getvar(name);
                    if (symbol != null) {
                        self.createvarused(name, symbol);
                        return new EmptyStatement;
                    }
                }
            }
            break;
          case symbol instanceof FunctionStatement:
            string subid = symbol.makesubid();
            self.createvarnamed(name, REGvar, subid);
            self.subid = subid;
            self.usesubid(subid);
            return self;
        }
        self.createvar(name, REGvar);
        return self;
    }
    function emit(e)
    {
        var path = self.path;
        string name = path[-1];
        var vdata = self.getvar(name);
        if (self.subid == null) {
            self.annotate(e);
            string key;
            if (elements(path) > 1) {
                path.pop();
                key = getparrotkey(path);
            }
            e.emitget_hll_global(vdata.getreg(), name, key);
        }
    }
}

//*********************************************
//            UsingNamespaceStatement
//*********************************************

// Common part of using namespace from different kinds of scopes.
function usingNamespace(start, tk, owner)
{
    var nskey = parseDotted(tk);
    if (elements(nskey) == 0)
        Expected('namespace identifier', start);
    var nssym = owner.scopesearch(nskey, SEARCH_NAMESPACE);
    if (nssym == null)
        SyntaxError('unknow namespace', start);
    owner.usenamespace(nssym);
}

class UsingNamespaceStatement : Statement
{
    function UsingNamespaceStatement(start, tk, owner)
    {
        self.Statement(tk, owner);
        usingNamespace(start, tk, owner);
        ExpectOp(';', tk);
    }
    function optimize()
    {
        return self;
    }
    function emit(e)
    {
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function ExprStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var expr = [];
        var t;
        do {
            var newexpr = parseExpr(tk, self);
            expr.push(newexpr);
        } while ((t = tk.get()).isop(','));
        RequireOp(';', t);
        self.expr = expr;
    }
    function clone(owner)
    {
        var cloned = new ExprStatement;
        cloned.Statement(self.start, owner);
        cloned.expr = clone_array(self.expr, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.expr);
        return self;
    }
    function emit(e)
    {
        for_each(self.expr, bindlast(bindmethod("emit_void"), e));
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarData
{
    var type;
    var reg;
    var scope;
    var flags;
    var lexname;

    function VarData(string type, reg, scope, int flags)
    {
        // Sanity check
        __ASSERT__(type == REGint || type == REGfloat || type == REGstring ||
                type == REGvar);

        self.type = type;
        self.reg = reg;
        self.scope = scope;
        self.flags = flags;
    }
    function setlex(string name)
    {
        self.lexname = name;
    }
    function createlex(string lexname)
    {
        // Set the lexname and make the variable a lexical
        // in its outer.
        self.setlex(lexname);
        self.getscope().getouter().setlex(lexname, self.reg);
    }
    function gettype() { return self.type; }
    function getreg() { return self.reg; }
    function getscope() { return self.scope; }
    function getvalue() { return self.value; }
    function isconst() { return false; }
    function getlex()
    {
        var lexname = self.lexname;
        return lexname != null ? string(lexname) : null;
    }
    function getflags() { return self.flags; }
    function issubid()
    {
        var reg = self.reg;
        return reg != null && substr(reg, 0, 7) == 'WSubId_';
    }
}

class ConstantInternalFail
{
    var name;
    function ConstantInternalFail(var name)
    {
        self.name = name;
    }
    function get_string[vtable]()
    {
        InternalError('Attempt to use unexpanded constant!!!', self.name);
    }
}

class VarData_const : VarData
{
    var value;

    function VarData_const(string type, name, scope, int flags)
    {
        self.VarData(type, new ConstantInternalFail(name), scope, flags);
    }
    function isconst() { return true; }
    function setvalue(value)
    {
        if (self.value != null)
            InternalError('Attempt change value of constant!!!');
        self.value = value;
    }
}


class VarContainer
{
    var locals;
    var usednamespaces;

    function VarContainer()
    {
        self.locals = {};
    }
    function createvar(var name, string type, int flags[optional])
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        string reg = self.createreg(type);
        var data = new VarData(type, reg, self, flags);
        locals[sname] = data;
        return data;
    }
    function createvarused(name, data)
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        locals[sname] = data;
    }
    function createvarnamed(var name, string type, string pirname)
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        locals[sname] = new VarData(type, pirname, self, 0);
    }
    function createconst(var name, string type, int flags[optional])
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            SyntaxError("Redeclared '" + sname + "'", name);
        var data = new VarData_const(type, name, self, flags);
        locals[sname] = data;
        return data;
    }
    function getlocalvar(var name)
    {
        var locals = self.locals;
        return locals[string(name)];
    }
    function getusedvar(var name)
    {
        var sym;
        for (var ns in self.usednamespaces) {
            if ((sym = ns.getlocalvar(name)) != null)
                return sym;
        }
        return null;
    }
    function getvar(var name)
    {
        var sym;
        if ((sym = self.getlocalvar(name)) != null)
            return sym;
        if ((sym = self.getusedvar(name)) != null)
            return sym;
        var owner = self.owner;
        if (owner != null)
            return owner.getvar(name);
        return null;
    }
    function makelexical(vardesc)
    {
        var lexowner = self.getouter();
        string lexname = lexowner.createlex(vardesc);
        return lexname;
    }
    function makelexicalself()
    {
        const string lexname = "'__WLEX_self'";
        self.setlex(lexname, SELF);
        return lexname;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
    function BlockStatement(start, owner)
    {
        self.Statement(start, owner);
        self.VarContainer();
    }
}

//*********************************************
//            Expr
//*********************************************

class Expr : CommonBase
{
    function Expr(owner, start)
    {
        self.initbase(start, owner);
    }
    function issimple() { return false; }
    function isliteral() { return false; }
    function isintegerliteral() { return false; }
    function isintegerzero() { return false; }
    function isfloatliteral() { return false; }
    function isstringliteral() { return false; }
    function isidentifier() { return false; }
    function isnull() { return false; }
    function hascompilevalue() { return false; }
    function isnegable() { return false; }
    function tempreg(type)
    {
        return self.owner.tempreg(type);
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function optimize()
    {
        // By default return same expression unchanged
        return self;
    }
    function cantailcall() { return false; }
    function emit_init(e, string result)
    {
        // By default does the same as plane emit, some expressions
        // can override it for optimization.
        self.emit(e, result);
    }
    function emit_get(e)
    {
        string reg = self.tempreg(self.checkresult());
        self.emit(e, reg);
        return reg;
    }
    function emit_void(e)
    {
        string type = self.checkresult();
        string reg;
        switch (type) {
          case REGint:    reg = DISCARD_IREG; break;
          case REGfloat:  reg = DISCARD_NREG; break;
          case REGstring: reg = DISCARD_SREG; break;
          case REGvar:    reg = DISCARD_PREG; break;
          default:
            InternalError("Unexcpected emit_void with type '" + type + "'", self.start);
        }
        self.emit(e, reg);
    }
    function emit_get_nonull(e)
    {
        // Must be overriden by any possible null
        return self.emit_get(e);
    }
    function emit_getint(e)
    {
        string reg = self.emit_get_nonull(e);
        if (self.checkresult() != REGint) {
            string aux = self.tempreg(REGint);
            self.annotate(e);
            e.emitset(aux, reg);
            reg = aux;
        }
        return reg;
    }
    function emit_getvar(e)
    {
        string type = self.checkresult();
        string reg = self.emit_get(e);
        if (type != REGvar) {
            string auxreg = reg;
            reg = self.tempreg(REGvar);
            e.emitbox(reg, auxreg);
        }
        return reg;
    }
    function emit_assign_get(e, expr)
    {
        NoLeftSide(self);
    }
}

class SimpleExpr : Expr
{
    function issimple() { return true; }
}


class FinalExpr : Expr
// An expr crated during optimize, never parsed
{
    function optimize()
    {
        InternalError("misuse of " + string(typeof(self)), self);
    }
}

//**********************************************************************

class FunctionExpr : Expr
{
    var fn;
    function FunctionExpr(tk, owner, start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        if (!t.isop('('))
            Expected('anonymous function', t);
        self.fn = new LocalFunctionStatement(start, tk, owner);
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.fn = self.fn.optimize();
        self.usesubid(self.fn.getsubid());
        return self;
    }
    function emit(e, string result)
    {
        self.annotate(e);
        var fn = self.fn;
        string subid = fn.getsubid();
        if (fn.needclosure())
            e.emitarg2('newclosure', result, subid);
        else
            e.emitset(result, subid);
    }
    function emit_void(e)
    {
    }
}

//*********************************************

// Condition class, contains and works with expressions used in
// conditional operators and statements.

const int CONDisruntime = 0, CONDistrue = 1, CONDisfalse = 2;

class ConditionFriendlyExpr
{
    // Abstract base class for expressions with specialized code generation
    // for conditions.
    function emit_if(e, string labeltrue)
    {
        InternalError(__FUNCTION__ + " not overriden", self);
    }
    function emit_else(e, string labelfalse)
    {
        InternalError(__FUNCTION__ + " not overriden", self);
    }
}

class Condition
{
    var condexpr;
    function set(expr)
    {
        self.condexpr = expr;
        return self;
    }
    function optimize_condition()
    {
        self.condexpr = self.condexpr.optimize();
    }
    function optimize()
    {
        self.condexpr = self.condexpr.optimize();
        return self;
    }
    function getvalue()
    {
        var condexpr = self.condexpr;
        if (condexpr.isintegerliteral())
            return condexpr.isintegerzero() ? CONDisfalse : CONDistrue;
        return CONDisruntime;
    }
    function emit_if(e, string labeltrue, string labelfalse)
    {
        var condexpr = self.condexpr;

        if (condexpr instanceof ConditionFriendlyExpr)
            condexpr.emit_if(e, labeltrue);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGstring:
              case REGint:
              case REGfloat:
                e.emitif(reg, labeltrue);
                break;
              default:
                InternalError('Invalid if condition');
            }
        }
    }
    function emit_else(e, string labelfalse)
    {
        var condexpr = self.condexpr;

        if (condexpr instanceof ConditionFriendlyExpr)
            condexpr.emit_else(e, labelfalse);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGstring:
              case REGint:
              case REGfloat:
                e.emitunless(reg, labelfalse);
                break;
              default:
                InternalError('Invalid if condition');
            }
        }
    }
}

//*********************************************

class Literal : SimpleExpr
{
    function isliteral() { return true; }
    function hascompilevalue() { return true; }
    function emit_void(e) { }
}

//*********************************************

class StringLiteral : Literal
{
    var strval;
    function StringLiteral(owner, t)
    {
        self.Expr(owner, t);
        self.strval = t;
    }
    function clone(owner)
    {
        return new StringLiteral(owner, self.strval);
    }
    function isstringliteral() { return true; }
    function checkresult() { return REGstring; }
    function getPirString()
    {
        var strtok = self.strval;
        string str = strtok.getPirString();
        return str;
    }
    function get_value()
    {
        var strtok = self.strval;
        string str = strtok.str;
        if (strtok instanceof TokenQuoted)
            str = unescape(str);
        return str;
    }
    function emit(e, string result)
    {
        e.emitset(result, self.getPirString());
    }
    function emit_get(e)
    {
        return self.getPirString();
    }
}

//*********************************************

class IntegerLiteral : Literal
{
    var pos;
    var numval;
    function IntegerLiteral(owner, t, value)
    {
        self.Expr(owner, t);
        self.pos = t;
        int n = value;
        self.numval = n;
    }
    function clone(owner)
    {
        return new IntegerLiteral(owner, self.pos, self.numval);
    }
    function isintegerliteral() { return true; }
    function isintegerzero()
    {
        return int(self.numval) == 0;
    }
    function checkresult() { return REGint; }
    function getIntegerValue()
    {
        return self.numval;
    }
    function getFloatValue()
    {
        float value = self.getIntegerValue();
        return value;
    }
    function emit(e, string result)
    {
        int value = self.getIntegerValue();
        if (value == 0)
            e.emitnull(result);
        else
            e.emitset(result, value);
    }
    function emit_get(e)
    {
        return self.getIntegerValue();
    }
    function emit_getint(e)
    {
        // Just a shortcut
        return self.getIntegerValue();
    }
}

//*********************************************

class FloatLiteral : Literal
{
    var numval;
    function FloatLiteral(owner, t)
    {
        self.Expr(owner, t);
        self.numval = t;
    }
    function clone(owner)
    {
        return new FloatLiteral(owner, self.numval);
    }
    function isfloatliteral() { return true; }
    function checkresult() { return REGfloat; }
    function getFloatValue()
    {
        float value = self.numval.getfloatvalue();
        return value;
    }
    function emit(e, string result)
    {
        string n = self.emit_get(e);
        e.emitset(result, n);
    }
    function emit_get(e)
    {
        float value = self.getFloatValue();
        return floatAsString(value);
    }
}

//*********************************************

function concat_literal(lexpr, rexpr)
{
    __ASSERT__(lexpr.isstringliteral());
    __ASSERT__(rexpr.isstringliteral());

    var etok = lexpr.strval;
    var rtok = rexpr.strval;
    // If both are single quoted, result is single quoted.
    // If one is double quoted, result is double quoted.
    var t = etok.issinglequoted() && rtok.issinglequoted()
        ?
        new TokenSingleQuoted(etok.file, etok.line,
                string(etok.str) + string(rtok.str))
        :
        new TokenQuoted(etok.file, etok.line,
                string(etok.getasquoted()) + string(rtok.getasquoted()));
    return new StringLiteral(lexpr.owner, t);
}

//*********************************************

class FunctionId : FinalExpr
{
    var subid;
    function FunctionId(owner, start, name, string id)
    {
        self.Expr(owner, start);
        self.subid = id;
    }
    function checkresult() { return REGvar; }
    function emit_get(e)
    {
        return self.subid;
    }
    function emit(e, string result)
    {
        e.emitset(result, self.subid);
    }
}

class FunctionRef : FinalExpr
{
    var sym;
    function FunctionRef(owner, start, sym)
    {
        self.Expr(owner, start);
        self.sym = sym;
    }
    function checkresult() { return REGvar; }
    function emit(e, string result)
    {
        var sym = self.sym;
        var path = sym.owner.getpath();
        self.annotate(e);
        path.emit_get_global(e, self.owner, result, sym.name);
    }
}

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return true; }
    function IdentifierExpr(owner, t)
    {
        self.Expr(owner, t);
        self.name = t;
    }
    function clone(owner)
    {
        var cloned = new IdentifierExpr;
        cloned.Expr(owner, self.start);
        cloned.name = self.name;
        return cloned;
    }
    function isnull()
    {
        var name = self.name;
        if (self.owner.getvar(name) != null)
            return false;
        return name.iskeyword(NULL);
    }
    function emit_get_nonull(e)
    {
        if (self.isnull())
            SyntaxError("Invalid 'null' usage", self);
        return self.emit_get(e);
    }
    function checkresult()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null)
            return desc.gettype();
        else {
            switch (name) {
              case SELF:
              case NULL:
                return REGvar;
              default:
                return '';
            }
        }
    }
    function getName()
    {
        string s = self.name;
        return s;
    }
    function checkVar()
    {
        return self.owner.getvar(string(self.name));
    }
    function checkIdentifier()
    {
        var name = self.name;
        if (name == null)
            InternalError('Bad thing');
        var desc = self.owner.getvar(name);
        string s;
        if (desc == null) {
            switch (name) {
              case SELF:
              case NULL:
                s = name; break;
              default:
                s = '';
            }
        }
        else
            s = desc.getreg();
        return s;
    }
    function getIdentifier()
    {
        var value = self.checkIdentifier();
        if (value == '')
            UndefinedVariable(self.name, self);
        return value;
    }
    function optimize()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null) {
            __ASSERT__(desc instanceof VarData);
            if (desc.isconst())
                return desc.getvalue();
            int flags = desc.getflags();
            if (flags & VAR_is_volatile) {
                if (flags & VAR_is_lexical)
                    return new LexicalVolatileExpr(self, desc);
            }
            else {
                // const Sub previous definition may be in a code path
                // not taken. Better allow redundant definitions than
                // leave undefined depending on runtime conditions.
                // TODO: improve this.
                var reg = desc.getreg();
                if (reg != null && substr(reg, 0, 7) == 'WSubId_')
                    return new FunctionId(self.owner, self.start, name, reg);
            }
        }
        else {
            var sym = self.scopesearch([name], 0);
            switch {
              case sym == null:
                break;
              case sym instanceof FunctionStatement:
                if (!sym.ismulti()) {
                    string id = sym.makesubid();
                    self.usesubid(id);
                    self.owner.createvarnamed(name, REGvar, id);
                    return new FunctionId(self.owner, self.start, name, id);
                }
                else
                    return new FunctionRef(self.owner, self.start, sym);
                break;
              case sym instanceof FunctionExtern:
                return new FunctionRef(self.owner, self.start, sym);
              case sym instanceof InlineStatement:
                return new InlineRef(self.owner, self.start, sym);
            }
        }
        return self;
    }
    function emit(e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(e) { }
    function emit_get(e)
    {
        string reg;
        reg = self.getIdentifier();
        var desc = self.owner.getvar(self.name);
        int flags = desc == null ? 0 : desc.getflags();
        if (flags & VAR_is_volatile) {
            if (flags & VAR_is_lexical) {
                string lexname = desc.getlex();
                if (lexname != null)
                    self.annotate(e);
                    e.emitfind_lex(reg, lexname);
            }
        }
        return reg;
    }
    function emit_assign_get(e, expr)
    {
        self.annotate(e);
        if (self.isnull())
            SyntaxError("Cannot assign to null", self);
        string typeleft = self.checkresult();
        string lreg = self.getIdentifier();
        if (expr.isnull()) {
            switch (typeleft) {
              case REGstring:
              case REGvar:
                e.emitnull(lreg);
                break;
              default:
                SyntaxError("Can't assign null to that type", self);
            }
        }
        else if (expr instanceof IndexExpr)
            expr.emit(e, lreg);
        else {
            string typeright = expr.checkresult();
            if (typeright == REGnone)
                SyntaxError("Can't assign from void expression", self);
            if (typeleft == typeright) {
                expr.emit(e, lreg);
            }
            else {
                string rreg = expr.emit_get(e);
                self.annotate(e);
                if (typeleft == REGvar && typeright != REGvar)
                    e.emitbox(lreg, rreg);
                else
                    e.emitset(lreg, rreg);
            }
        }
        return lreg;
    }
}

//*********************************************

class LexicalVolatileExpr : FinalExpr
{
    var desc;
    function LexicalVolatileExpr(idexpr, desc)
    {
        self.Expr(idexpr.owner, idexpr.start);
        self.desc = desc;
    }
    function checkresult()
    {
        return self.desc.gettype();
    }
    function emit_get(e)
    {
        var desc = self.desc;
        string lexname = desc.getlex();
        string reg = self.owner.tempreg(desc.gettype());
        e.emitfind_lex(reg, lexname);
        return reg;
    }
    function emit(e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_assign_get(e, expr)
    {
        var owner = self.owner;
        var desc = self.desc;
        string typelex = desc.gettype();
        string lreg;
        switch {
          case expr.isnull():
            lreg = owner.tempreg(typelex);
            e.emitnull(lreg);
            break;
          case expr instanceof IndexExpr:
            lreg = owner.tempreg(typelex);
            expr.emit(e, lreg);
            break;
          default:
            if (typelex == REGvar)
                lreg = expr.emit_getvar(e);
            else if (typelex == expr.checkresult())
                lreg = expr.emit_get(e);
            else {
                lreg = owner.tempreg(typelex);
                expr.emit(e, lreg);
            }
        }

        e.emitstore_lex(desc.getlex(), lreg);
        return lreg;
    }
    function emit_store(e, reg)
    {
        e.emitstore_lex(self.desc.getlex(), reg);
    }
}

//*********************************************

class OpExpr : Expr
{
    function initop(owner, start)
    {
        self.Expr(owner, start);
    }
}

//*********************************************

class OpNamespaceExpr : OpExpr
{
    var key;
    function OpNamespaceExpr(tk, owner, start)
    {
        self.initop(owner, start);
        self.key = parseDotted(tk);
        if (elements(self.key) == 0)
            Expected('namespace identifier', start);
    }
    function checkresult() { return REGvar; }
    function emit(e, string result)
    {
        var owner = self.owner;
        var sym = owner.scopesearch(self.key, SEARCH_NAMESPACE);
        if (sym == null)
            SyntaxError('unknown namespace', self);
        var path = sym.getpath();
        path.emit_get_namespace(e, owner, result);
    }
}

//*********************************************

class OpClassExpr : OpExpr
{
    var clspec;

    function OpClassExpr(tk, owner, start)
    {
        self.initop(owner, start);
        self.clspec = parseClassSpecifier(tk, owner);
    }
    function checkresult() { return REGvar; }
    function get_class_raw_key()
    {
        var owner = self.owner;
        var clspec = self.clspec;
        var clkey;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifierParrotKey:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifier:
            SyntaxError(string(typeof(clspec)) + " not supported yet here",
                    clspec.start);
        }
        InternalError("Unexpected class key", clspec.start);
    }
    function emit(e, string result)
    {
        var owner = self.owner;
        var clspec = self.clspec;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            var clkey = clspec.checknskey(owner);
            if (clkey != null) {
                clkey.emit_get_class(e, owner, result);
                return;
            }
            break;
        }

        e.print(INDENT + 'get_class ', result, ', ');
        clspec.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpUnaryExpr : OpExpr
{
    var subexpr;
    function OpUnaryExpr(owner, start, subexpr)
    {
        self.initop(owner, start);
        self.subexpr = subexpr;
    }
    function cloneunary(cloned, owner)
    {
        cloned.OpUnaryExpr(owner, self.start, self.subexpr.clone(owner));
        return cloned;
    }
    function optimizearg()
    {
        self.subexpr = self.subexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpBinaryExpr : OpExpr
{
    var lexpr;
    var rexpr;
    function initbinary(owner, start, lexpr, rexpr)
    {
        self.initop(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
    }
    function set(owner, t, lexpr, rexpr)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        return self;
    }
    function clonebinary(cloned, owner)
    {
        cloned.initbinary(owner, self.start,
                self.lexpr.clone(owner), self.rexpr.clone(owner));
        return cloned;
    }
    function setfrom(from)
    {
        return self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function optimizearg()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
    function emit_intleft(e)
    {
        return self.lexpr.emit_getint(e);
    }
    function emit_intright(e)
    {
        return self.rexpr.emit_getint(e);
    }
}

//*********************************************

class OpBinaryIntExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = lexpr.getIntegerValue();
            int ri = rexpr.getIntegerValue();
            return integerValue(self.owner, self.start, self.do_op(li, ri));
        }
        return self;
    }
}

//*********************************************

class OpDelExBase : OpUnaryExpr
{
    function checkresult()
    {
        return REGint;
    }
}


class OpDeleteExpr : OpDelExBase
{
    function OpDeleteExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function optimize()
    {
        self.optimizearg();
        var expr = self.subexpr;
        if ((!(expr instanceof IndexExpr)) || expr.checkresult() == REGstring)
            SyntaxError("delete with invalid operator", self);
        return self;
    }
    function emit_void(e)
    {
        var expr = self.subexpr;
        expr.emit_prep(e);
        self.annotate(e);
        e.print(INDENT + 'delete ');
        expr.emit_aux(e);
        e.say();
    }
    function emit(e, string result)
    {
        self.emit_void(e);
        e.emitset(result, '1');
    }
}

class OpExistsExpr : OpDelExBase
{
    function OpExistsExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit(e, string result)
    {
        var expr = self.subexpr;
        if (expr instanceof IndexExpr && expr.checkresult() != REGstring) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print(INDENT + 'exists ', result, ', ');
            expr.emit_aux(e);
            e.say();
        }
        else
            SyntaxError("exists with invalid operator", self);
    }
}

//*********************************************

class OpUnaryMinusExpr : OpUnaryExpr
{
    function OpUnaryMinusExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpUnaryMinusExpr, owner);
    }
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(owner, t, subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        var subexpr = self.subexpr;
        self.optimizearg();
        if (subexpr.isintegerliteral()) {
            int i = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, -i);
        }
        if (subexpr.isfloatliteral()) {
            float n = subexpr.getFloatValue();
            return floatValue(self.owner, subexpr.start, -n);
        }
        return self;
    }
    function emit(e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2('neg', result, reg);
    }
}

//*********************************************

class OpNotExpr : OpUnaryExpr, ConditionFriendlyExpr
{
    function OpNotExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpNotExpr, owner);
    }
    function isnegable() { return true; }
    function checkresult()
    {
        return REGint;
    }
    function set(owner, t, subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            int n = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, ! n);
        }
        if (subexpr.isnegable())
            return subexpr.negated();
        return self;
    }
    function negated()
    {
        return self.subexpr;
    }
    function emit(e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_get(e);
        self.annotate(e);
        switch (subexpr.checkresult()) {
          case REGint:
            e.emitarg2('not', result, reg);
            break;
          case REGstring:
            // No appropiate op for string. Do it the hard way.
            e.emitset(result, 0);
            string label = self.genlabel();
            e.emitif(reg, label);
            e.emitinc(result);
            e.emitlabel(label);
            break;
          case REGvar:
            e.emitarg2('isfalse', result, reg);
            break;
          default:
            e.emitarg2('isfalse', result, reg);
        }
    }
    function emit_if(e, string labelif)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitunless(reg, labelif);
    }
    function emit_else(e, string labelelse)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitif(reg, labelelse);
    }
}

//*********************************************

class OpBinNotExpr : OpUnaryExpr
{
    function OpBinNotExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpBinNotExpr, owner);
    }
    function checkresult()
    {
        return REGint;
    }
    function set(owner, t, subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            int n = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, ~ n);
        }
        if (subexpr.isnegable())
            return subexpr.negated();
        return self;
    }
    function emit(e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_getint(e);
        self.annotate(e);
        e.emitarg3('bxor', result, reg, -1);
    }
}

//*********************************************

class OpIncDec : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function iflexical(e, reg)
    {
        var expr = self.subexpr;
        if (expr instanceof LexicalVolatileExpr)
            expr.emit_store(e, reg);
    }
}

//*********************************************

class OpPreIncDec : OpIncDec
{
    function emit(e, string result)
    {
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_void(e)
    {
        self.emit_get(e);
    }
}

class OpPreIncExpr : OpPreIncDec
{
    function OpPreIncExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpPreIncExpr, owner);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

class OpPreDecExpr : OpPreIncDec
{
    function OpPreDecExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpPreDecExpr, owner);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

//*********************************************

class OpPostIncExpr : OpIncDec
{
    function OpPostIncExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpPostIncExpr, owner);
    }
    function emit(e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2('clone', aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2('clone', result, reg);
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
}

class OpPostDecExpr : OpIncDec
{
    function OpPostDecExpr(owner, start, subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(owner)
    {
        return self.cloneunary(new OpPostDecExpr, owner);
    }
    function emit(e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2('clone', aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
    function emit_get(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2('clone', result, reg);
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
    }
}

//*********************************************

class OpBaseAssignExpr : Expr
{
    var lexpr;
    var rexpr;
    function set(owner, start, lexpr, rexpr)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
        return self;
    }
    function cloneassign(cloned, owner)
    {
        return cloned.set(owner, self.start,
                self.lexpr.clone(owner), self.rexpr.clone(owner));
    }
    function checkresult()
    {
        return self.lexpr.checkresult();
    }
    function optimize_base()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_base();
    }
    function checkleft()
    {
        var lexpr = self.lexpr;
        if (lexpr.isnull() || lexpr.isliteral())
            NoLeftSide(lexpr);
    }
    function emit(e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(e)
    {
        self.emit_get(e);
    }
}

//*********************************************

class OpAssignExpr : OpBaseAssignExpr
{
    function clone(owner)
    {
        return self.cloneassign(new OpAssignExpr, owner);
    }
    function emit_get(e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        return lexpr.emit_assign_get(e, self.rexpr);
    }
    function emit_void(e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        lexpr.emit_assign_get(e, self.rexpr);
    }
}

//*********************************************

class OpAssignToExpr : OpBaseAssignExpr
{
    function emit(e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitassign(result, reg);
    }
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        if (lexpr.checkresult() != REGvar)
            SyntaxError("Wrong dest type in =:", lexpr);
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitassign(reg, reg2);
        return reg;
    }
    function emit_void(e)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
    }
}

//*********************************************

class OpAddToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        if (ltype == REGstring && (rexpr instanceof ConcatString))
            rexpr.emit_concat_to(e, reg);
        else {
            string reg2 = rexpr.emit_get(e);
            string aux;
            self.annotate(e);
            switch (ltype) {
              case REGstring:
                if (rtype != REGstring) {
                    aux = self.tempreg(REGstring);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitconcat1(reg, reg2);
                break;
              case REGint:
              case REGfloat:
                if (ltype != rtype) {
                    aux = self.tempreg(ltype);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitaddto(reg, reg2);
                break;
              default:
                e.emitaddto(reg, reg2);
            }
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpSubToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        string reg2 = rexpr.emit_get(e);
        string aux;
        self.annotate(e);
        switch (ltype) {
          case REGstring:
            SyntaxError("-= can't be applied to string", self);
          case REGint:
          case REGfloat:
            if (ltype != rtype) {
                aux = self.tempreg(ltype);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitsubto(reg, reg2);
            break;
          default:
            e.emitsubto(reg, reg2);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpMulToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string lreg = lexpr.emit_get(e);
        string rreg;
        switch (lexpr.checkresult()) {
          case REGstring:
            rreg = rexpr.emit_getint(e);
            self.annotate(e);
            e.emitrepeat(lreg, lreg, rreg);
            break;
          default:
            rreg = rexpr.emit_get(e);
            self.annotate(e);
            e.emitarg2('mul', lreg, rreg);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, lreg);
        return lreg;
    }
}

//*********************************************

class OpDivToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2('div', reg, reg2);
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpModToExpr : OpBaseAssignExpr
{
    function emit_get(e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2('mod', reg, reg2);
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

const int
    COMPARATOR_DEFAULT = 0,
    COMPARATOR_IF      = 1,
    COMPARATOR_ELSE    = 2;

class ComparatorBaseExpr : OpBinaryExpr, ConditionFriendlyExpr
{
    function checkresult() { return REGint; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = lexpr.getIntegerValue();
            int ri = rexpr.getIntegerValue();
            return integerValue(self.owner, self.start, self.int_op(li, ri));
        }
        return self;
    }
    function emit_comparator(e, string result, int doifelse[optional])
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        string regl = self.lexpr.emit_get(e);
        string regr = self.rexpr.emit_get(e);
        self.annotate(e);
        string aux;
        switch {
          case rl == REGint && rr == REGfloat:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rl == REGfloat && rr == REGint:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGint && rl == REGvar:
            aux = self.tempreg(REGint);
            e.emitset( aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGint:
            aux = self.tempreg(REGint);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGstring && rl == REGvar:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGstring:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regr);
            regr = aux;
            break;
        }

        switch (doifelse) {
          case COMPARATOR_DEFAULT:
            self.emitop(e, result, regl, regr);
            break;
          case COMPARATOR_IF:
            self.emitop_if(e, result, regl, regr);
            break;
          case COMPARATOR_ELSE:
            self.emitop_else(e, result, regl, regr);
            break;
        }
    }
    function emit(e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emit_if(e, string labeltrue)
    {
        self.emit_comparator(e, labeltrue, COMPARATOR_IF);
    }
    function emit_else(e, string labelfalse)
    {
        self.emit_comparator(e, labelfalse, COMPARATOR_ELSE);
    }
}

//*********************************************

class Negable
{
    var positive;

    function Negable(int positive)
    {
        self.positive = new ["Boolean"](positive);
    }
    function isnegable() { return true; }
    function negated()
    {
        int positive = ! self.positive;
        self.positive =: positive;
        return self;
    }
}

//*********************************************

// Null checkers, created during optimize of Equal and NotEqual
// to simplify its emit functions.

class CheckerExpr : Expr, Negable, ConditionFriendlyExpr
{
    var expr;

    function CheckerExpr(base, expr, int positive)
    {
        self.Expr(base.owner, base.start);
        self.Negable(positive);
        self.expr = expr;
    }
    function isnegable() { return true; }
    function checkresult() { return REGint; }
}

class NullCheckerExpr : CheckerExpr
{
    function NullCheckerExpr(base, expr, int checknull)
    {
        self.CheckerExpr(base, expr, checknull);
    }
    function emit(e, string result)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        e.emitarg2('isnull', result, reg);
        if (! self.positive)
            e.emitarg1('not', result);
    }
    function emit_if(e, string labelif)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitif_null(reg, labelif);
        else
            e.emitunless_null(reg, labelif);
    }
    function emit_else(e, string labelelse)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless_null(reg, labelelse);
        else
            e.emitif_null(reg, labelelse);
    }
}

class ZeroCheckerExpr : CheckerExpr
{
    function ZeroCheckerExpr(base, expr, int positive)
    {
        self.CheckerExpr(base, expr, positive);
    }
    function emit(e, string result)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitarg3('iseq', result, reg, 0);
        else
            e.emitarg3('isne', result, reg, 0);
    }
    function emit_if(e, string labelif)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless(reg, labelif);
        else
            e.emitif(reg, labelif);
    }
    function emit_else(e, string labelelse)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitif(reg, labelelse);
        else
            e.emitunless(reg, labelelse);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr, Negable
{
    function OpEqualExpr(owner, start, lexpr, rexpr, int positive)
    {
        self.set(owner, start, lexpr, rexpr);
        self.Negable(positive);
    }
    function clone(owner)
    {
        var cloned = self.clonebinary(new OpEqualExpr, owner);
        cloned.Negable(self.positive);
        return cloned;
    }
    function isnegable() { return true; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        int lnull = lexpr.isnull();
        int rnull = rexpr.isnull();
        if (lnull) {
            if (rnull)
                return integerValue(self.owner, self.start, self.positive);
            else
                return new NullCheckerExpr(self, rexpr, self.positive);
        }
        if (rnull)
            return new NullCheckerExpr(self, lexpr, self.positive);
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == rtype) {
                switch (ltype) {
                  case REGint:
                    int li = lexpr.getIntegerValue();
                    int ri = rexpr.getIntegerValue();
                    int vi = self.positive ? li == ri : li != ri;
                    return integerValue(self.owner, self.start, vi);
                  case REGstring:
                    string ls = (lexpr.strval).str;
                    string rs = (rexpr.strval).str;
                    int vs = self.positive ? ls == rs : ls != rs;
                    return integerValue(self.owner, self.start, vs);
                }
            }
        }
        if (rexpr.isintegerzero())
            return new ZeroCheckerExpr(self, lexpr, self.positive);
        if (lexpr.isintegerzero())
            return new ZeroCheckerExpr(self, rexpr, self.positive);
        return self;
    }
    function emitop(e, string result, string regl, string regr)
    {
        self.annotate(e);
        e.emitbinop(self.positive ? 'iseq' : 'isne', result, regl, regr);
    }
    function emit(e, string result)
    {
        self.annotate(e);
        self.emit_comparator(e, result);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? 'eq' : 'ne', regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? 'ne' : 'eq', regl, regr, labelelse);
    }
}


//**********************************************************************

class OpSameExpr : ComparatorBaseExpr, Negable
{
    var positive;
    function OpSameExpr(owner, t, lexpr, rexpr, int positive)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        self.Negable(positive);
    }
    function clone(owner)
    {
        var cloned = self.clonebinary(new OpSameExpr, owner);
        cloned.Negable(self.positive);
        return cloned;
    }
    function isnegable() { return true; }
    function int_op(int left, int right)
    {
        return self.positive ? (left == right) : (left != right);
    }
    function emitop(e, string result, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? 'issame' : 'isntsame';
        e.emitbinop(op, result, regl, regr);
    }
    function emit(e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? 'eq_addr' : 'ne_addr';
        e.emitcompare(op, regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? 'ne_addr' : 'eq_addr';
        e.emitcompare(op, regl, regr, labelelse);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function clone(owner)
    {
        return self.clonebinary(new OpLessExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left < right;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('islt', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.emitcompare('lt', regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.emitcompare('ge', regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function clone(owner)
    {
        return self.clonebinary(new OpGreaterExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left > right;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isgt', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.emitcompare('gt', regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.emitcompare('le', regl, regr, labelelse);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function clone(owner)
    {
        return self.clonebinary(new OpLessEqualExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left <= right;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isle', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.emitcompare('le', regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.emitcompare('gt', regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function clone(owner)
    {
        return self.clonebinary(new OpGreaterEqualExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left >= right;
    }
    function emitop(e, string result, string regl, string regr)
    {
        e.emitbinop('isge', result, regl, regr);
    }
    function emitop_if(e, string labeltrue, string regl, string regr)
    {
        e.emitcompare('ge', regl, regr, labeltrue);
    }
    function emitop_else(e, string labelelse, string regl, string regr)
    {
        e.emitcompare('lt', regl, regr, labelelse);
    }
}

//*********************************************

class OpBaseBoolExpr : OpBinaryExpr
{
    function checkresult()
    {
        return self.lexpr.checkresult() == REGint && self.rexpr.checkresult() == REGint ?
            REGint : REGvar;
    }
}

//*********************************************

class OpBoolAndExpr : OpBaseBoolExpr
{
    function OpBoolAndExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpBoolAndExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln != 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('and', result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitunless(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('and', DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitunless(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
}

//*********************************************

class OpBoolOrExpr : OpBaseBoolExpr
{
    function OpBoolOrExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpBoolOrExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln == 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('or', result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitif(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop('or', DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitif(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
}

//*********************************************

class OpBaseBinExpr : OpBinaryIntExpr
{
}

//*********************************************

class OpBinAndExpr : OpBaseBinExpr
{
    function OpBinAndExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpBinAndExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('band', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left & right;
    }
}

//*********************************************

class OpBinOrExpr : OpBaseBinExpr
{
    function OpBinOrExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpBinOrExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('bor', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left | right;
    }
}

//*********************************************

class OpBinXorExpr : OpBaseBinExpr
{
    function OpBinXorExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('bxor', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left ^ right;
    }
}

//*********************************************

class ConcatString : FinalExpr
{
    var values;
    function ConcatString(owner, start, lexpr, rexpr)
    {
        self.Expr(owner, start);
        switch {
          case lexpr instanceof ConcatString:
            self.values = lexpr.values;
            if (rexpr instanceof ConcatString)
                self.append(rexpr.values);
            else
                self.pushexpr(rexpr);
            break;
          case rexpr instanceof ConcatString:
            self.values = rexpr.values;
            self.unshiftexpr(lexpr);
            break;
          default:
            self.values = [lexpr, rexpr];
        }
    }
    function pushexpr(rexpr)
    {
        var values = self.values;
        var last = values[-1];
        if (last.isstringliteral() && rexpr.isstringliteral())
            values[-1] = concat_literal(last, rexpr);
        else
            push(values, rexpr);
    }
    function unshiftexpr(lexpr)
    {
        var values = self.values;
        var first = values[0];
        if (first.isstringliteral() && lexpr.isstringliteral())
            values[0] = concat_literal(lexpr, first);
        else
            unshift(values, lexpr);
    }
    function append(rvalues)
    {
        var values = self.values;
        var last = values[-1];
        if (last.isstringliteral()) {
            var first = rvalues[0];
            if (first.isstringliteral()) {
                values[-1] = concat_literal(last, first);
                rvalues.shift();
            }
        }
        values.append(rvalues);
    }

    function checkresult() { return REGstring; }
    function getregs(e)
    {
        var values = self.values;
        int nvalues = elements(values);
        string regvalues[nvalues];
        for (int i = 0; i < nvalues; ++i)
            regvalues[i] = string(values[i].emit_get(e));
        return regvalues;
    }
    function emit(e, string result)
    {
        string auxreg = self.emit_get(e);
        e.emitset(result, auxreg);
    }
    function emit_get(e)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        string auxreg = self.tempreg(REGstring);
        self.annotate(e);
        e.emitconcat(auxreg, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(auxreg, regvalues[i]);
        return auxreg;
    }
    function emit_init(e, string result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        e.emitconcat(result, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
    function emit_concat_to(e, string result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        for (int i = 0; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
}

//*********************************************

class RepeatString : OpBinaryExpr
{
    function RepeatString(from)
    {
        self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function checkresult() { return REGstring; }
    function emit(e, string result)
    {
        var rexpr = self.rexpr;
        string lreg = self.lexpr.emit_get(e);
        string rreg = rexpr.emit_getint(e);
        self.annotate(e);
        e.emitrepeat(result, lreg, rreg);
    }
}

//*********************************************

class OpAddExpr : OpBinaryExpr
{
    function OpAddExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpAddExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGstring && rtype == REGstring)
                return concat_literal(lexpr, rexpr);
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln + rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                return floatValue(self.owner, self.start, lf + rf);
            }
        }
        if (ltype == REGstring && rtype == REGstring) {
            return new ConcatString(self.owner, self.start, lexpr, rexpr);
        }
        return self;
    }
    function checkresult()
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGint && rr == REGstring)
            return REGstring;
        if (rl == REGstring && rr == REGint)
            return REGstring;
        if (floatresult(rl, rr))
            return REGfloat;
        return REGint;
    }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string restype = self.checkresult();
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();

        string rleft = lexpr.emit_get(e);
        string rright = rexpr.emit_get(e);
        if (restype == REGstring) {
            if (ltype != REGstring || rtype != REGstring) {
                string aux = self.tempreg(REGstring);
                if (ltype != REGstring) {
                    e.emitset(aux, rleft);
                    rleft = aux;
                }
                else {
                    e.emitset(aux, rright);
                    rright = aux;
                }
            }
            e.emitconcat(result, rleft, rright);
        }
        else {
            if (restype == REGint && (ltype != REGint || rtype != REGint)) {
                string l;
                if (ltype == REGint) l = rleft;
                else {
                    l = self.tempreg(REGint);
                    e.emitset(l, rleft);
                }
                string r;
                if (rtype == REGint) r = rright;
                else {
                    r = self.tempreg(REGint);
                    e.emitset(r, rright);
                }
                e.emitadd(result, l, r);
            }
            else
                e.emitadd(result, rleft, rright);
        }
    }
}

//*********************************************

class OpSubExpr : OpBinaryExpr
{
    function OpSubExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpSubExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln - rn);
            }
        }
        return self;
    }
    function checkresult()
    {
        string ltype = self.lexpr.checkresult();
        string rtype = self.rexpr.checkresult();
        switch {
          case ltype == rtype:
            return ltype;
          case ltype == REGvar || rtype == REGvar:
            return REGvar;
          case ltype == REGint && rtype == REGfloat:
            return REGfloat;
          case ltype == REGfloat && rtype == REGint:
            return REGfloat;
          default:
            return REGint;
        }
    }
    function emit(e, string result)
    {
        string type = self.checkresult();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg = lexpr.emit_get(e);
        string rreg = rexpr.emit_get(e);
        string aux;
        if (ltype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, lreg);
            else
                e.emitset(aux, lreg);
            lreg = aux;
        }
        if (rtype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, rreg);
            else
                e.emitset(aux, rreg);
            rreg = aux;
        }
        e.emitsub(result, lreg, rreg);
    }
}

//*********************************************

class OpMulExpr : OpBinaryExpr
{
    function OpMulExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpMulExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln * rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                return floatValue(self.owner, self.start, lf * rf);
            }
        }
        if (ltype == REGstring)
            return new RepeatString(self);
        return self;
    }
    function checkresult()
    {
        var lexpr = self.lexpr;
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGstring)
            return REGstring;
        else
            return REGfloat;
    }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg, rreg;
        if (ltype == rtype && (ltype == REGint || ltype == REGfloat || ltype == REGvar)) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            e.emitmul(result, lreg, rreg);
            return;
        }

        // Quick fix for some float mul
        // TODO: rewrite this mess
        if (ltype == REGfloat) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            string rval;
            switch (rtype) {
              case REGint:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
                rval = rreg;
                break;
              case REGfloat:
                rval = rreg;
                break;
              default:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
            }
            self.annotate(e);
            e.emitmul(result, lreg, rval);
            return;
        }

        int nleft, nright;
        if ((!lexpr.issimple()) || lexpr.isidentifier()) {
            lreg = self.tempreg(self.checkresult());
            lexpr.emit(e, lreg);
        }
        else {
            nleft = lexpr.getIntegerValue();
            lreg = nleft;
        }
        if ((!rexpr.issimple()) || rexpr.isidentifier()) {
            rreg = self.tempreg(self.checkresult());
            rexpr.emit(e, rreg);
        }
        else {
            switch (rtype) {
              case REGstring:
                rreg = self.tempreg(self.checkresult());
                rexpr.emit(e, rreg);
                break;
              case REGfloat:
                rreg = rexpr.emit_get(e);
                break;
              case REGint:
              default:
                nright = rexpr.getIntegerValue();
                rreg = nright;
                break;
            }
        }
        self.annotate(e);
        e.emitmul(result, lreg, rreg);
    }
}

//*********************************************

class OpDivExpr : OpBinaryExpr
{
    function OpDivExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpDivExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            var lval;
            var rval;
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                if (rn != 0)
                    return floatValue(self.owner, self.start, ln / rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                if (rf != 0)
                    return floatValue(self.owner, self.start, lf / rf);
            }
        }
        return self;
    }
    function checkresult()
    {
        return REGfloat;
    }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        var aux;
        var lreg = lexpr.emit_get(e);
        if (lexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, lreg);
            lreg = aux;
        }
        var rexpr = self.rexpr;
        var rreg = rexpr.emit_get(e);
        if (rexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, rreg);
            rreg = aux;
        }
        self.annotate(e);
        e.emitdiv(result, lreg, rreg);
    }
}

//*********************************************

class OpModExpr : OpBinaryIntExpr
{
    function OpModExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpModExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('mod', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left % right;
    }
}

//*********************************************

class OpCModExpr : OpBinaryExpr
{
    function OpCModExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpCModExpr, owner);
    }
    function checkresult()
    {
        return REGint;
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);

        // WORKAROUND:
        // e.say('cmod ', result, ', ', lreg, ', ', rreg);
        // cmod is now a dynop. Silly workaround, use mod instead.
        e.emitbinop('mod', result, lreg, rreg);
    }
}

//*********************************************

class OpShiftleftExpr : OpBinaryIntExpr
{
    function OpShiftleftExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpShiftleftExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('shl', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left << right;
    }
}

//*********************************************

class OpShiftrightExpr : OpBinaryIntExpr
{
    function OpShiftrightExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpShiftrightExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('shr', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left >> right;
    }
}

//*********************************************

class OpShiftlrightExpr : OpBinaryIntExpr
{
    function OpShiftlrightExpr(owner, start, lexpr, rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(owner)
    {
        return self.clonebinary(new OpShiftlrightExpr, owner);
    }
    function emit(e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop('lsr', result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left >>> right;
    }
}

//*********************************************

class ArgumentModifierList : ModifierList
{
    function ArgumentModifierList(tk, owner)
    {
        self.ModifierList(tk, owner);
    }
    function emitmodifiers(e)
    {
        int isflat = false, isnamed = false;
        string setname = '';
        for (var modif in self.getlist()) {
            switch (modif.getname()) {
              case 'flat':
                isflat = true;
                break;
              case 'named':
                isnamed = true;
                switch (modif.numargs()) {
                  case 0:
                    break;
                  case 1:
                    var argmod = modif.getarg(0);
                    if (! argmod.isstringliteral())
                        SyntaxError('Invalid modifier', self);
                    setname = argmod.getPirString();
                    break;
                  default:
                    SyntaxError('Invalid modifier', self);
                }
            }
        }
        switch {
          case isflat && isnamed:
            e.print(' :flat :named');
            break;
          case isflat:
            e.print(' :flat');
            break;
          case isnamed:
            e.print(' :named');
            if (setname != '')
                e.print("(", setname, ")");
            break;
        }
    }
}

class Argument
{
    var arg;
    var modifiers;
    function Argument(var arg, var modifiers)
    {
        self.arg = arg;
        self.modifiers = modifiers;
    }
    function clone(owner)
    {
        var cloned = new Argument;
        cloned.arg = self.arg.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.arg = self.arg.optimize();
        return self;
    }
    function hascompilevalue()
    {
        return self.arg.hascompilevalue();
    }
}

function parseArgument(tk, owner)
{
    var modifier = null;
    var expr = parseExpr(tk, owner);
    var t = tk.get();
    if (t.isop(':')) {
        t = tk.get();
        if (t.isop('[')) {
            modifier = new ArgumentModifierList(tk, owner);
        }
        else
            Expected('modifier list', t);
    }
    else
        tk.unget(t);
    return new Argument(expr, modifier);
}

class ArgumentList
{
    var owner;
    var start;
    var args;
    var argregs;

    function ArgumentList(owner, start, tk, string delimiter)
    {
        self.owner = owner;
        self.start = start;
        var t = tk.get();
        if (! t.isop(delimiter)) {
            tk.unget(t);
            self.args = parseList(tk, owner, parseArgument, delimiter);
        }
    }
    function clone(owner)
    {
        var cloned = new ArgumentList;
        cloned.owner = owner;
        cloned.start = self.start;
        var args = self.args;
        if (args != null)
            cloned.args = clone_array(args, owner);
        return cloned;
    }
    function numargs()
    {
        var args = self.args;
        return args == null ? 0 : elements(args);
    }
    function getrawargs()
    {
        return self.args;
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }
    function getfreearg(int i)
    {
        var args = self.args;
        return args[i].arg;
    }
    function optimize()
    {
        optimize_array(self.args);
        return self;
    }
    function getargvalues(var e)
    {
        var argregs = self.argregs;
        if (argregs == null) {
            string argregs[];
            var collect = new CollectValues(self.owner, e);
            for (var argitem in self.args) {
                string reg = collect.add(argitem.arg);
                push(argregs, reg);
            }
            self.argregs = argregs;
        }
        return argregs;
    }
    function emitargs(var e)
    {
        var args = self.args;
        var argreg = self.getargvalues(e);

        string sep = '';
        int n = self.numargs();
        for (int i = 0; i < n; ++i) {
            e.print(sep, argreg[i]);
            var modifiers = args[i].modifiers;
            if (modifiers != null)
                modifiers.emitmodifiers(e);
            sep = ', ';
        }
    }
}

function arglist_hascompilevalue(var arglist)
{
    for (var arg in arglist)
        if (! arg.hascompilevalue())
            return false;
    return true;
}

//*********************************************

class CallBuiltinExpr : FinalExpr
{
    var builtin;
    var args;

    function CallBuiltinExpr(owner, start, builtin, args)
    {
        self.Expr(owner, start);
        self.builtin = builtin;
        self.args = args;
    }
    function checkresult()
    {
        string result = self.builtin.result();
        if (result == REGsame)
            result = self.args[0].arg.checkresult();
        return result;
    }
    function emit_void(e)
    {
        self.emit(e, "");
    }
    function emit_get(e)
    {
        string type = self.checkresult();
        switch (type)
        {
          case REGint: case REGfloat: case REGstring: case REGvar:
            break;
          case REGnone:
            SyntaxError("Can't use result of a void builtin", self);
          default:
            InternalError("Unexpected result type '" + type + "'", self);
        }
        string reg = self.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
    function emit(e, string result)
    {
        var builtin = self.builtin;
        var args = self.args;
        string argreg[];
        var arg;
        switch (builtin.params()) {
          case BULTIN_arglist:
            var collectarglist = new CollectValues(self.owner, e);
            for (arg in args)
                push(argreg, collectarglist.add(arg.arg));
            break;
          case BULTIN_raw1:
            var rawargs = [];
            for (arg in args)
                push(rawargs, arg.arg);
            self.builtin.expand(e, self, self.start, result, rawargs);
            return;
          default:
            int n = self.args;
            var collectdefault = new CollectValues(self.owner, e);
            for (int i = 0; i < n; ++i) {
                arg = args[i].arg;
                string argtype = arg.checkresult();
                string paramtype = builtin.paramtype(i);
                string argr;
                if (arg.isnull()) {
                    switch (paramtype) {
                      case REGint:
                      case REGfloat:
                      case REGstring:
                        argr = self.tempreg(paramtype);
                        e.emitnull(argr);
                        break;
                      default:
                        argr = collectdefault.add(arg);
                    }
                }
                else {
                    if (argtype == paramtype || paramtype == REGany ||
                            (paramtype == REGs_v &&
                             (argtype == REGstring || argtype == REGvar)))
                        argr = arg.emit_get(e);
                    else {
                        if (paramtype == REGs_v)
                            paramtype = REGvar;
                        string aux = arg.emit_get(e);
                        switch (paramtype) {
                          case REGvar:
                            switch (argtype) {
                              case REGint:
                              case REGfloat:
                              case REGstring:
                                argr = self.tempreg(paramtype);
                                e.emitbox(argr, aux);
                                break;
                              default:
                                argr = aux;
                            }
                            break;
                          case REGint:
                          case REGfloat:
                          case REGstring:
                            argr = self.tempreg(paramtype);
                            e.emitset(argr, aux);
                            break;
                          default:
                            argr = aux;
                        }
                    }
                }
                push(argreg, argr);
            }
        }
        self.builtin.expand(e, self, self.start, result, argreg);
    }
}

//*********************************************

function gencallbuiltin(owner, start, builtin, args)
{
    string callname = builtin.getname();
    owner.use_builtin(callname);
    int nargs = args == null ? 0 : args.numargs();
    var rawargs = nargs == 0 ? [] : args.getrawargs();

    var variants = builtin.variants;
    var variant;
    for (var v in variants) {
        int vargs = v.nparams;
        if (vargs == nargs ||
                vargs == BULTIN_arglist ||
                (vargs == BULTIN_raw1 && nargs == 1))
            variant = v;
    }
    if (variant == null)
        SyntaxError("Wrong arguments for builtin", start);

    // Check for compile time evaluation.
    if (variant.iscompileevaluable()) {
        if (arglist_hascompilevalue(rawargs)) {
            var evalfun = variant.evalfun;
            try {
                return evalfun(owner.owner, owner.start, rawargs);
            }
            catch (ex) {
                SyntaxError("Compile time evaluation of builtin " + callname +
                        " failed: '" + string(ex["message"]) + "'", start);
            }
        }
    }

    return new CallBuiltinExpr(owner, start, variant, rawargs);
}

class CallExpr : Expr
{
    var funref;
    var args;

    function CallExpr(tk, owner, start, subexp)
    {
        self.Expr(owner, start);
        self.funref = subexp;
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            self.args = new ArgumentList(owner, start, tk, ')');
        }
    }
    function clone(owner)
    {
        var cloned = new CallExpr;
        cloned.Expr(owner, self.start);
        cloned.funref = self.funref.clone(owner);
        var args = self.args;
        if (args != null)
            cloned.args = args.clone(owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        var funref = self.funref.optimize();
        var args = self.args;
        if (args != null)
            args = args.optimize();

        if (funref instanceof MemberExpr) {
            var sym = funref.search_nonmember();
            switch {
              case sym == null:
                return new CallMemberExpr(self, funref, args);
              case sym instanceof FunctionStatement:
                if (!sym.ismulti()) {
                    var subid = sym.makesubid();
                    self.usesubid(subid);
                    return new CallSubid(self, funref, args, subid);
                }
                else {
                    self.funref = new FunctionRef(self.owner, self.start, sym);
                    return self;
                }
                break;
              case sym instanceof FunctionExtern:
                self.funref = new FunctionRef(self.owner, self.start, sym);
                return self;
              case sym instanceof Builtin:
                return gencallbuiltin(self.owner, funref.start, sym, args);
                break;
              default:
                InternalError("unexpected type found in scope", self.start);
            }
        }
        if (funref instanceof MemberRefExpr)
            return new CallMemberRefExpr(self, funref, args);
        if (funref instanceof InlineRef)
            return new CallInlineExpr(self, funref, args);

        // Check for bultins
        if (funref.isidentifier()) {
            if (funref.checkIdentifier() == '') {
                var sym = self.scopesearch([ funref.getName() ], 0);
                if (sym != null && sym instanceof Builtin)
                    return gencallbuiltin(self.owner, funref.start, sym, args);
            }
        }

        self.funref = funref;
        self.args = args;
        return self;
    }
    function cantailcall()
    {
        return true;
    }
    function emitcall(e)
    {
        var funref = self.funref;
        string call;

        if (funref.isidentifier()/* && funref.subid == null*/) {
            call = funref.checkIdentifier();
            if (call == '') {
                var sym = self.scopesearch([ funref.getName() ], 0);
                switch {
                  case sym == null:
                    call = join("", [ "'", funref.getName(), "'" ] );
                    break;
                  case sym instanceof FunctionExtern:
                    call = sym.emit_get(e, self);
                    break;
                  case sym instanceof Builtin:
                    InternalError("Builtin unexpected here", self);
                  default:
                    call = join("", [ "'", funref.getName(), "'" ] );
                }
            }
        }
        else
            call = funref.emit_get(e);
        return call;
    }
    function prepareargs(e)
    {
        var args = self.args;
        if (args != null)
            args.getargvalues(e);
    }
    function emitargs(e)
    {
        e.print('(');
        var args = self.args;
        if (args != null)
            args.emitargs(e);
        e.say(')');
    }
    function emit(e, string result)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);

        self.annotate(e);

        e.print(INDENT);
        if (result == '.tailcall')
            e.print('.tailcall ');
        else
            e.print(result, ' = ');

        e.print(call);
        self.emitargs(e);
    }
    function emit_void(e)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);
        self.annotate(e);
        e.print(INDENT);
        e.print(call);
        self.emitargs(e);
    }
}

//*********************************************

// CallExpr variants. Always created from CallExpr, never directly.

class CallSubid : CallExpr
{
    var subid;
    function CallSubid(callst, funref, args, subid)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
        self.subid = subid;
    }
    function emitcall(e)
    {
        return self.subid;
    }
}

// Method call by name.
class CallMemberExpr : CallExpr
{
    function CallMemberExpr(callst, funref, args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(e)
    {
        var funref = self.funref;

        var first = funref.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first.isidentifier()) {
            string check = first.checkIdentifier();
            if (check == null || check == '') {
                // The other usages are covered in other conditions,
                // here we have a qualified symbol not found in scope,
                // assume is function in a namespace not declared here.
                string key[];
                funref.buildkey(key);
                string fun = key.pop();
                var reg = self.tempreg(REGvar);
                self.annotate(e);
                e.emitget_hll_global(reg, fun, getparrotkey(key));
                return reg;
            }
        }
        return join("", [ funref.emit_left_get(e),
                ".'", funref.get_member(), "'" ] );
    }
}

// Method call by reference.
// The reference is a expression, its result must be a var containing a
// invokable or a string with the method name.
class CallMemberRefExpr : CallExpr
{
    function CallMemberRefExpr(callst, funref, args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(e)
    {
        var funref = self.funref;
        var right = funref.right;
        var type = right.checkresult();
        if (type != REGvar && type != REGstring)
            SyntaxError("Invalid expression type in '.*'", funref);
        // We want a well defined order of evaluation here, so use variables
        // to store intermediate results.
        string lreg = funref.emit_left_get(e);
        string rreg = right.emit_get(e);
        return lreg + '.' + rreg;
    }
}

//*********************************************

class MemberExprBase : Expr
{
    var left;
    function MemberExprBase(owner, start, subexp)
    {
        self.Expr(owner, start);
        self.left = subexp;
    }
    function emit_left_get(e)
    {
        return self.left.emit_getvar(e);
    }
}

class MemberExpr : MemberExprBase
{
    var right;

    function MemberExpr(owner, start, subexp, right)
    {
        self.MemberExprBase(owner, start, subexp);
        self.right = right;
    }
    function clone(owner)
    {
        var cloned = new MemberExpr;
        cloned.MemberExprBase(owner, self.start, self.left.clone(owner));
        cloned.right = self.right;
        return cloned;
    }
    function checkresult() { return REGvar; }
    function search_nonmember()
    {
        // Check if the first element of the member expression
        // is an identfier. In that case, if it's not in scope
        // look for a function in accessible namespaces.
        var sym;
        var first = self.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first instanceof IdentifierExpr) {
            var idfirst = first.checkIdentifier();
            if (idfirst == null || idfirst == '') {
                var key = [ ];
                self.buildkey(key);
                return self.scopesearch(key, 0);
            }
        }
        return null;
    }
    function optimize()
    {
        self.left = self.left.optimize();

        var sym = self.search_nonmember();
        switch {
          case sym == null:
            break;
          case sym instanceof FunctionStatement:
            if (sym.ismulti())
              return new FunctionRef(self.owner, self.start, sym);
            break;
          case sym instanceof FunctionExtern:
            return new FunctionRef(self.owner, self.start, sym);
          case (sym instanceof VarData) && sym.isconst():
            return sym.getvalue();
        }
        return self;
    }
    function buildkey(key)
    {
        var left = self.left;
        if (left instanceof IdentifierExpr)
            push(key, left.getName());
        else
            left.buildkey(key);
        push(key, self.right.getidentifier());
    }
    function get_member()
    {
        return self.right;
    }
    function __emit_get_left(e)
    {
        var left = self.left;
        if (left.checkresult() != REGvar)
            SyntaxError("non-var at left of '.'", self);
        return left.emit_get_nonull(e);
    }
    function emit_get(e)
    {
        string result = self.tempreg(REGvar);
        self.emit(e, result);
        return result;
    }
    function emit(e, string result)
    {
        string obj = self.__emit_get_left(e);
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, 'getattribute ', result, ', ', obj, ", '", ident, "'");
    }
    function emit_assign_get(e, expr)
    {
        string obj = self.__emit_get_left(e);
        string value = self.tempreg(REGvar);
        if (expr.isnull())
            e.emitnull(value);
        else {
            string rreg = expr.emit_get(e);
            if (expr.checkresult() != REGvar)
                e.emitbox(value, rreg);
            else
                value = rreg;
        }
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, "setattribute ", obj, ", '", ident, "', ", value);
        return value;
    }
}

// Member dereference via a var or string expresion.
// When used for method calls is handled by CallMemberRefExpr.
// For attribute access only string is allowed.
class MemberRefExpr : MemberExprBase
{
    var right;
    function MemberRefExpr(owner, start, left, right)
    {
        self.MemberExprBase(owner, start, left);
        self.right = right;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.left = self.left.optimize();
        self.right = self.right.optimize();
        return self;
    }
    function emit(e, string result)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        self.annotate(e);
        e.say(INDENT, 'getattribute ', result, ', ', lreg, ", ", rreg);
    }
    function emit_assign_get(e, expr)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        string vreg;
        switch (expr.checkresult()) {
          case REGvar:
            vreg = expr.emit_get(e);
            // Special case
            if (vreg == NULL) {
                vreg = self.tempreg(REGvar);
                e.emitnull(vreg);
            }
            break;
          default:
            vreg = self.tempreg(REGvar);
            string aux = expr.emit_get(e);
            e.emitbox(vreg, aux);
        }

        self.annotate(e);
        e.say(INDENT, "setattribute ",  lreg, ", ", rreg, ", ", vreg);
        return vreg;
    }
}

//*********************************************

class StringIndexExpr : Expr
{
    var left;
    var arg;
    function StringIndexExpr(owner, start, left, arg)
    {
        self.Expr(owner, start);
        self.left = left;
        self.arg = arg;
    }
    function checkresult()
    {
       return REGstring;
    }
    function emit(e, string result)
    {
        string lreg = self.left.emit_get(e);
        string rreg = self.arg.emit_getint(e);
        self.annotate(e);
        e.say(sformat(INDENT + "substr %0, %1, %2, 1",
                result, lreg, rreg));
    }
}

//*********************************************

class IndexExpr : Expr
{
    var left;
    var regleft;
    var args;
    var argregs;

    function IndexExpr(tk, owner, start, subexp)
    {
        self.Expr(owner, start);
        self.left = subexp;
        self.args = new SimpleArgList(tk, owner, ']');
    }
    function clone(owner)
    {
        var cloned = new IndexExpr;
        cloned.Expr(owner, self.start);
        cloned.left = self.left.clone(owner);
        cloned.args = self.args.clone(owner);
        return cloned;
    }
    function checkresult()
    {
       return REGvar;
    }
    function optimize()
    {
        var left = self.left.optimize();
        self.left = left;
        var args = self.args;
        args.optimizeargs();

        switch (left.checkresult()) {
          case REGstring:
            if (args.numargs() != 1)
               SyntaxError('Bad string index', self);
            var arg = args.getarg(0);
            // Optimize case of string constant indexed with int constant
            // evaluating it at compile time.
            if (left.isstringliteral() && arg.isintegerliteral()) {
                int ival = arg.getIntegerValue();
                string sval = left.get_value();
                return stringQuotedValue(self.owner, self.start,
                        substr(sval, ival, 1));
            }
            return new StringIndexExpr(self.owner, self.start, left, arg);
          case REGvar:
            break;
          default:
            SyntaxError("Type not valid for indexing", left);
        }

        return self;
    }
    function emit_prep(e)
    {
        if (self.regleft != null || self.argregs != null)
            InternalError('wrong call to IndexExpr.emit_args', self.start);
        var left = self.left;
        self.regleft = left.isidentifier() ?
            left.getIdentifier() :
            left.emit_get(e);
        self.argregs = self.args.getargvalues(e);
    }
    function emit_aux(e)
    {
        var regleft = self.regleft;
        var argregs = self.argregs;
        if (regleft == null || argregs == null)
            InternalError('wrong call to IndexExpr.emit_aux', self.start);
        e.print(self.regleft, '[');
        e.print(join('; ', argregs));
        e.print(']');
    }
    function emit(e, string result)
    {
        self.emit_prep(e);
        self.annotate(e);
        e.print(INDENT, result, ' = ');
        self.emit_aux(e);
        e.say('');
    }
    function emit_getint(e)
    {
        string result = self.tempreg(REGint);
        self.emit(e, result);
        return result;
    }
    function emit_assign_get(e, expr)
    {
        self.emit_prep(e);
        string rreg;
        if (expr.isnull()) {
            rreg = self.tempreg(REGvar);
            e.emitnull(rreg);
        }
        else
            rreg = expr.emit_get(e);
        self.annotate(e);
        e.print(INDENT);
        self.emit_aux(e);
        e.say(' = ', rreg);
        return rreg;
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var values;

    function ArrayExpr(tk, owner, start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        if (! t.isop(']')) {
            tk.unget(t);
            self.values = parseList(tk, owner, parseExpr, ']');
        }
    }
    function clone(owner)
    {
        var cloned = new ArrayExpr;
        cloned.Expr(owner, self.start);
        if (self.values != null)
            cloned.values = clone_array(self.values, owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.values);
        return self;
    }
    function emit(e, string result)
    {
        string value = self.emit_get(e);
        e.emitset(result, value);
    }
    function emit_void(e)
    {
        // No need to create the container, but the
        // initializers may have secondary effects,
        // so they should be evaluated.
        self.emit_init(e, '');
    }
    function emit_get(e)
    {
        string container = self.tempreg(REGvar);
        self.emit_init(e, container);
        return container;
    }
    function emit_init(e, string container)
    {
        self.annotate(e);
        var values = self.values;
        int size = values == null ? 0 : elements(values);
        if (container != '') {
            e.say(INDENT, 'root_new ', container, ", ['parrot';'ResizablePMCArray']");
            if (size > 0)
                e.emitassign(container, size);
        }
        var collect = new CollectValues(self.owner, e);
        int i = 0;
        for (var value in values) {
            string valuereg = collect.add(value);
            if (container != '') {
                self.annotate(e);
                e.say(sformat(INDENT + "%0[%1] = %2", container, i, valuereg));
                ++i;
            }
        }
    }
}

//*********************************************

class HashExpr : Expr
{
    var keys;
    var values;

    function HashExpr(tk, owner, start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        var keys = [];
        var values = [];
        if (!t.isop('}')) {
            tk.unget(t);
            do {
                var key = parseExpr(tk, owner);
                ExpectOp(':', tk);
                var value = parseExpr(tk, owner);
                push(keys, key);
                push(values, value);

            } while ((t = tk.get()).isop(','));
            if (! t.isop('}'))
                Expected("',' or '}'", t);
        }
        self.keys = keys;
        self.values = values;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.keys);
        optimize_array(self.values);
        return self;
    }
    function emit(e, string result)
    {
        self.annotate(e);

        // In void context there is no need to create the container,
        // but the keys and values may have secondary effects,
        // so they should ve evaluated.
        if (result != '')
            e.say(INDENT, 'root_new ', result, ", ['parrot';'Hash']");

        var keys = self.keys;
        var values = self.values;
        var collectvalues = new CollectValues(self.owner, e);
        int n = keys;
        for (int i = 0; i < n; ++i) {
            var key = keys[i];
            string keyreg;
            if (key.isidentifier() && key.checkIdentifier() == '') {
                string id = key.getName();
                keyreg = self.tempreg(REGvar);
                e.emitget_hll_global(keyreg, id);
            }
            else
                keyreg = key.emit_get(e);

            string valuereg = collectvalues.add(values[i]);
            if (result != '')
                e.say(INDENT, result, '[', keyreg, '] = ', valuereg);
        }
    }
    function emit_void(e)
    {
        self.emit(e, '');
    }
    function emit_get(e)
    {
        string container = self.tempreg(REGvar);
        self.emit(e, container);
        return container;
    }
}

//**********************************************************************

class NewBaseExpr : Expr
{
    var initializer;
    // The value of initializer is:
    // * null if no arguments          -> no parenthesis
    // * empty array if zero arguments -> parenthesized empty list
    // * non empty array otherwise     -> parenthesized non empty list

    function checkresult() { return REGvar; }
    function parseinitializer(tk)
    {
        // Called with the tokenizer pointing right after the
        // opening parenthesis
        self.initializer = new ArgumentList(self.owner, self.start, tk, ')');
    }
    function numargs()
    {
        var initializer = self.initializer;
        return initializer == null ? -1 : int(initializer.numargs());
    }
    function optimize_initializer()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer.optimize();
    }
    function optimize()
    {
        self.optimize_initializer();
        return self;
    }
    function emit_constructor(e, string regnew, string constructor)
    {
        var initializer = self.initializer;
        if (initializer != null)
            initializer.getargvalues(e);
        e.print(INDENT, regnew, ".'", constructor, "'(");
        if (initializer != null)
            initializer.emitargs(e);
        e.say(")");
    }
}

//**********************************************************************

function warn_class_unknown(e, string name, pos)
{
    e.warn("class " + name + " not found at compile time", pos);
}

class NewExpr : NewBaseExpr
{
    var value;

    function NewExpr(var tk, var owner, var start, var firstvalue)
    {
        self.Expr(owner, start);

        if (! (firstvalue.isstring() || firstvalue.isidentifier()))
            SyntaxError("Unimplemented", firstvalue);
        self.value = firstvalue;
        var t = tk.get();

        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function clone(owner)
    {
        var cloned = new NewExpr;
        cloned.Expr(owner, self.start);
        cloned.value = self.value;
        if (self.initializer != null)
            cloned.initializer = self.initializer.clone(owner);
        return cloned;
    }
    function optimize()
    {
        var value = self.value;
        if (value.isidentifier()) {
            // The identifier can be a string constant, check for that case
            // and obtain the string value.
            var desc = self.owner.getvar(value.getidentifier());
            if (desc != null && desc.isconst()) {
                value = desc.getvalue();
                if (! (value instanceof StringLiteral))
                    SyntaxError('Constant value must evaluate to a string', value);
                self.value = value.strval;
            }
        }
        self.optimize_initializer();
        return self;
    }
    function emit(e, string result, int is_init[optional])
    {
        self.annotate(e);

        var initializer = self.initializer;
        var value = self.value;
        int numinits = self.numargs();

        const int BYNAME = 0, BYIDENT = 1;
        int type = value.isstring() ? BYNAME :
                value.isidentifier() ? BYIDENT : -1;

        string reginit = '';
        string regnew = result;
        string constructor;
        switch (numinits) {
          case -1:
          case 0:
            break;
          case 1:
            if (type == BYIDENT) {
                if (! is_init)
                    regnew = self.tempreg(REGvar);
            }
            else {
                var initval = initializer.getfreearg(0);
                reginit = initval.emit_get(e);
                reginit = ', ' + reginit;
            }
            break;
          default:
            if (type != BYIDENT)
                SyntaxError('Multiple init arguments not allowed here', self);
            if (! is_init)
                regnew = self.tempreg(REGvar);
        }

        if (regnew == '')
            regnew = self.tempreg(REGvar);

        switch (type) {
          case BYNAME:
            // By name, usually a pmc.
            string name = value.rawstring();
            var aux = get_class(name);
            if (aux == null)
                warn_class_unknown(e, name , value);

            // Avoid using root_new here for a now.
            //e.say('root_new ', regnew, ", ['parrot'; ", value, " ]", reginit);
            e.say(INDENT, 'new ', regnew, ", [ ", value, " ]", reginit);
            if (numinits > 1) {
                e.say(regnew, ".'", value, "'()");
            }
            break;
          case BYIDENT:
            var id = self.owner.getvar(value);
            if (id == null) {
                var cl = self.owner.checkclass(value);
                if (cl != null) {
                    var key = cl.getpath();
                    key.emit_new(e, self, regnew, reginit);
                }
                else {
                    id = self.scopesearch( [value], SEARCH_CLASS);
                    if (id != null)
                        e.say(INDENT, 'new ', regnew, ", ", id.getclasskey(), reginit);
                    else {
                        warn_class_unknown(e, value.getidentifier(), value);
                        e.say(INDENT, 'new ', regnew, ", ['", value, "']", reginit);
                    }
                }
                constructor = value;
            }
            else {
                //say('new with var');
                e.say(INDENT, 'new ', regnew, ", ", id.getreg(), "", reginit);
            }
            break;
          default:
            InternalError('Unexpected type in new');
        }
        if (numinits > 1 || (numinits >= 0 && type == BYIDENT)) {
            self.emit_constructor(e, regnew, constructor);
            if (! is_init)
                e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

class NewIndexedExpr : NewBaseExpr
{
    var nskey;

    function NewIndexedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierParrotKey(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(e, string result)
    {
        string reginit;
        switch (self.numargs()) {
          case -1:
          case 0:
            break;
          case 1:
            var initval = self.initializer.getfreearg(0);
            reginit = initval.emit_get(e);
            break;
          default:
            SyntaxError('Multiple init arguments not allowed here', self);
        }
        var nskey = self.nskey;

        e.print(INDENT);
        if (nskey.hasHLL())
            e.print("root_");
        e.print("new ", result, ", ");
        nskey.emit(e, null);
        if (reginit != null)
            e.print(', ', reginit);
        e.say();
    }
}

//**********************************************************************

class NewQualifiedExpr : NewBaseExpr
{
    var nskey;

    function NewQualifiedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierId(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop('('))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(e, string result)
    {
        int numinits = self.numargs();
        string regnew = result;
        if (numinits > 0)
            regnew = self.tempreg(REGvar);
        var nskey = self.nskey;

        if (regnew == '')
            regnew = self.tempreg(REGvar);

        nskey.emit_new(e, self, regnew);

        if (numinits >= 0) {
            string constructor = nskey.last();
            self.emit_constructor(e, regnew, constructor);
            e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

function parseNew(var tk, var owner, var start)
{
    var t = tk.get();

    switch {
      case t.isop('('):
        // Not a new operator, but a call to a function called new.
        return new CallExpr(tk, owner, start,
                new StringLiteral(owner, start));
      case t.isop('['):
        // Class specifier is a key
        return new NewIndexedExpr(tk, owner, start);
      case t.isidentifier():
        // Special case here. It can be an id, a qualified id or
        // a const string
        var t2 = tk.get();
        tk.unget(t2);
        if (t2.isop('.')) {
            // Qualified id
            return new NewQualifiedExpr(tk, owner, t);
        }
        // Else let the default handle it
      default:
        // Remainig cases
        return new NewExpr(tk, owner, start, t);
    }
}

//**********************************************************************

class OpInstanceOfExpr : Expr
{
    var lexpr;
    var checked;

    function OpInstanceOfExpr(owner, start, lexpr, tk)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.checked = parseClassSpecifier(tk, self);
    }
    function clone(owner)
    {
        var cloned = new OpInstanceOfExpr;
        cloned.Expr(owner, self.start);
        cloned.lexpr = self.lexpr.clone(owner);
        cloned.checked = self.checked.clone(self);
        return cloned;
    }
    function optimize()
    {
        self.lexpr = self.lexpr.optimize();
        return self;
    }
    function checkresult() { return REGint; }
    function emit(e, string result)
    {
        var lexpr = self.lexpr;
        string ltype = lexpr.checkresult();
        if (ltype != REGvar)
            SyntaxError('Invalid instanceof left operand', lexpr);
        var checked = self.checked;

        string check = lexpr.emit_get(e);
        self.annotate(e);
        e.print(INDENT + 'isa ', result, ', ', check, ', ');
        checked.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpConditionalExpr : Expr
{
    var condition;
    var etrue;
    var efalse;

    function OpConditionalExpr(owner, start, condition, etrue, efalse)
    {
        self.Expr(owner, start);
        self.condition = (new Condition).set(condition);
        self.etrue = etrue;
        self.efalse = efalse;
        return self;
    }
    function clone(owner)
    {
        var cloned = new OpConditionalExpr;
        cloned.Expr(owner, self.start);
        cloned.condition = (new Condition).set(self.condition.condexpr.clone(owner));
        cloned.etrue = self.etrue.clone(owner);
        cloned.efalse = self.efalse.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        switch (self.condition.getvalue()) {
          case CONDistrue:
            return self.etrue.optimize();
          case CONDisfalse:
            return self.efalse.optimize();
          default:
            self.etrue = self.etrue.optimize();
            self.efalse = self.efalse.optimize();
            return self;
        }
    }
    function checkresult()
    {
        var etrue = self.etrue;
        if (etrue.isnull())
            return self.efalse.checkresult();
        else
            return etrue.checkresult();
    }
    function emit(e, string result)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        var etrue = self.etrue;
        string tres = self.checkresult();
        if (etrue.isnull())
            e.emitnull(result);
        else
            etrue.emit(e, result);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        var efalse = self.efalse;
        if (efalse.isnull())
            e.emitnull(result);
        else {
            string tfalse = efalse.checkresult();
            if (tres == REGvar && tfalse != REGvar) {
                string r = efalse.emit_get(e);
                e.emitbox(result, r);
            }
            else
            {
                if (tfalse == REGvar) {
                    var aux = efalse.emit_get(e);
                    e.emitset(result, aux);
                }
                else
                    efalse.emit(e, result);
            }
        }
        e.emitlabel(cond_end);
    }
    function emit_void(e)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        self.etrue.emit_void(e);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        self.efalse.emit_void(e);
        e.emitlabel(cond_end);
    }
}

//*********************************************
//           Expressions parser
//*********************************************

const int
    Code_none          =  0,
    Code_paren         =  1,
    Code_bracket       =  2,
    Code_dot           =  3,
    Code_assign        =  4,
    Code_assign_to     =  5,
    Code_add_assign    =  6,
    Code_add           =  7,
    Code_minus         =  8,
    Code_inc           =  9,
    Code_dec           = 10,
    Code_not           = 11,
    Code_equal         = 12,
    Code_not_equal     = 13,
    Code_less          = 14,
    Code_less_equal    = 15,
    Code_greater       = 16,
    Code_greater_equal = 17,
    Code_sub_assign    = 18,
    Code_mul           = 19,
    Code_div           = 20,
    Code_mod           = 21,
    Code_cmod          = 22,
    Code_mul_assign    = 23,
    Code_div_assign    = 24,
    Code_same          = 25,
    Code_not_same      = 26,
    Code_instanceof    = 27,
    Code_shiftleft     = 28,
    Code_shiftright    = 29,
    Code_shiftlright   = 30,
    Code_mod_assign    = 31,
    Code_delete        = 32,
    Code_exists        = 33,
    Code_bin_not       = 34;

function getOpCode_2(t)
{
    switch (t.checkop()) {
    case '(': return Code_paren;
    case '[': return Code_bracket;
    case '.': return Code_dot;
    default:  return Code_none;
    }
}

function getOpCode_4(t)
{
    switch (t.checkop()) {
    case '-':  return Code_minus;
    case '!':  return Code_not;
    case '~':  return Code_bin_not;
    case '++': return Code_inc;
    case '--': return Code_dec;
    default:
        if (t.iskeyword('delete')) return Code_delete;
        else if (t.iskeyword('exists')) return Code_exists;
        else return Code_none;
    }
}

function getOpCode_5(t)
{
    switch (t.checkop()) {
    case '*':  return Code_mul;
    case '/':  return Code_div;
    case '%':  return Code_mod;
    case '%%': return Code_cmod;
    default:   return Code_none;
    }
}

function getOpCode_7(t)
{
    switch (t.checkop()) {
    case '<<':  return Code_shiftleft;
    case '>>':  return Code_shiftright;
    case '>>>': return Code_shiftlright;
    default:    return Code_none;
    }
}

function getOpCode_8(t)
{
    switch (t.checkop()) {
    case '<':  return Code_less;
    case '>':  return Code_greater;
    case '<=': return Code_less_equal;
    case '>=': return Code_greater_equal;
    default:
        if (t.iskeyword('instanceof')) return Code_instanceof;
        else return Code_none;
    }
}

function getOpCode_9(t)
{
    switch (t.checkop()) {
    case '==':  return Code_equal;
    case '!=':  return Code_not_equal;
    case '===':  return Code_same;
    case '!==':  return Code_not_same;
    default:   return Code_none;
    }
}

function getOpCode_16(t)
{
    switch (t.checkop()) {
    case '=':  return Code_assign;
    case '=:': return Code_assign_to;
    case '+=': return Code_add_assign;
    case '-=': return Code_sub_assign;
    case '*=': return Code_mul_assign;
    case '/=': return Code_div_assign;
    case '%=': return Code_mod_assign;
    default:   return Code_none;
    }
}

function parseExpr_0(tk, owner)
{
    var t = tk.get();
    var expr;

    switch {
      case t.isop('('):
        expr = parseExpr(tk, owner);
        ExpectOp(')', tk);
        return expr;
      case t.isop('['):
        return new ArrayExpr(tk, owner, t);
      case t.isop('{'):
        return new HashExpr(tk, owner, t);
      case t.isstring():
        return new StringLiteral(owner, t);
      case t.isint():
        return integerValue(owner, t, t.getintvalue());
      case t.isfloat():
        return new FloatLiteral(owner, t);
      case t.iskeyword('new'):
        return parseNew(tk, owner, t);
      case t.iskeyword('function'):
        return new FunctionExpr(tk, owner, t);
      case t.iskeyword('class'):
        return new OpClassExpr(tk, owner, t);
      case t.iskeyword('namespace'):
        return new OpNamespaceExpr(tk, owner, t);
      case t.isidentifier():
        return new IdentifierExpr(owner, t);
      default:
        Expected('expression', t);
    }
}

function parseExpr_2(tk, owner)
{
    var subexp = parseExpr_0(tk, owner);
    var t;
    var start;
    int code;
    while ((code = getOpCode_2(t = tk.get())) != Code_none ) {
        switch (code) {
          case Code_paren:
            subexp = new CallExpr(tk, owner, t, subexp);
            break;
          case Code_bracket:
            subexp = new IndexExpr(tk, owner, t, subexp);
            break;
          case Code_dot:
            start = t;
            t = tk.get();
            if (t.isop('*')) {
                var right = parseExpr_0(tk, owner);
                subexp = new MemberRefExpr(owner, t, subexp, right);
            }
            else
                subexp = new MemberExpr(owner, start, subexp, t);
            break;
          default:
            InternalError('Unexpected code in parseExpr_2');
        }
    }
    tk.unget(t);
    return subexp;
}

function parseExpr_3(tk, owner)
{
    var subexp = parseExpr_2(tk, owner);
    var t = tk.get();
    switch {
      case t.isop('++'):
        return new OpPostIncExpr(owner, t, subexp);
      case t.isop('--'):
        return new OpPostDecExpr(owner, t, subexp);
      default:
        tk.unget(t);
        return subexp;
    }
}

function parseExpr_4(tk, owner)
{
    var t = tk.get();
    int code = getOpCode_4(t);
    if (code != Code_none) {
        var subexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_minus:
            return new OpUnaryMinusExpr(owner, t, subexpr);
          case Code_not:
            return new OpNotExpr(owner, t, subexpr);
          case Code_bin_not:
            return new OpBinNotExpr(owner, t, subexpr);
          case Code_inc:
            return new OpPreIncExpr(owner, t, subexpr);
          case Code_dec:
            return new OpPreDecExpr(owner, t, subexpr);
          case Code_delete:
            return new OpDeleteExpr(owner, t, subexpr);
          case Code_exists:
            return new OpExistsExpr(owner, t, subexpr);
          default:
            InternalError('Invalid code in parseExpr_4', t);
        }
    }
    else {
        tk.unget(t);
        return  parseExpr_3(tk, owner);
    }
}

function parseExpr_5(tk, owner)
{
    var lexpr = parseExpr_4(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_5(t = tk.get())) != Code_none) {
        var rexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_mul:
            lexpr = new OpMulExpr(owner, t, lexpr, rexpr);
            break;
          case Code_div:
            lexpr = new OpDivExpr(owner, t, lexpr, rexpr);
            break;
          case Code_mod:
            lexpr = new OpModExpr(owner, t, lexpr, rexpr);
            break;
          case Code_cmod:
            lexpr = new OpCModExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError('Invalid code in parseExpr_5', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_6(tk, owner)
{
    var lexpr = parseExpr_5(tk, owner);
    var t;
    while ((t = tk.get()).isop('+') || t.isop('-')) {
        var rexpr = parseExpr_5(tk, owner);
        var expr;
        if (t.isop('+'))
            expr = new OpAddExpr(owner, t, lexpr, rexpr);
        else
            expr = new OpSubExpr(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_7(tk, owner)
{
    var lexpr = parseExpr_6(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_7(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_shiftleft:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftleftExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftrightExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftlright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftlrightExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError('Invalid code in parseExpr_7', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_8(tk, owner)
{
    var lexpr = parseExpr_7(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_8(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_less:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_less_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_instanceof:
            lexpr = new OpInstanceOfExpr(owner, t, lexpr, tk);
            break;
          default:
            InternalError('Invalid code in parseExpr_9', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_9(tk, owner)
{
    var lexpr = parseExpr_8(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_9(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, false);
            break;
          case Code_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, false);
            break;
          default:
            InternalError('Invalid code in parseExpr_8', t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_10(tk, owner)
{
    var lexpr = parseExpr_9(tk, owner);
    var t;
    while ((t = tk.get()).isop('&')) {
        var rexpr = parseExpr_9(tk, owner);
        lexpr = new OpBinAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_11(tk, owner)
{
    var lexpr = parseExpr_10(tk, owner);
    var t;
    while ((t = tk.get()).isop('^')) {
        var rexpr = parseExpr_10(tk, owner);
        lexpr = new OpBinXorExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_12(tk, owner)
{
    var lexpr = parseExpr_11(tk, owner);
    var t;
    while ((t = tk.get()).isop('|')) {
        var rexpr = parseExpr_11(tk, owner);
        lexpr = new OpBinOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_13(tk, owner)
{
    var lexpr = parseExpr_12(tk, owner);
    var t;
    while ((t = tk.get()).isop('&&')) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_14(tk, owner)
{
    var lexpr = parseExpr_13(tk, owner);
    var t;
    while ((t = tk.get()).isop('||')) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_15(tk, owner)
{
    var econd = parseExpr_14(tk, owner);
    var t = tk.get();
    if (t.isop('?')) {
        var etrue = parseExpr_16(tk, owner);
        ExpectOp(':', tk);
        var efalse = parseExpr_16(tk, owner);
        return new OpConditionalExpr(owner, t, econd, etrue, efalse);
    }
    else {
        tk.unget(t);
        return econd;
    }
}

function parseExpr_16(tk, owner)
{
    var lexpr = parseExpr_15(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_16(t = tk.get())) != Code_none ) {
        var rexpr = parseExpr_16(tk, owner);
        var expr;
        switch (code) {
          case Code_assign:
            expr = new OpAssignExpr;
            break;
          case Code_assign_to:
            expr = new OpAssignToExpr;
            break;
          case Code_add_assign:
            expr = new OpAddToExpr;
            break;
          case Code_sub_assign:
            expr = new OpSubToExpr;
            break;
          case Code_mul_assign:
            expr = new OpMulToExpr;
            break;
          case Code_div_assign:
            expr = new OpDivToExpr;
            break;
          case Code_mod_assign:
            expr = new OpModToExpr;
            break;
          default:
            InternalError('Unexpected code in parseExpr_16', t);
        }
        expr.set(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr(tk, owner)
{
    return parseExpr_16(tk, owner);
}

//*********************************************
//         Breakable and Continuable
//*********************************************

// Abstract base class for statments that can contain break
// and continue statments. Continuable is always breakable.

class Breakable
{
    var brlabel;

    function genbreaklabel()
    {
        if (self.brlabel != null)
            InternalError('attempt to generate break label twice');
        string label = self.genlabel();
        self.brlabel = label;
        return label;
    }
    function getbreaklabel(pos)
    {
        var label = self.brlabel;
        if (label == null)
            InternalError('attempt to get break label before creating it');
        return label;
    }
}

class Continuable : Breakable
{
    var cntlabel;

    function gencontinuelabel()
    {
        if (self.cntlabel != null)
            InternalError('attempt to generate continue label twice');
        string label = self.genlabel();
        self.cntlabel = label;
        return label;
    }
    function getcontinuelabel(pos)
    {
        var label = self.cntlabel;
        if (label == null)
            InternalError('attempt to get continue label before creating it');
        return label;
    }
}

//*********************************************
//            ReturnYieldStatement
//*********************************************

// Return and Yield statements and a base class
// that does almost all.

class ReturnYieldStatement : Statement
{
    var values;

    function parse(start, tk, owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.values = new ArgumentList(owner, start, tk, ";");
        }
    }
    function optimize()
    {
        var values = self.values;
        if (values != null)
            values = values.optimize();
        return self;
    }
    function emit(e)
    {
        //var args = [];
        var values = self.values;
        int n = values == null ? 0 : int(values.numargs());

        // Experimental tailcall optimization
        if (n == 1 && (self instanceof ReturnStatement)) {
            var func = values.getfreearg(0);
            if (func.cantailcall() && self.owner.allowtailcall()) {
                self.annotate(e);
                return func.emit(e, '.tailcall');
            }
        }

        if (n > 0)
            values.getargvalues(e);

        self.annotate(e);
        self.emitret(e);
        if (n > 0)
            values.emitargs(e);
        e.say(')');
    }
}

class ReturnStatement : ReturnYieldStatement
{
    function ReturnStatement(start, tk, owner)
    {
        self.parse(start, tk, owner);
    }
    function emitret(e)
    {
        e.print(INDENT, '.return(');
    }
}

class YieldStatement : ReturnYieldStatement
{
    function YieldStatement(start, tk, owner)
    {
        self.parse(start, tk, owner);
    }
    function clone(owner)
    {
        SyntaxError("inlined yield not allowed", self);
    }
    function emitret(e)
    {
        e.print(INDENT, '.yield(');
    }
}

class InlineReturnStatement : Statement
{
    var expr;
    function InlineReturnStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        tk.unget(t);
        if (!t.isop(";"))
            self.expr = parseExpr(tk, owner);
    }
    function clone(owner)
    {
        var cloned = new InlineReturnStatement;
        cloned.Statement(self.start, owner);
        var expr = self.expr;
        if (expr != null)
            cloned.expr = expr.clone(owner);
        return cloned;
    }
    function optimize()
    {
        var expr = self.expr;
        if (expr != null)
            self.expr = expr.optimize();
        return self;
    }
    function emit(e)
    {
        var outer = self.owner.getouter();
        __ASSERT__(outer instanceof InlinedBlock);
        var expr = self.expr;
        string rettype = outer.getrettype();
        self.annotate(e);
        if (expr != null) {
            var retreg = outer.getretreg();
            if (retreg == null)
                expr.emit_void(e);
            else {
                if (expr.isnull())
                    e.emitnull(retreg);
                else {
                    string type = expr.checkresult();
                    if (type == rettype)
                        expr.emit(e, retreg);
                    else {
                        string reg = expr.emit_get(e);
                        self.annotate(e);
                        if (rettype == REGvar)
                            e.emitbox(retreg, reg);
                        else
                            e.emitset(retreg, reg);
                    }
                }
            }
        }

        if (! outer.islaststatement(self)) {
            string retlabel = outer.getendlabel();
            self.annotate(e);
            e.emitgoto(retlabel);
        }
    }
}

function parseReturn(start, tk, owner)
{
    var outer = owner.getouter();
    if (outer instanceof InlineStatement)
        return new InlineReturnStatement(start, tk, owner);
    else
        return new ReturnStatement(start, tk, owner);
}

//*********************************************
//            LabelStatement
//*********************************************

class LabelStatement : Statement
{
    var name;
    var value;
    function LabelStatement(n, owner)
    {
        self.Statement(n, owner);
        self.name = n;
        self.value = self.createlabel(n);
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        e.emitlabel(self.value, 'label ' + string(self.name));
    }
}

//*********************************************
//            Reflabel
//*********************************************

class Reflabel
{
    var owner;
    var label;

    function Reflabel(owner, label)
    {
        self.owner = owner;
        self.label = label;
    }
    function optimize() { return self; }
    function emit_get(e)
    {
        string value = self.owner.getlabel(self.label.getidentifier());
        if (value == null)
            SyntaxError("No such label", self.label);
        return value;
    }
}

//*********************************************
//            GotoStatement
//*********************************************

class GotoStatement : Statement
{
    var label;

    function GotoStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        RequireIdentifier(t);
        self.label = t;
        ExpectOp(';', tk);
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string labelname = self.label;
        string value = self.getlabel(labelname);
        if (value == null)
            SyntaxError("No such label", self.label);
        e.emitgoto(value, 'goto ' + labelname);
    }
}

//*********************************************
//          ConditionalStatement
//*********************************************

class ConditionalStatement : Statement, Condition
{
    function parseconditionshort(tk)
    {
        self.set(parseExpr(tk, self));
    }
    function parsecondition(tk)
    {
        ExpectOp('(', tk);
        self.set(parseExpr(tk, self));
        ExpectOp(')', tk);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : ConditionalStatement
{
    var truebranch;
    var falsebranch;
    function IfStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.truebranch = parseStatement(tk, self);
        var t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement;
            tk.unget(t);
        }
    }
    function clone(owner)
    {
        var cloned = new IfStatement;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(owner);
        cloned.truebranch = self.truebranch.clone(owner);
        cloned.falsebranch = self.falsebranch.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        self.truebranch = self.truebranch.optimize();
        self.falsebranch = self.falsebranch.optimize();
        switch (self.getvalue()) {
          case CONDistrue:
            return self.truebranch;
          case CONDisfalse:
            return self.falsebranch;
        }
        return self;
    }
    function emit(e)
    {
        var truebranch = self.truebranch;
        var falsebranch = self.falsebranch;
        int t_empty = truebranch.isempty();
        int f_empty = falsebranch.isempty();
        string elselabel = '';
        if (! f_empty)
            elselabel = self.genlabel();
        string endlabel = self.genlabel();
        string cond_false = f_empty ? endlabel : elselabel;
        self.annotate(e);
        self.emit_else(e, cond_false);
        truebranch.emit(e);

        if (! f_empty) {
            e.emitgoto(endlabel);
            e.emitlabel(elselabel, 'else');
            falsebranch.emit(e);
        }
        e.emitlabel(endlabel, 'endif');
    }
}

//*********************************************
//            LoopStatement
//*********************************************

class LoopStatement : Continuable
{
    var body;
    function parsebody(tk)
    {
        self.body = parseStatement(tk, self);
    }
    function emit_infinite(e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.emitlabel(continuelabel, 'Infinite loop');
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, 'Infinite loop end');
    }
}

//*********************************************
//            WhileStatement
//*********************************************

class WhileStatement : LoopStatement, ConditionalStatement
{
    function WhileStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.parsebody(tk);
    }
    function clone(owner)
    {
        var cloned = new WhileStatement;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        switch (self.getvalue()) {
          case CONDistrue:
            self.emit_infinite(e);
            break;
          case CONDisfalse:
            if (e.getDebug())
                e.comment('while(false) optimized out');
            break;
          default:
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(continuelabel, 'while');
            self.emit_else(e, breaklabel);
            self.body.emit(e);
            e.emitgoto(continuelabel);
            e.emitlabel(breaklabel, 'endwhile');
        }
    }
}

//*********************************************
//            DoStatement
//*********************************************

class DoStatement : LoopStatement, ConditionalStatement
{
    function DoStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        self.parsebody(tk);
        ExpectKeyword('while', tk);
        self.parsecondition(tk);
    }
    function clone(owner)
    {
        var cloned = new DoStatement;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        var body = self.body.optimize();
        if (body.isempty() && self.getvalue() == CONDisfalse)
            return new EmptyStatement;
        self.body = body;
        return self;
    }
    function emit(e)
    {
        var body = self.body;
        int condvalue = self.getvalue();
        switch (condvalue) {
          case CONDistrue:
            self.emit_infinite(e);
            break;
          default:
            string looplabel = self.genlabel();
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(looplabel, 'do');

            body.emit(e);
            e.emitlabel(continuelabel, 'continue');
            if (condvalue != CONDisfalse)
                self.emit_if(e, looplabel, breaklabel);
            e.emitlabel(breaklabel, 'enddo');
        }
    }
}

//*********************************************
//            ContinueStatement
//*********************************************

class ContinueStatement : Statement
{
    function ContinueStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        ExpectOp(';', tk);
    }
    function clone(owner)
    {
        var cloned = new ContinueStatement;
        cloned.Statement(self.start, owner);
        return cloned;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string label = self.getcontinuelabel(self.start);
        e.emitgoto(label, 'continue');
    }
}

//*********************************************
//            BreakStatement
//*********************************************

class BreakStatement : Statement
{
    function BreakStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        ExpectOp(';', tk);
    }
    function clone(owner)
    {
        var cloned = new BreakStatement;
        cloned.Statement(self.start, owner);
        return cloned;
    }
    function optimize() { return self; }
    function emit(e)
    {
        self.annotate(e);
        string label = self.getbreaklabel(self.start);
        e.emitgoto(label, 'break');
    }
}

//*********************************************
//            SwitchBaseStatement
//*********************************************

class SwitchBaseStatement : Breakable, Statement
{
    var case_value;
    var case_st;
    var default_st;

    function SwitchBaseStatement(start, owner)
    {
        self.Statement(start, owner);
        self.case_value = [];
        self.case_st = [];
        self.default_st = [];
    }
    function cloneswitchto(cloned, owner)
    {
        cloned.Statement(self.start, owner);
        cloned.case_value = clone_array(self.case_value, owner);
        cloned.case_st = transform(self.case_st, [],
                function (case) { return clone_array(case, owner); } );
        cloned.default_st = clone_array(self.default_st, owner);
        return cloned;
    }
    function parse_cases(tk)
    {
        var t;
        while ((t = tk.get()).iskeyword('case') || t.iskeyword('default')) {
            if (t.iskeyword('case')) {
                push(self.case_value, parseExpr(tk, self));
                t = tk.get();
                if (! t.isop(':'))
                    Expected("':' in case", t);
                var st = [];
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    push(st, parseStatement(tk, self));
                }
                push(self.case_st, st);
                tk.unget(t);
            }
            else {
                t = tk.get();
                if (! t.isop(':'))
                    Expected("':' in default", t);
                while (! ((t = tk.get()).isop('}') || t.iskeyword('case') || t.iskeyword('default'))) {
                    tk.unget(t);
                    push(self.default_st, parseStatement(tk, self));
                }
                tk.unget(t);
            }
        }
        if (! t.isop('}'))
            Expected("'}' in switch", t);
    }
    function optimize_cases()
    {
        optimize_array(self.case_value);
        //for_each(self.case_st, optimize_array);
        for (var case in self.case_st)
            optimize_array(case);
        optimize_array(self.default_st);
    }
}

//*********************************************
//            SwitchStatement
//*********************************************

class SwitchStatement : SwitchBaseStatement
{
    var condition;

    function SwitchStatement(start, tk, owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.condition = parseExpr(tk, self);
        var t = tk.get();
        if (! t.isop(')'))
            Expected("')' in switch", t);
        t = tk.get();
        if (! t.isop('{'))
            Expected("'{' in switch", t);
        self.parse_cases(tk);
    }
    function clone(owner)
    {
        var cloned = self.cloneswitchto(new SwitchStatement, owner);
        cloned.condition = self.condition.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.optimize_cases();
        return self;
    }
    function emit(e)
    {
        // Get case common type
        // If all cases are literal strings of length 1, convert to
        // the code of the first char
        string type = '';
        for (var value in self.case_value) {
            string t = value.checkresult();
            if (t == REGfloat)
                SyntaxError("Invalid type in case", self);
            if (t == REGstring) {
                if (type == '' || type == 'char')
                {
                    if (value.isstringliteral() && length(string_from_literal(value)) == 1)
                        t = 'char';
                    else
                        type = REGstring;
                }
            }
            if (type == '')
                type = t;
            else if (type != t)
                type = REGvar;
        }
        // Evaluate condition
        var condition = self.condition;
        var condtype = condition.checkresult();

        // This can happen if there isn't any case. Not likely in hand
        // written code but allowing it may simplify code generators.
        if (type == '')
            type = condtype;

        if (e.getDebug())
            e.comment('switch');
        string defaultlabel = self.genlabel();
        string reg;
        if (type == 'char') {
            if ((condition instanceof CallBuiltinExpr) &&
                        condition.builtin.name() == "chr") {
                var args = condition.args;
                var arg = args[0].arg;
                reg = arg.emit_getint(e);
            }
            else {
                string regs;
                if (condtype != REGstring) {
                    string regcond = condition.emit_get(e);
                    regs = self.tempreg(REGstring);
                    e.emitset(regs, regcond);
                }
                else
                    regs = condition.emit_get(e);
                e.emitif_null(regs, defaultlabel);
                reg = self.tempreg(REGint);
                e.emitarg2('length', reg, regs);
                e.emitarg3('ne', reg, "1", defaultlabel);
                e.emitarg2('ord', reg, regs);
            }
        }
        else if (condtype == type)
            reg = condition.emit_get(e);
        else {
            reg = self.tempreg(type);
            string regcond = condition.emit_get(e);
            e.emitset(reg, regcond);
        }

        // Prpeare labels and check values
        self.genbreaklabel();
        string caselabel[];
        string regval;
        if (type != 'char')
            self.tempreg(type);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            string casereg;
            if (type == REGint)
                casereg = caseval.emit_getint(e);
            else if (type == 'char') {
                int code = ord(string_from_literal(caseval));
                casereg = code;
            }
            else if (type == caseval.checkresult())
                casereg = caseval.emit_get(e);
            else {
                caseval.emit(e, regval);
                casereg = regval;
            }
            e.say(sformat(INDENT + "if %0 == %1 goto %2", reg, casereg, label));
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; ++i) {
            e.emitlabel(caselabel[i], 'case');
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, 'default');
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), 'switch end');
    }
}

//*********************************************
//            SwitchCaseStatement
//*********************************************

class SwitchCaseStatement : SwitchBaseStatement
{

    function SwitchCaseStatement(start, tk, owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.parse_cases(tk);
    }
    function clone(owner)
    {
        return self.cloneswitchto(new SwitchCaseStatement, owner);
    }
    function optimize()
    {
        self.optimize_cases();
        return self;
    }
    function emit(e)
    {
        // Prpeare labels and check values
        self.genbreaklabel();
        string defaultlabel = self.genlabel();
        string caselabel[];

        if (e.getDebug())
            e.comment('switch-case');
        string reg = self.tempreg(REGint);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            if (caseval.checkresult() == REGint)
                caseval.emit(e, reg);
            else {
                string auxreg = caseval.emit_get(e);
                e.emitset(reg, auxreg);
            }
            e.emitif(reg, label);
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; ++i) {
            e.emitlabel(caselabel[i], 'case');
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, 'default');
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), 'switch end');
    }
}

//*********************************************

function parseSwitch(start, tk, owner)
{
    var t = tk.get();
    if (t.isop('('))
        return new SwitchStatement(start, tk, owner);
    if (t.isop('{'))
        return new SwitchCaseStatement(start, tk, owner);
    Expected("'(' in switch", t);
}

//*********************************************
//            ForStatement
//*********************************************

class ForStatement : LoopStatement, BlockStatement, ConditionalStatement
{
    var initializer;
    var iteration;

    function ForStatement(start, tk, owner)
    {
        self.BlockStatement(start, owner);
        var t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.initializer = parseStatement(tk, self);
        }
        t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            self.parseconditionshort(tk);
            ExpectOp(';', tk);
        }
        t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            var iteration = [];
            do {
                push(iteration, parseExpr(tk, self));
            } while ((t = tk.get()).isop(','));
            self.iteration = iteration;
            RequireOp(')', t);
        }
        self.parsebody(tk);
    }
    function clone(owner)
    {
        var cloned = new ForStatement;
        cloned.BlockStatement(self.start, owner);
        if (self.initializer != null)
            cloned.initializer = self.initializer.clone(cloned);
        if (self.condexpr != null)
            cloned.condexpr = self.condexpr.clone(cloned);
        if (self.iteration != null)
            cloned.iteration = clone_array(self.iteration, cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer = initializer.optimize();
        if (self.condexpr != null) {
            self.optimize_condition();
            if (self.getvalue() == CONDisfalse) {
                if (initializer != null)
                    return initializer;
                else
                    return new EmptyStatement;
            }
        }
        optimize_array(self.iteration);
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        var iteration = self.iteration;
        int has_iteration = iteration != null;
        if (self.initializer == null &&
                self.condexpr == null &&
                !(has_iteration)) {
            self.emit_infinite(e);
            return;
        }
        if (e.getDebug())
            e.comment('for loop');
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        string condlabel = has_iteration ?
                string(self.genlabel()) :
                continuelabel;
        if (self.initializer != null)
            self.initializer.emit(e);

        e.emitlabel(condlabel, 'for condition');
        if (self.condexpr != null)
            self.emit_else(e, breaklabel);

        self.body.emit(e);
        if (has_iteration) {
            e.emitlabel(continuelabel, 'for iteration');
            for (var it in iteration)
                it.emit_void(e);
        }
        e.emitgoto(condlabel);

        e.emitlabel(breaklabel, 'for end');
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : LoopStatement, BlockStatement
{
    var deftype;
    var varname;
    var container;

    function ForeachStatement(start, tk, owner, name, string type)
    {
        self.BlockStatement(start, owner);
        if (type != '') {
            string deftype = typetoregcheck(type);
            self.createvar(name, deftype);
            self.deftype = deftype;
        }
        self.varname = name;
        self.container = parseExpr(tk, self);
        ExpectOp(')', tk);
        self.parsebody(tk);
    }
    function clone(owner)
    {
        var cloned = new ForeachStatement;
        cloned.BlockStatement(self.start, owner);
        var deftype = self.deftype;
        var varname = self.varname;
        if (deftype != null)
            cloned.createvar(varname, deftype);
        cloned.deftype = deftype;
        cloned.varname = varname;
        cloned.container = self.container.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        var container = self.container.optimize();

        // Optimize out iterating on compile time eveluated
        // null values and empty strings.
        if (container.isnull() ||
                (container.isstringliteral() &&
                length(container.get_value()) == 0))
            return new EmptyStatement;

        self.container = container;
        self.body = self.body.optimize();
        return self;
    }
    function emit(e)
    {
        self.annotate(e);
        string regcont;
        if (self.container.checkresult() == REGstring) {
            string value = self.container.emit_get(e);
            regcont = self.tempreg(REGvar);
            e.emitbox(regcont, value);
        }
        else
            regcont = self.container.emit_get(e);

        var itvar = self.getvar(self.varname);
        if (itvar == null)
            UndefinedVariable(self.varname, self);

        string iterator = self.createreg(REGvar);
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        e.emitif_null(regcont, breaklabel);
        e.emitarg2('iter', iterator, regcont);
        e.emitset(iterator, '0');
        e.emitlabel(continuelabel, 'for iteration');
        e.emitunless(iterator, breaklabel);
        e.emitarg2('shift', itvar.getreg(), iterator);
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, 'endfor');
    }
}

//*********************************************

function parseFor(t, tk, owner)
{
    ExpectOp('(', tk);
    var aux = tk.get();
    var in1 = tk.get();
    if (in1.iskeyword('in'))
        return new ForeachStatement(t, tk, owner, aux, '');
    else {
        var in2 = tk.get();
        if (in2.iskeyword('in'))
            return new ForeachStatement(t, tk, owner, in1, aux);
        tk.unget(in2);
        tk.unget(in1);
        tk.unget(aux);
    }
    return new ForStatement(t, tk, owner);
}

//*********************************************
//            ThrowStatement
//*********************************************

class ThrowStatement : Statement
{
    var excep;

    function ThrowStatement(start, tk, owner)
    {
        self.Statement(start, owner);
        self.excep = parseExpr(tk, self);
    }
    function clone(owner)
    {
        var cloned = new ThrowStatement;
        cloned.Statement(self.start, owner);
        cloned.excep = self.excep.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.excep = self.excep.optimize();
        return self;
    }
    function emit(e)
    {
        var excep = self.excep;
        string reg = excep.emit_get(e);
        self.annotate(e);
        switch (excep.checkresult()) {
          case REGvar:
            // Nothing to do here
            break;
          case REGstring:
            // Build a Exception with default values and the message provided
            string msg = reg;
            reg = self.tempreg(REGvar);
            e.print(sformat(
<<:
    root_new %0, ['parrot';'Exception']
    %0['message'] = %1
:>>
                , reg, msg));
            break;
          default:
            SyntaxError("Invalid throw argument", self);
        }
        e.emitarg1('throw', reg);
    }
}

//*********************************************
//            TryStatement
//*********************************************

class TryModifierList : ModifierList
{
    var start;
    function TryModifierList(start, tk, owner)
    {
        self.start = start;
        self.ModifierList(tk, owner);
    }
    function allowtailcall()
    {
        return self.pick('allowtailcall') != null;
    }
    function emitmodifiers(e, string reghandler)
    {
        var modiflist = self.getlist();
        for (var modif in modiflist) {
            string modifname = modif.getname();
            int nargs = modif.numargs();
            switch (modifname) {
              case 'min_severity':
              case 'max_severity':
                if (nargs != 1)
                    SyntaxError('Wrong modifier args', self);
                var arg = modif.getarg(0);
                e.say(sformat(INDENT + "%0.'%1'(%2)",
                        reghandler, modifname, arg.emit_get(e)));
                break;
              case 'handle_types':
              case 'handle_types_except':
                string argregs [];
                for (int i = 0; i < nargs; ++i) {
                    var arg = modif.getarg(i);
                    push(argregs, arg.emit_get(e));
                }
                e.say(sformat(INDENT + "%0.'%1'(%2)",
                        reghandler, modifname, join(', ', argregs)));
                break;
              case 'allowtailcall':
                break;
              default:
                SyntaxError("Modifier '" + modifname + "' not valid for try", self);
            }
        }
    }
}

class TryStatement : BlockStatement
{
    var stry;
    var modifiers;
    var exname;
    var scatch;

    function TryStatement(start, tk, owner)
    {
        self.BlockStatement(start, owner);
        var t = tk.get();
        if (t.isop('['))
            self.modifiers = new TryModifierList(t, tk, self);
        else
            tk.unget(t);

        self.stry = parseStatement(tk, self);
        t = tk.get();
        if (! t.iskeyword('catch'))
            ExpectedOp('catch', t);
        t = tk.get();
        if (! t.isop('('))
            Expected("'(' after 'catch'", t);
        t = tk.get();
        if (! t.isop(')')) {
            string exname = t.getidentifier();
            self.exname = t;
            self.createvar(exname, REGvar);
            t = tk.get();
            if (! t.isop(')'))
                Expected("')' in 'catch'", t);
        }
        self.scatch = parseStatement(tk, self);
    }
    function allowtailcall()
    {
        if (self.modifiers != null)
            return self.modifiers.allowtailcall();
        else
            return false;
    }
    function optimize()
    {
        if (self.modifiers != null)
            self.modifiers.optimize();
        self.stry = self.stry.optimize();
        self.scatch = self.scatch.optimize();
        return self;
    }
    function emit(e)
    {
        string reghandler = self.tempreg(REGvar);
        string labelhandler = self.genlabel();
        string labelpasthandler = self.genlabel();
        string exreg = self.exname != null ?
            self.getvar(self.exname).getreg() :
            self.tempreg(REGvar);

        int edebug = e.getDebug();
        self.annotate(e);
        if (edebug)
            e.comment('try: create handler');
        e.print(sformat(
<<:
    new %0, 'ExceptionHandler'
    set_label %0, %1
:>>
            , reghandler, labelhandler));

        if (self.modifiers != null)
            self.modifiers.emitmodifiers(e, reghandler);

        e.emitarg1('push_eh', reghandler);
        if (edebug)
            e.comment('try: begin');
        self.stry.emit(e);
        if (edebug)
            e.comment('try: end');
        e.say(INDENT, 'pop_eh');

        self.annotate(e);
        e.emitgoto(labelpasthandler);

        if (edebug)
            e.comment('catch');
        e.emitlabel(labelhandler);
        e.say(INDENT, '.get_results(', exreg, ')');
        e.emitarg1('finalize', exreg);
        e.say(INDENT, 'pop_eh');
        self.scatch.emit(e);

        if (edebug)
            e.comment('catch end');
        e.emitlabel(labelpasthandler);
    }
}

//*********************************************
//            DeclarationModifierList
//*********************************************

/*
    Only for lexicals for a now. Testing.
*/

class DeclarationModifierList : ModifierList
{
    function DeclarationModifierList(tk, owner)
    {
        self.ModifierList(tk, owner);
    }
    function getlexicalname()
    {
        // Return the lexical name: null if there is not lexical modifier,
        // empty string if it has no arguments.
        var lexical = self.pick("lexical");
        if (lexical != null) {
            int nargs = lexical.numargs();
            switch (nargs) {
              case 0:
                return '';
              case 1:
                var name = lexical.getarg(0);
                if (! name.isstringliteral())
                    SyntaxError('Invalid lexical', self);
                return name.getPirString();
              default:
                SyntaxError("invalid arguments in modifier", lexical);
            }
        }
        return null;
    }
}

//*********************************************
//            DeclareItem
//*********************************************

/*
    Base class for all variable declarations.
*/

class DeclareItem : Statement
{
    var name;
    var reg;
    var modifiers;

    function DeclareItem(start, owner, name, string regtype, int flags)
    {
        self.Statement(start, owner);
        self.name = name;
        var vdata = self.createvar(name, regtype, flags);
        self.reg = vdata.getreg();
    }
    function parsemodifiers(start, tk)
    {
        ExpectOp("[", tk);
        self.modifiers = new DeclarationModifierList(tk, self.owner);
    }
    function optimizemodifiers()
    {
        var modifiers = self.modifiers;
        if (modifiers != null) {
            modifiers.optimize();
            string lexname = modifiers.getlexicalname();
            if (lexname != null) {
                // If no name specified, use the variable name.
                if (lexname == '')
                    lexname = self.name;
                var vardata = self.getvar(self.name);
                vardata.createlex(lexname);
            }
        }
    }
}

//*********************************************
//            VarBaseStatement
//*********************************************

class VarBaseStatement : DeclareItem
{
    function initvarbase(start, owner, name, int flags[optional])
    {
        self.DeclareItem(start, owner, name, REGvar, flags);
    }
}

//*********************************************
//            Declare Statements
//*********************************************

class DeclareBase : DeclareItem
{
    var basetype;
    var regtype;

    function DeclareBase(start, owner, name, string basetype, string regtype)
    {
        self.DeclareItem(start, owner, name, regtype, 0);
        self.basetype = basetype;
        self.regtype = regtype;
    }
}

//*********************************************

class DeclareSingleStatement : DeclareBase
{
    var init;

    function DeclareSingleStatement(start, owner, name, string basetype, tk)
    {
        self.DeclareBase(start, owner, name, basetype, basetype);
        var t = tk.get();
        if (t.isop(':')) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop('=')) {
            // Simple initializer
            self.init = parseExpr(tk, self);
        }
        else
            tk.unget(t);
    }
    function clonedeclare(cloned, owner)
    {
        cloned.DeclareBase(self.start, owner,
            self.name, self.basetype, self.regtype);
        if (self.init != null)
            cloned.init = self.init.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.optimizemodifiers();
        var init = self.init;
        if (init != null)
            self.init = init.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string name = self.name;
        string reg = self.reg;
        string ireg;
        string basetype = self.basetype;
        var init = self.init;
        if (e.getDebug())
            e.comment(name + ': ' + reg);

        if (init == null || init.isnull())
            e.emitnull(reg);
        else {
            string itype = init.checkresult();
            if (itype == basetype)
                init.emit_init(e, reg);
            else {
                if (init instanceof IndexExpr) {
                    // Use the declared type for the indexing
                    init.emit(e, reg);
                }
                else if (init.isliteral()) {
                    switch (basetype) {
                      case REGint:
                        ireg = int_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      case REGfloat:
                        ireg = float_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      case REGstring:
                        ireg = string_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      default:
                        InternalError("Wrong type", self);
                    }
                }
                else {
                    switch (itype) {
                      case REGnone:
                        SyntaxError('Invalid initialization from void value', self);
                      default:
                        ireg = init.emit_get(e);
                    }
                    if (basetype == REGstring && itype == REGvar) {
                        string auxlabel = self.genlabel();
                        e.emitnull(reg);
                        e.emitif_null(ireg, auxlabel);
                        e.emitset(reg, ireg);
                        e.emitlabel(auxlabel);
                    }
                    else
                        e.emitset(reg, ireg);
                }
            }
        }
    }
}

//*********************************************

class DeclareArrayStatement : DeclareBase
{
    var size;
    var initarray;
    var arraytype;

    function DeclareArrayStatement(start, owner,
            name, string basetype, string arraytype,
            tk)
    {
        self.DeclareBase(start, owner, name, basetype, REGvar);
        self.arraytype = arraytype;
        var t = tk.get();
        if (! t.isop(']')) {
            // Fixed length
            tk.unget(t);
            self.size = parseExpr(tk, self);
            ExpectOp(']', tk);
        }
        t = tk.get();
        if (t.isop(':')) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop('=')) {
            t = tk.get();
            if (! t.isop('['))
                Expected("array initializer", t);
            t = tk.get();
            if (! t.isop(']')) {
                tk.unget(t);
                self.initarray = parseList(tk, self, parseExpr, ']');
            }
        }
        else
            tk.unget(t);
    }
    function clonedeclare(cloned, owner)
    {
        cloned.DeclareBase(self.start, owner,
            self.name, self.basetype, REGvar);
        cloned.arraytype = self.arraytype;
        if (self.size)
            cloned.size = self.size.clone(cloned);
        if (self.initarray != null)
            cloned.initarray = clone_array(self.initarray, owner);
        return cloned;
    }
    function optimize()
    {
        self.optimizemodifiers();
        if (self.size != null)
            self.size = self.size.optimize();
        optimize_array(self.initarray);
        return self;
    }
    function emit(e)
    {
        self.annotate(e);

        string container = self.reg;
        var size = self.size;
        var init = self.initarray;
        var basetype = self.basetype;
        var arraytype = self.arraytype;
        __ASSERT__(arraytype != null);
        if (size != null) {
            // Fixed size array
            e.say(sformat(INDENT + "new %0, ['Fixed%1Array'], %2",
                    container, arraytype, size.emit_get(e)));
        }
        else {
            // Variable size array
            e.say(sformat(INDENT + "new %0, ['Resizable%1Array']",
                    container, arraytype));
        }
        if (init != null) {
            string auxitemreg = self.tempreg(basetype);
            int n = elements(init);
            if (size == null) {
                if (n != 0) {
                    // Allocate initializers size
                    e.emitset(container, n);
                }
            }
            int i = 0;
            for (var item in init) {
                string itemreg;
                if (item.isliteral() && item.checkresult() == basetype)
                    itemreg = item.emit_get(e);
                else {
                    item.emit(e, auxitemreg);
                    itemreg = auxitemreg;
                }
                e.say(sformat(INDENT + "%0[%1] = %2", container, i, itemreg));
                ++i;
            }
        }
    }
}

//*********************************************

function parseDeclareHelper(funsingle, funarray, start, tk, owner)
{
    var next;
    var r = null;
    do {
        var name = tk.get();
        RequireIdentifier(name);
        var t = tk.get();
        var item;
        if (t.isop('['))
            item = funarray(start, owner, tk, name);
        else {
            tk.unget(t);
            item = funsingle(start, owner, name, tk);
        }
        r = addtomulti(r, item);
        next = tk.get();
    } while (next.isop(','));
    RequireOp(';', next);
    return r;
}

//*********************************************

class IntStatement : DeclareSingleStatement
{
    function IntStatement(start, owner, name, tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGint, tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new IntStatement, owner);
    }
}

class IntArrayStatement : DeclareArrayStatement
{
    function IntArrayStatement(start, owner, name, tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGint, 'Integer', tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new IntArrayStatement, owner);
    }
}


function newIntSingle(start, owner, name, tk)
{
    return new IntStatement(start, owner, name, tk);
}

function newIntArray(start, owner, tk, name)
{
    return new IntArrayStatement(start, owner, name, tk);
}

function parseInt(start, tk, owner)
{
    return parseDeclareHelper(newIntSingle, newIntArray, start, tk, owner);
}

//*********************************************

class FloatStatement : DeclareSingleStatement
{
    function FloatStatement(start, owner, name, tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGfloat, tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new FloatStatement, owner);
    }
}

class FloatArrayStatement : DeclareArrayStatement
{
    function FloatArrayStatement(start, owner, name, tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGfloat, 'Float', tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new FloatArrayStatement, owner);
    }
}


function newFloatSingle(start, owner, name, tk)
{
    return new FloatStatement(start, owner, name, tk);
}

function newFloatArray(start, owner, tk, name)
{
    return new FloatArrayStatement(start, owner, name, tk);
}

function parseFloat(start, tk, owner)
{
    return parseDeclareHelper(newFloatSingle, newFloatArray, start, tk, owner);
}

//*********************************************

class StringStatement : DeclareSingleStatement
{
    function StringStatement(start, owner, name, tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGstring, tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new StringStatement, owner);
    }
}

class StringArrayStatement : DeclareArrayStatement
{
    function StringArrayStatement(start, owner, name, tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGstring, 'String', tk);
    }
    function clone(owner)
    {
        return self.clonedeclare(new StringArrayStatement, owner);
    }
}


function newStringSingle(start, owner, name, tk)
{
    return new StringStatement(start, owner, name, tk);
}

function newStringArray(start, owner, tk, name)
{
    return new StringArrayStatement(start, owner, name, tk);
}

function parseString(start, tk, owner)
{
    return parseDeclareHelper(newStringSingle, newStringArray, start, tk, owner);
}

//*********************************************
//            ConstStatement
//*********************************************

class ConstStatement : Statement
{
    var type;
    var name;
    var data;
    var value;

    function ConstStatement(var start, var owner,
            string type, var name, var value)
    {
        self.Statement(start, owner);
        self.type = type;
        self.name = name;
        self.value = value;
        self.data = self.createconst(name, type);
    }
    function optimize()
    {
        var value = self.value;
        string type = self.type;
        value = value.optimize();
        if (! value.hascompilevalue()) {
            SyntaxError('Value for const is not evaluable at compile time',
                self);
        }
        self.data.setvalue(value);
        return self;
    }
    function checkresult()
    {
        InternalError('Direct use of const', self.start);
    }
    function emit(e)
    {
        if (e.getDebug()) {
            var val = self.data.getvalue();
            string sval;
            switch (self.type) {
              case REGint:    sval = val.getIntegerValue(); break;
              case REGfloat:  sval = val.getFloatValue(); break;
              case REGstring: sval = val.getPirString(); break;
              default: __ASSERT__(false);
            }
            e.comment("Constant '" + string(self.name) +
                    "' set to: " + sval);
        }
    }
}

function parseConst(start, tk, owner)
{
    var t = tk.get();
    string type = typetoregcheck(t);
    if (type != REGint && type != REGfloat && type != REGstring)
        SyntaxError('Invalid type for const', start);

    var multi = null;
    do {
        var name = tk.get();
        ExpectOp('=', tk);
        var value = parseExpr(tk, owner);
        multi = addtomulti(multi,
                new ConstStatement(t, owner, type, name, value));
    } while ((t = tk.get()).isop(','));
    RequireOp(';', t);
    return multi;
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : VarBaseStatement
{
    var init;
    function VarStatement(start, tk, owner, name, int flags)
    {
        self.initvarbase(start, owner, name, flags);
        var t = tk.get();
        if (t.isop(':')) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop('=')) {
            self.init = parseExpr(tk, self);
            t = tk.get();
        }
        RequireOp(';', t);
    }
    function clone(owner)
    {
        var cloned = new VarStatement;
        cloned.initvarbase(self.start, owner, self.name, self.flags);
        if (self.init != null)
            cloned.init = self.init.clone(cloned);
        return cloned;
    }
    function optimize_init()
    {
        if (self.init != null)
            self.init = self.init.optimize();
        return self;
    }
    function optimize()
    {
        self.optimizemodifiers();
        return self.optimize_init();
    }
    function emit(var e)
    {
        self.annotate(e);
        string name =  self.name;
        string reg = self.reg;
        var init = self.init;
        if (e.getDebug())
            e.comment('var ' + name + ': ' + reg);
        if (init != null)
            if (init.isnull())
                init = null;
        if (init != null) {
            switch (init.checkresult()) {
              case REGvar:
                init.emit_init(e, reg);
                break;
              case REGstring:
              case REGint:
              case REGfloat:
                string value = init.emit_get(e);
                e.emitbox(reg, value);
                break;
              case REGnone:
                SyntaxError("Can't use void function as initializer", self);
              default:
                SyntaxError("Invalid var initializer", self);
            }
        }
        else
            e.emitnull(reg);
    }
}

class ResizableVarStatement : VarStatement
{
    function ResizableVarStatement(start, tk, owner, name)
    {
        self.initvarbase(start, owner, name);
        ExpectOp(';', tk);
    }
    function emit(var e)
    {
        self.annotate(e);
        string reg = self.reg;
        if (e.getDebug())
            e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'ResizablePMCArray'", reg));
    }
}

class FixedVarStatement : VarStatement
{
    var exprsize;

    function FixedVarStatement(start, tk, owner, name)
    {
        self.initvarbase(start, owner, name);
        self.exprsize = parseExpr(tk, self);
        ExpectOp(']', tk);
        ExpectOp(';', tk);
    }
    function optimize()
    {
        self.exprsize = self.exprsize.optimize();
        return self.optimize_init();
    }
    function emit(var e)
    {
        string regsize = self.exprsize.emit_get(e);
        self.annotate(e);
        string reg = self.reg;
        if (e.getDebug())
            e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'FixedPMCArray', %1", reg, regsize));
    }
}

function parseVar(start, tk, owner, int flags[optional])
{
    var name = tk.get();
    RequireIdentifier(name);
    var t = tk.get();
    if (t.isop('[')) {
        t = tk.get();
        if (t.isop(']'))
            return new ResizableVarStatement(start, tk, owner, name);
        else {
            tk.unget(t);
            return new FixedVarStatement(start, tk, owner, name);
        }
    }
    else {
        tk.unget(t);
        return new VarStatement(start, tk, owner, name, flags);
    }
}

function parseVolatile(start, tk, owner)
{
    var t = tk.get();
    if (!t.iskeyword('var'))
        SyntaxError("invalid volatile type", t);
    return parseVar(start, tk, owner, VAR_is_volatile);
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : MultiStatementBase, BlockStatement
{
    var end;
    var labels;

    function CompoundStatement(start, tk, owner)
    {
        self.BlockStatement(start, owner);
        self.labels = {};
        self.statements = [];
        var t;
        while (! (t = tk.get()).isop('}')) {
            tk.unget(t);
            var c = parseStatement(tk, self);
            if (c == null)
                InternalError('Unexpected null statement');
            push(self.statements, c);
        }
        self.end = t;
    }
    function clone(owner)
    {
        var cloned = new CompoundStatement;
        cloned.BlockStatement(self.start, owner);
        cloned.labels = {};
        cloned.end = self.end;
        cloned.statements = clone_array(self.statements, owner);
        return cloned;
    }
    function last()
    {
        var statements = self.statements;
        for (int i = elements(statements) - 1; i >= 0; --i) {
            var st = statements[i];
            if (st != null && ! st.isempty())
                return st;
        }
        return null;
    }
    function getlabel(string name)
    {
        var labels = self.labels;
        string exist = labels[name];
        if (exist == null || exist == '')
            exist = self.owner.getlabel(name);
        return exist;
    }
    function createlabel(var name)
    {
        string s = name;
        var labels = self.labels;
        string exist = labels[s];
        if (exist != null && exist != '')
            SyntaxError('Label already defined', name);
        string value = self.genlabel();
        labels[s] = value;
        return value;
    }
    function getend() { return self.end; }
    function emit(var e)
    {
        int edebug = e.getDebug();
        if (edebug)
            e.comment('{');
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        if (edebug)
            e.comment('}');
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function RegisterStore(string type)
    {
        self.type = type;
        // Registers number 0 are reserved for temporary usage in builtins.
        self.nreg = 1;
        string tempreg[];
        string freereg[];
        self.tempreg = tempreg;
        self.freereg = freereg;
    }
    function createreg()
    {
        var n = self.nreg;
        int i = n;
        string reg = i++;
        n =: i;
        return '$' + string(self.type) + reg;
    }
    function tempreg()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        string reg;
        if (elements(freereg) != 0)
            reg = freereg.pop();
        else
            reg = self.createreg();
        push(tempreg, reg);
        return reg;
    }
    function freetemps()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        int n = elements(tempreg);
        for (int i = n - 1; i >= 0; --i) {
            string s = tempreg[i];
            push(freereg, s);
        }
        tempreg =: 0;
    }
}

//*********************************************
//            FunctionParameter
//*********************************************

class ParameterModifierList : ModifierList
{
    function ParameterModifierList(tk, owner)
    {
        self.ModifierList(tk, owner);
    }
    function emitmodifiers(e, start, string paramname)
    {
        var named = null;
        var slurpy = null;
        var modarglist = self.getlist();
        for (var mod in modarglist) {
            string modname = mod.getname();
            switch (modname) {
              case 'named':
                named = mod;
                break;
              case 'slurpy':
                slurpy = mod;
                break;
              default:
                e.print(' :', modname);
            }
        }
        switch {
          case named != null && slurpy != null:
            // Special case for named slurpy: named refers
            // to the slurpy content, not to the param himself.
            // TODO: check that named has no arguments,
            // or use a different way.
            e.print(" :named :slurpy");
            break;
          case named != null:
            string setname;
            switch (named.numargs()) {
              case 0:
                setname = "'" + paramname + "'";
                break;
              case 1:
                var argmod = named.getarg(0);
                if (! argmod.isstringliteral())
                    SyntaxError('Invalid modifier', start);
                setname = argmod.getPirString();
                break;
              default:
                SyntaxError('Invalid modifier', start);
            }
            e.print(" :named(", setname, ")");
            break;
          case slurpy != null:
            e.print(" :slurpy");
            break;
        }
    }
}

class FunctionParameter
{
    var func;
    var name;
    var modifiers;
    var type;
    var defaultexpr;
    function FunctionParameter(func, tk)
    {
        // Syntax: [type] name [modifiers] [ = default]

        self.func = func;
        var t = tk.get();
        string type = typetoregcheck(t.checkkeyword());
        if (type != '')
            t = tk.get();
        else
            type = REGvar;
        self.type = type;
        string argname = '__ARG_' + string(func.getparamnum());
        func.createvarnamed(t, type, argname);
        self.name = string(t);

        // Modifiers
        t = tk.get();
        if (t.isop('[')) {
            self.modifiers = new ParameterModifierList(tk, func.owner);
            t = tk.get();
        }
        // Default value
        if (t.isop('='))
            self.defaultexpr = new FunctionParameterDefault(tk, func, self);
        else
            tk.unget(t);
    }
    function optimize()
    {
        var def = self.defaultexpr;
        if (def != null) {
            def.optimize();
            def.setoptflag("__opt_flag" + string(self.getvar().getreg()));
        }
        return self;
    }
    function emit(e)
    {
        var func = self.func;
        string paramname = self.name;
        var param = self.getvar();
        string ptype = typetopirname(param.gettype());
        e.print(INDENT + INDENT + '.param ', ptype, ' ', param.getreg());
        var modarg = self.modifiers;
        if (modarg != null)
            modarg.emitmodifiers(e, func.start, paramname);
        var def = self.defaultexpr;
        if (def != null)
            e.print(" :optional\n" + INDENT + INDENT + ".param int ",
                    def.getoptflag(), " :opt_flag");
        e.say('');
    }
    function emitdefault(e)
    {
        var def = self.defaultexpr;
        if (def != null)
            def.emit(e);
    }
    function get_type()
    {
        return self.type;
    }
    function getvar()
    {
        return self.func.getvar(self.name);
    }
}

class FunctionParameterDefault
{
    var owner;
    var param;
    var expr;
    var reg;
    function FunctionParameterDefault(tk, owner, param)
    {
        self.owner = owner;
        self.param = param;
        self.expr = parseExpr(tk, owner);
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        var paramvar = self.param.getvar();
    }
    function setoptflag(string reg)
    {
        self.reg = reg;
    }
    function getoptflag()
    {
        var reg = self.reg;
        if (reg == null)
            InternalError("Invalid parameter default usage", self.param);
        return string(reg);
    }
    function emit(e)
    {
        var expr = self.expr;
        if (! expr.isnull()) {
            var param = self.param;
            var pvar = param.getvar();
            string label = self.owner.genlabel();
            string optflag = self.getoptflag();
            e.emitif(optflag, label);
            string reg = pvar.getreg();
            string type = pvar.gettype();
            if (type == expr.checkresult())
                expr.emit_init(e, reg);
            else {
                var defreg = expr.emit_get(e);
                if (type == REGvar)
                    e.emitbox(reg, defreg);
                else
                    e.emitset(reg, defreg);
            }
            e.emitlabel(label);
        }
    }
}

function parseParameter(tk, owner)
{
    return new FunctionParameter(owner, tk);
}

//*********************************************
//            FunctionExtern
//*********************************************

class FunctionExtern : CommonBase
{
    var name;
    function FunctionExtern(start, owner)
    {
        self.initbase(start, owner);
        self.name = start;
    }
    function emit_get(e, owner)
    {
        var path = self.owner.getpath();
        string reg = owner.tempreg(REGvar);
        self.annotate(e);
        path.emit_get_global(e, owner, reg, self.name);
        return reg;
    }
}

//*********************************************
//            FunctionBase
//*********************************************

function emit_subid(string subid)
{
    return ".const 'Sub' " + subid + ' = "' + subid + '"' + "\n";
}

class FunctionModifierList : ModifierList
{
    function FunctionModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function emit(e)
    {
        for (var m in self.getlist()) {
            string name = m.getname();

            if (name == 'multi') // Is handled elsewere
                continue;
            int nargmods = m.numargs();
            e.print(' :', name);
            if (nargmods > 0) {
                e.print('(');
                for (int iargmod = 0; iargmod < nargmods; ++iargmod) {
                    var argmod = m.getarg(iargmod);
                    if (!argmod.isstringliteral())
                        SyntaxError('Invalid modifier', argmod);
                    e.print(argmod.getPirString());
                    if (iargmod < nargmods - 1)
                        e.print(", ");
                }
                e.print(')');
            }
        }
    }
}

function multi_sig_from_multi_modifier(owner, multi)
{
    int nargs = multi.numargs();
    var sig;
    if (nargs) {
        sig = [];
        for (int i = 0; i < nargs; ++i) {
            var arg = multi.getarg(i);
            switch {
              case arg.isstringliteral():
                push(sig, arg.get_value());
                break;
              case arg.isidentifier():
                string name = arg.getName();
                switch (name) {
                  case "int": case "string":
                    push(sig, name); break;
                  case "float":
                    push(sig, "num"); break;
                  case "var":
                    push(sig, "pmc"); break;
                  default:
                    SyntaxError("unsupported multi signature", arg);
                }
                break;
              case arg instanceof OpClassExpr:
                var key = arg.get_class_raw_key();
                if (key == null)
                    SyntaxError("class not found", arg);
                __ASSERT__(key instanceof 'ResizableStringArray');
                push(sig, getparrotkey(key));
                break;
              default:
                SyntaxError("unsupported multi signature", arg);
            }
        }
    }
    return sig;
}

class FunctionBase : BlockStatement
{
    var name;
    var subid;
    var modifiers;
    var params;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;
    var localfun;
    var lexicals;
    var usedlexicals;
    var usedsubids;
    var outer;

    function FunctionBase(start, owner)
    {
        self.BlockStatement(start, owner);
        self.nlabel = 0;
        self.regstI = new RegisterStore(REGint);
        self.regstN = new RegisterStore(REGfloat);
        self.regstS = new RegisterStore(REGstring);
        self.regstP = new RegisterStore(REGvar);
    }

    function getouter() { return self; }
    function allowtailcall()
    {
        return true;
    }
    function makesubid()
    {
        // Return the subid for this function, creating if it doesn't have one
        var subid = self.subid;
        if (subid == null)
            self.subid = subid = self.generatesubid();
        return subid;
    }
    function usesubid(string id)
    {
        var used = self.usedsubids;
        if (used == null)
            self.usedsubids = used = {};
        used[id] = 1;
    }

    function same_scope_as(other)
    {
        int r = self === other;
        return r;
    }
    function parse_parameters(tk)
    {
        var t = tk.get();
        if (! t.isop(')')) {
            tk.unget(t);
            self.params = parseList(tk, self, parseParameter, ')');
        }
    }

    function addlocalfunction(fn)
    {
        var localfun = self.localfun;
        if (localfun == null)
            self.localfun = [ fn ];
        else
            push(localfun, fn);
    }
    function usenamespace(ns)
    {
        __ASSERT__(ns != null);
        var usedns = self.usednamespaces;
        if (usedns == null)
            self.usednamespaces = [ ns ];
        else {
            if (find_same(usedns, ns) != null)
                return;
            push(usedns, ns);
        }
    }
    function scopesearch(key, int flags)
    {
        for (var ns in self.usednamespaces) {
            var found = ns.scopesearch(key, flags);
            if (found != null)
                return found;
        }
        return self.owner.scopesearch(key, flags);
    }

    function optimize()
    {
        var modifiers = self.modifiers;
        if (modifiers != null) {
            var multi = modifiers.pick('multi');
            if (multi != null) {
                __ASSERT__(self instanceof FunctionStatement);
                self.setmulti();
                self.multi_sig = multi_sig_from_multi_modifier(self, multi);
            }
        }
        optimize_array(self.params);
        for_each(self.usednamespaces, bindmethod("fixnamespaces"));
        self.body = self.body.optimize();
        return self;
    }

    function setusedlex(string lexname, string regname)
    {
        var lexicals = self.usedlexicals;
        if (lexicals == null)
            self.usedlexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function setlex(string lexname, string regname)
    {
        var lexicals = self.lexicals;
        if (lexicals == null)
            self.lexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function createlex(vardata)
    {
        // Get the lexname for a variable, creating it on the fly
        // when needed.
        string lexname = vardata.getlex();
        if (lexname == null) {
            lexname = "'__WLEX_" + string(self.getlexnum()) + "'";
            vardata.createlex(lexname);
        }
        return lexname;
    }

    function createreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in createreg: " + type);
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in tempreg: " + type);
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for_each([ self.regstI, self.regstN, self.regstS, self.regstP ],
            bindmethod("freetemps"));
    }
    function genlabel()
    {
        int n = ++self.nlabel;
        return '__label_' + string(n);
    }
    function getbreaklabel(pos)
    {
        SyntaxError('break not allowed here', pos);
    }
    function getcontinuelabel(pos)
    {
        SyntaxError('continue not allowed here', pos);
    }

    function emit_extra_modifiers(e) { }

    function emit(var e)
    {
        string name = self.name;
        e.say();
        e.print(".sub ");
        if (self.isanonymous())
            e.print("'' :anon");
        else
            e.print("'", name, "'");
        if (self.subid != null)
            e.print(" :subid('", self.subid, "')");

        var outer = self.outer;
        if (outer != null && self.usedlexicals != null) {
            var outerid = outer.subid;
            if (outerid != null)
                e.print(" :outer('", outerid, "')");
        }

        // Modifiers
        if (self.ismethod())
            e.print(' :method');
        var modifiers = self.modifiers;
        if (modifiers != null)
            modifiers.emit(e);
        else {
            if (name == 'main')
                e.print(' :main');
        }
        self.emit_extra_modifiers(e);
        e.say();

        // Emit Parameters
        var params = self.params;
        emit_array(e, params);

        // Emit .const 'Sub' declarations for used subs
        e.print(join("", transform(self.usedsubids, [], emit_subid)));

        // Emit default values for optional params
        for_each(params, bindlast(bindmethod("emitdefault"), e));

        // Emit lexicals
        var lexicals = self.lexicals;
        var usedlexicals = self.usedlexicals;
        if (lexicals != null || usedlexicals != null) {
            e.annotate(self.start);
            // lexicals declared in this function and its inner scopes
            for (string l in lexicals)
                e.say(sformat(".lex %0, %1", lexicals[l], l));
            // lexicals from outers used inside
            for (string l in usedlexicals) {
                if (substr(l, 0, 1) != '$')
                    e.say(INDENT + ".local pmc " + l);
                e.emitfind_lex(l, usedlexicals[l]);
            }
        }

        int edebug = e.getDebug();
        var body = self.body;
        if (body.isempty()) {
            if (edebug)
                e.comment('Empty body');
        }
        else {
            if (edebug)
                e.comment('Body');
            body.emit(e);
            e.annotate(body.getend());
        }
        e.say("\n.end # ", name, "\n");

        // Local functions
        for_each(self.localfun, bindlast(bindmethod("emit"), e));
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

class FunctionStatement : FunctionBase
{
    var paramnum;
    var lexnum;
    var is_multi;
    var multi_sig;

    function FunctionStatement(start, tk, owner)
    {
        self.FunctionBase(start, owner);
        self.paramnum = 0;
        self.lexnum = 0;
        self.parse(tk);
        self.is_multi = new ["Boolean"];
    }

    function isanonymous() { return false; }
    function getparamnum()
    {
        // Get a number to assign unique internal names to params.
        return int(++self.paramnum);
    }
    function getlexnum()
    {
        // Get a number to assign unique internal names to lexicals.
        return int(++self.lexnum);
    }
    function ismethod() { return false; }

    function ismulti()
    {
        return self.is_multi ? true : false;
    }
    function setmulti()
    {
        self.is_multi =: true;
    }
    function default_multi_sig()
    {
        var multi_sig = [];
        if (self.ismethod())
            push(multi_sig, "_");
        transform(self.params, multi_sig,
                function (param)
                {
                    return typetopirname(param.get_type());
                }
        );
        return multi_sig;
    }
    function parse(tk)
    {
        var name = tk.get();
        self.name = name;
        var t = tk.get();
        if (t.isop('[')) {
            self.modifiers = new FunctionModifierList(tk, self.owner);
            t = tk.get();
        }
        RequireOp('(', t);
        self.parse_parameters(tk);

        var path = self.owner.getpath().createchild(name.getidentifier());
        createPredefConstString(self, '__FUNCTION__', path.fullname());

        t = tk.get();
        if (!t.isop('{'))
            ExpectedOp('{', t);
        self.body = new CompoundStatement(t, tk, self);
        return self;
    }

    function emit_extra_modifiers(e)
    {
        if (self.is_multi) {
            var multi_sig = self.multi_sig;
            if (multi_sig == null)
                multi_sig = self.default_multi_sig();
            e.print(' :multi(', join(", ", multi_sig), ')');
        }
    }
}

//*********************************************
//            LocalFunctionStatement
//*********************************************

class LocalFunctionStatement : FunctionBase
{
    function LocalFunctionStatement(start, tk, owner)
    {
        self.FunctionBase(start, owner);
        var outer = owner.getouter();
        if (outer instanceof InlineStatement)
            throw SyntaxError("local functions not allowed in inline", self);
        outer.makesubid();
        self.outer = outer;
        var subid = self.makesubid();
        self.name = subid;
        self.parse_parameters(tk);
        var t = tk.get();
        RequireOp('{', t);
        self.body = new CompoundStatement(t, tk, self);
        owner.addlocalfunction(self);
    }
    function isanonymous() { return true; }
    function ismethod() { return false; }
    function needclosure()
    {
        if (self.lexicals != null || self.usedlexicals != null)
            return true;
        return null != find_if(self.localfun, bindmethod("needclosure"));
    }
    function getsubid()
    {
        return self.subid;
    }
    function getparamnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.getparamnum();
    }
    function getlexnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.getlexnum();
    }
    function checkvarlexical(name, vardata)
    {
        /*
            If the var data is a lexical in some outer scope, create a
            local variable and set it as a used lexical.
            Otherwise, return it unchanged.
        */
        if (vardata.isconst())
            return vardata;
        string reg = vardata.getreg();
        //TEMPORARY WORKAROUND
        if (substr(reg, 0, 6) == 'WSubId') {
            self.usesubid(reg);
            return vardata;
        }
        var scope = vardata.getscope();
        var ownerscope = scope.getouter();
        var outer = self.outer;
        if (ownerscope instanceof FunctionBase) {
            if (ownerscope.same_scope_as(outer)) {
                string lexname = scope.makelexical(vardata);
                int flags = vardata.getflags() | VAR_is_lexical;
                string type = vardata.gettype();
                if (type != REGvar)
                    flags = flags | VAR_is_volatile;
                var localvar = self.createvar(name, vardata.gettype(), flags);
                localvar.setlex(lexname);
                self.setusedlex(lexname, localvar.getreg());
                return localvar;
            }
        }
        return vardata;
    }
    function getvar(name)
    {
        var localvar = self.getlocalvar(name);
        if (localvar == null)
            localvar = self.getusedvar(name);
        if (localvar == null) {
            // Not found in function scope, search external scopes
            // and check lexicals.
            localvar = self.owner.getvar(name);
            if (localvar == null) {
                // Special case for self in methods
                if (name == SELF) {
                    var ownerscope = self.outer;
                    if (self.outer.ismethod()) {
                        string lexself = ownerscope.makelexicalself();
                        localvar = self.createvar(name, REGvar);
                        string reg = localvar.getreg();
                        self.setusedlex(lexself, reg);
                    }
                }
            }
            else
                localvar = self.checkvarlexical(name, localvar);
        }
        if (localvar != null && !(localvar instanceof VarData))
            InternalError('Incorrect data for variable in LocalFunction');
        return localvar;
    }
}

//*********************************************
//            MethodStatement
//*********************************************

class MethodStatement : FunctionStatement
{
    function MethodStatement(t, tk, owner)
    {
        self.FunctionStatement(t, tk, owner);
    }
    function ismethod() { return true; }
}

//*********************************************
//            InlineStatement
//*********************************************

class InlineParam : CommonBase
{
    var flags;
    var type;
    var name;
    function InlineParam(tk, owner)
    {
        int flags = 0;
        var name = tk.get();
        self.initbase(name, owner);
        if (name.getidentifier() == "const") {
            flags = flags | 1;
            name = tk.get();
        }
        string type;
        var t = tk.get();
        if (t.isop(",") || t.isop(")")) {
            type = REGany;
            tk.unget(t);
        }
        else {
            type = typetoregcheck(name.getidentifier());
            name = t;
        }
        self.flags = flags;
        self.type = type;
        self.name = name;
    }
    function isconst()
    {
        return int(self.flags) & 1;
    }
    function getname()
    {
        return self.name;
    }
    function gettype()
    {
        return self.type;
    }
}

class InlineStatement : BlockStatement, VarContainer
{
    var name;
    var rettype;
    var body;
    var params;
    function InlineStatement(start, tk, owner)
    {
        self.BlockStatement(start, owner);
        var name = tk.get();
        ExpectOp("(", tk);
        var t = tk.get();
        var params;
        if (! t.isop(")")) {
            tk.unget(t);
            params = [];
            do {
                var param = new InlineParam(tk, self);
                params.push(param);
            } while ((t = tk.get()).isop(","));
            RequireOp(")", t);
        }
        t = tk.get();
        string type;
        if (t.iskeyword('return')) {
            t = tk.get();
            string nametype = t.getidentifier();
            type = typetoregcheck(nametype);
            if (type == '')
                SyntaxError("Invalid return type", t);
            t = tk.get();
        }
        else
            type = REGnone;
        RequireOp("{", t);
        tk.unget(t);
        var body = parseStatement(tk, self);

        self.name = name;
        self.rettype = type;
        self.params = params;
        self.body = body;
    }
    function getouter() { return self; }
    function createreg(string type) { return "FAKEREG"; }
}

class InlinedBlock : BlockStatement
{
    var inliner;
    var inlined;
    var usedsubids;
    var params;
    var args;
    var body;
    var endlabel;
    var retreg;
    function InlinedBlock(inlined, inliner, args)
    {
        self.BlockStatement(inliner.start, inlined);
        self.inliner = inliner;
        self.inlined = inlined;
        var params = inlined.params;
        int nparams = params == null ? 0 : elements(params);
        int nargs = args == null ? 0 : args.numargs();
        if (nparams != nargs)
            SyntaxError("Wrong arguments in inline expansion", inliner);
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            var name = param.getname();
            var arg = args.getfreearg(i);
            string type = param.gettype();
            if (type == REGany)
                type = arg.checkresult();
            int isconst = param.isconst();
            if (isconst && arg.hascompilevalue()) {
                var cdata = self.createconst(name, type);
                cdata.setvalue(arg);
            }
            else
                self.createvar(name, type, 0);
        }
        self.params = params;
        self.args = args;
        var body = inlined.body;
        body = body.clone(self);
        body = body.optimize();
        self.body = body;
    }
    function getouter() { return self; }
    function islaststatement(st)
    {
        __ASSERT__(st != null);
        var stcheck = self.body;
        while (stcheck != null && (stcheck instanceof CompoundStatement))
            stcheck = stcheck.last();
        return stcheck === st;
    }
    function createreg(string type)
    {
        return self.inliner.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.inliner.tempreg(type);
    }
    function freetemps()
    {
        self.inliner.owner.freetemps();
    }
    function usesubid(string id)
    {
        var used = self.usedsubids;
        if (used == null)
            self.usedsubids = used = {};
        used[id] = 1;
    }
    function genlabel()
    {
        return self.inliner.genlabel();
    }

    function getendlabel()
    {
        return self.endlabel;
    }
    function getrettype()
    {
        return self.inlined.rettype;
    }
    function checkresult()
    {
        return self.inlined.rettype;
    }
    function getretreg()
    {
        return self.retreg;
    }
    function emit_it(e)
    {
        if (e.getDebug())
            e.comment("inlined start");
        self.endlabel = self.genlabel();
        var params = self.params;
        var args = self.args;
        int nparams = params == null ? 0 : elements(params);
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            var arg = args.getfreearg(i);
            if (param.isconst() && arg.hascompilevalue())
                continue;
            string type = param.gettype();
            string argtype = arg.checkresult();
            string reg = self.getvar(param.getname()).getreg();
            if (type == REGany || argtype == type)
                arg.emit_init(e, reg);
            else {
                string aux = arg.emit_get(e);
                if (type == REGvar)
                    e.emitbox(reg, aux);
                else
                    e.emitset(reg, aux);
            }
        }
        e.print(join("", transform(self.usedsubids, [], emit_subid)));
        self.body.emit(e);
        e.emitlabel(self.endlabel);
    }
    function emit(e, string result)
    {
        string type = self.getrettype();
        self.retreg = result;
        int edebug = e.getDebug();
        self.emit_it(e);
        if (e.getDebug())
            e.comment("inlined end");
    }
    function emit_void(e)
    {
        self.emit_it(e);
        if (e.getDebug())
            e.comment("inlined end");
    }
    function emit_get(e)
    {
        string type = self.checkresult();
        if (type == REGnone)
            SyntaxError("Cannot get a result from a void inline", self);
        string reg = self.createreg(type);
        self.retreg = reg;
        self.emit_it(e);
        if (type == REGvar) {
            // Let the value be garbage collected when no more used
            var aux = self.tempreg(REGvar);
            e.emitset(aux, reg);
            reg = aux;
        }
        if (e.getDebug())
            e.comment("inlined end");
        return reg;
    }
}

class InlineRef : FinalExpr
{
    var inlined;
    function InlineRef(owner, start, sym)
    {
        __ASSERT__(sym instanceof InlineStatement);
        self.Expr(start, owner);
        self.inlined = sym;
    }
    function checkresult() { return REGnone; }
    function misused()
    {
        SyntaxError("inline used by reference", self.start);
    }
    function emit_void(e)
    {
        self.misused();
    }
    function emit_get(e)
    {
        self.misused();
    }
    function emit(e, string result)
    {
        self.misused();
    }
}

class CallInlineExpr : FinalExpr
{
     var block;
     function CallInlineExpr(owner, funref, args)
     {
        self.Expr(funref.start, owner);
        self.block = new InlinedBlock(funref.inlined, owner, args);
     }
     function checkresult() { return self.block.checkresult(); }
     function emit_void(e)
     {
         self.block.emit_void(e);
     }
     function emit_get(e)
     {
         return self.block.emit_get(e);
     }
     function emit(e, string result)
     {
         self.block.emit(e, result);
     }
}

//*********************************************
//            MultiAssignStatement
//*********************************************

class SigParameter
{
    var owner;
    var name;
    var modifiers;
    var reg;
    var defaultexpr;
    function SigParameter(tk, owner)
    {
        self.owner = owner;
        var name = tk.get();
        if (! name.isidentifier())
            ExpectedIdentifier(name);
        var t = tk.get();
        if (t.isidentifier()) {
            string type = typetoregcheck(name.checkkeyword());
            name = t;
            owner.createvar(name, type);
            t = tk.get();
        }
        self.name = name;
        var data = owner.getvar(name.getidentifier());
        self.reg = data.getreg();
        if (t.isop('[')) {
            self.modifiers = new ParameterModifierList(tk, self);
            t = tk.get();
        }
        if (t.isop('='))
            self.defaultexpr = new FunctionParameterDefault(tk, owner, self);
        else
            tk.unget(t);
    }
    function getvar()
    {
        return self.owner.getvar(self.name.getidentifier());
    }
    function optimize()
    {
        var def = self.defaultexpr;
        if (def != null) {
            def.optimize();
            def.setoptflag(self.owner.createreg(REGint));
        }
        return self;
    }
    function emit(e)
    {
        e.print(self.reg);
        var modifiers = self.modifiers;
        if (modifiers != null) {
            var name = self.name;
            modifiers.emitmodifiers(e, name, name);
        }
        var def = self.defaultexpr;
        if (def != null)
            e.print(" :optional, ", def.getoptflag(), " :opt_flag");
    }
    function emitdefault(e)
    {
        var def = self.defaultexpr;
        if (def != null)
            def.emit(e);
    }
}

function parseSigParameter(tk, owner)
{
    return new SigParameter(tk, owner);
}

class SigParameterList
{
    var params;
    function SigParameterList(tk, owner)
    {
        self.params = parseList(tk, owner, parseSigParameter, ')');
    }
    function optimize()
    {
        optimize_array(self.params);
    }
    function emit(e)
    {
        e.print('(');
        string sep = '';
        for (var param in self.params) {
            e.print(sep);
            param.emit(e);
            sep = ', ';
        }
        e.print(')');
    }
    function emitdefaults(e)
    {
        for (var param in self.params)
            param.emitdefault(e);
    }
}

class MultiAssignStatement : Statement
{
    var params;
    var expr;
    function MultiAssignStatement(start, owner, params, expr)
    {
        self.Statement(start, owner);
        self.params = params;
        self.expr = expr;
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        self.params.optimize();
        return self;
    }
    function emit(e)
    {
        var expr = self.expr;
        if (! (expr instanceof CallExpr))
            SyntaxError('multi assignment used with non function call', expr);
        var call = expr.emitcall(e);
        expr.prepareargs(e);
        var params = self.params;
        e.print(INDENT);
        params.emit(e);
        e.print(' = ', call);
        expr.emitargs(e);
        e.say();
        params.emitdefaults(e);
    }
}

//*********************************************
//            Class specifier
//*********************************************

const int
    CLASSSPECIFIER_invalid   = 0,
    CLASSSPECIFIER_str       = 1, // Literal name
    CLASSSPECIFIER_parrotkey = 2, // Parrot key
    CLASSSPECIFIER_id        = 3; // Identifier, maybe qualified

class ClassSpecifier : CommonBase
{
    function ClassSpecifier(owner, start)
    {
        self.initbase(start, owner);
    }
    function reftype() { return CLASSSPECIFIER_invalid; }

    function annotate(e)
    {
        e.annotate(self.start);
    }
}

class ClassSpecifierStr : ClassSpecifier
{
    var name;
    function ClassSpecifierStr(owner, name)
    {
        self.ClassSpecifier(owner, name);
        self.name = name;
    }
    function reftype() { return CLASSSPECIFIER_str; }

    function emit(e, ns)
    {
        string basestr = self.name;
        e.print(basestr);
    }
}

class ClassSpecifierParrotKey : ClassSpecifier
{
    var key;
    var hll;
    function ClassSpecifierParrotKey(tk, owner, start)
    {
        self.ClassSpecifier(owner, start);
        var key = [];
        var t = tk.get();
        if (!t.isstring())
            Expected('literal string', t);
        push(key, t.rawstring());
        t = tk.get();
        if (! t.isop(']')) {
            switch (t.checkop()) {
              case ':':
                self.hll = true;
              case ',':
                break;
              default:
                Unexpected('token in class key', t);
            }
            do {
                t = tk.get();
                if (!t.isstring())
                    Expected('literal string', t);
                push(key, t.rawstring());
            } while ((t = tk.get()).isop(','));
            RequireOp(']', t);
        }
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_parrotkey; }
    function hasHLL()
    {
        return int(self.hll != null);
    }

    function checknskey(from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }
    function emit(e, ns)
    {
        e.print(getparrotkey(self.key));
    }
}

class ClassSpecifierId : ClassSpecifier
{
    var key;
    function ClassSpecifierId(tk, owner, id)
    {
        self.ClassSpecifier(owner, id);
        var key = [ string(id) ];
        var t;
        while ((t = tk.get()).isop('.')) {
            t = tk.get();
            push(key, string(t));
        }
        tk.unget(t);
        self.key = key;
    }
    function clone(owner)
    {
        var cloned = new ClassSpecifierId;
        cloned.ClassSpecifier(owner, self.start);
        cloned.key = self.key;
        return cloned;
    }
    function reftype() { return CLASSSPECIFIER_id; }

    function last()
    {
        var key = self.key;
        return key[-1];
    }
    function checknskey(from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }

    function emit(e, ns)
    {
        var key = ns.scopesearch(self.key, SEARCH_CLASS);
        if (key == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.print(getparrotkey(self.key));
        }
        else e.print(key.getclasskey());
    }
    function emit_new(e, from, string regnew)
    {
        var nskey = self.checknskey(from);
        if (nskey == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.say("new ", regnew, ", ", getparrotkey(self.key));
        }
        else {
            nskey.emit_new(e, from, regnew);
        }
    }
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassBase : CommonBase
{
    var name;
    var classns;
    function ClassBase(start, name, parent)
    {
        self.initbase(start, parent);
        self.name = name;
        var classns = parent.getpath().createchild(name);
        self.classns = classns;
    }
    function getpath()
    {
        return self.classns;
    }
    function getclasskey()
    {
        return self.classns.getparrotkey();
    }
}

class FunctionContainer
{
    var functions;
    function FunctionContainer()
    {
        self.functions = {};
    }
    function addfunction(newfunc)
    {
        __ASSERT__((newfunc instanceof Builtin) ||
                   (newfunc instanceof FunctionStatement) ||
                   (newfunc instanceof FunctionExtern));
        var functions = self.functions;
        string name = newfunc.name;
        var func = functions[name];
        if (func == null)
            functions[name] = newfunc;
        else {
            if (func instanceof FunctionStatement)
                func.setmulti();
            if (newfunc instanceof FunctionStatement)
                newfunc.setmulti();
        }
    }
    function find(string name)
    {
        var functions = self.functions;
        return functions[name];
    }
}

class ClassStatement : ClassBase, VarContainer
{
    var parent;
    var bases;
    var constants;
    var items;
    var members;
    var funcont;

    function ClassStatement(start, name, parent, tk)
    {
        self.ClassBase(start, name, parent);
        self.VarContainer();
        self.funcont = new FunctionContainer();
        self.parent = parent;
        var items = [];
        self.items = items;
        var members = [];
        self.members = members;

        var t = tk.get();
        if (t.isop(':')) {
            self.bases = parseList(tk, self, parseClassSpecifier);
            t = tk.get();
        }
        RequireOp('{', t);

        createPredefConstString(self, '__CLASS__', self.classns.fullname());

        for (t = tk.get(); !t.isop('}'); t = tk.get()) {
            switch (t.checkkeyword()) {
              case 'function':
                var f = new MethodStatement(t, tk, self);
                self.addmethod(f);
                push(items, f);
                break;
              case 'var':
                var name = tk.get();
                if (! name.isidentifier())
                   Expected("member identifier", name);
                push(members, name);
                t = tk.get();
                if (! t.isop(';'))
                    Expected("';' in member declaration", t);
                break;
              case 'const':
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              default:
                Unexpected("item in class", t);
            }
        }
    }
    function getlabel(string name)
    {
        return string(null);
    }
    function addmethod(func)
    {
        __ASSERT__(func instanceof MethodStatement);
        self.funcont.addfunction(func);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function checkclass(string name)
    {
        return self.parent.checkclass(name);
    }
    function scopesearch(key, int flags)
    {
        return self.parent.scopesearch(key, flags);
    }
    function use_builtin(string name)
    {
        return self.owner.use_builtin(name);
    }
    function optimize()
    {
        optimize_array(self.items);
        return self;
    }
    function emit(var e)
    {
        self.classns.emitnamespace(e);
        emit_array(e, self.items);

        e.say('.sub Winxed_class_init :anon :load :init');

        e.say(INDENT, 'newclass $P0, ', self.getclasskey() );
        int n = 1;
        for (var base in self.bases) {
            base.annotate(e);
            string reg = "$P" + n++;
            e.print(INDENT, 'get_class ', reg, ', ');
            base.emit(e, self.parent);
            e.say();
            e.say(INDENT, 'addparent $P0, ', reg);
        }
        for (var member in self.members) {
            e.annotate(member);
            e.say(INDENT, "addattribute $P0, '", member, "'");
        }

        e.say('.end');
    }
}

class DeclareClassStatement : ClassBase
{
    function DeclareClassStatement(start, name, parent)
    {
        self.ClassBase(start, name, parent);
    }
    function optimize()
    {
        return self;
    }
    function emit(e)
    {
    }
}

function parseClass(start, tk, parent)
{
    var name = tk.get();
    var t = tk.get();
    var nskey = [];
    var ns;

    for ( ; t.isop('.'); t = tk.get()) {
        nskey.push(name);
        name = tk.get();
    }

    if (t.isop(';')) {
        for (ns in nskey)
            parent = parent.declarenamespace(ns, string(ns));
        parent.declareclass(new DeclareClassStatement(start, name, parent));
    }
    else {
        tk.unget(t);
        for (ns in nskey)
            parent = parent.childnamespace(start, ns, null);
        parent.addclass(new ClassStatement(start, name, parent, tk));
    }
}

//*********************************************
//        Namespace classes and functions
//*********************************************

$include_const "libpaths.pasm";
$include_const "iglobals.pasm";

function open_include(string filename, start)
{
    var interp = getinterp();

    // Search for the file in the parrot include paths
    var libpaths = interp[IGLOBALS_LIB_PATHS];
    var paths = libpaths[PARROT_LIB_PATH_INCLUDE];
    var file;
    for (string path in paths) {
        string filepath = path + filename;
        try {
            file = open(filepath, 'r');
            if (file != null && ! file.is_closed())
                break;
        }
        catch () {
        }
    }
    if (file == null || file.is_closed())
        SyntaxError('File not found', start);
    file.encoding("utf8");
    return file;
}

function include_parrot(var start, var tk, var ns)
{
    var tfile = tk.get();
    if (!tfile.isstring())
        Expected('literal string', tfile);
    ExpectOp(';', tk);

    string filename = tfile.rawstring();
    var file = open_include(filename, start);

    // Parse lines like this: .macro_const CONST_NAME value
    // Assume only integer values for a now
    const string MACRO_CONST = '.macro_const';
    for (string line = file.readline(); !file.eof(); line = file.readline()) {
        if (substr(line, 0, length(MACRO_CONST)) == MACRO_CONST) {
            int pos = length(MACRO_CONST);
            string c;
            while ((c = substr(line, pos, 1)) == " " || c == "\t")
                ++pos;
            int pos2 = pos;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                ++pos2;
            if (pos2 == pos)
                continue;
            string name = substr(line, pos, pos2 - pos);
            while ((c = substr(line, pos2, 1)) == " " || c == "\t")
                ++pos2;
            pos = pos2;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                ++pos2;
            if (pos2 == pos)
                continue;
            string value = substr(line, pos, pos2- pos);

            int ivalue;
            if (substr(value, 0, 2) == '0x' || substr(value, 0, 2) == '0X')
                ivalue = substr(value, 2).to_int(16);
            else
                ivalue = value;
            var cst = ns.createconst(name, REGint, VAR_is_extern);
            cst.setvalue(integerValue(ns,
                    new TokenInteger(start.file, start.line, name), ivalue));
        }
    }

    file.close();
}

//*********************************************

function include_winxed(var start, var tk, var ns)
{
    if (! (ns instanceof RootNamespace))
        SyntaxError("Must be used at root namespace level", start);
    var tfile = tk.get();
    if (!tfile.isstring())
        Expected('literal string', tfile);
    ExpectOp(';', tk);

    string filename = tfile.rawstring();
    var file = open_include(filename, start);

    var tkinc = new Tokenizer(file, filename, false);
    ns.parse(tkinc);

    file.close();
}

//*********************************************

function parsensUsing(start, tk, ns)
{
    var t = tk.get();
    if (t.iskeyword('namespace')) {
        usingNamespace(start, tk, ns);
        ExpectOp(';', tk);
        return;
    }
    if (! t.iskeyword('extern')) {
        tk.unget(t);
        var key = parseDotted(tk);
        int nelems = elements(key);
        if (nelems < 1)
            SyntaxError('Unsupported at namespace level', t);
        ExpectOp(';', tk);
        ns.use(key);
        return;
    }
    t = tk.get();
    switch {
      case t.isstring():
        tk.warn("using extern 'file'; is deprecated, use $loadlib instead.",
                t);
        string reqlib = t;
        ns.addlib(reqlib);
        ExpectOp(';', tk);
        break;
      case t.isidentifier():
        tk.unget(t);
        var module = parseDotted(tk);
        t = tk.get();
        if (! t.isop(';')) {
            tk.unget(t);
            var names = parseList(tk, null, parseIdentifier, ';');
            ns.addextern(module, names);
        }
        string reqmodule = '"' + join('/', module) + '.pbc"';
        ns.addload(reqmodule);
        break;
      default:
        Expected('string literal or identifier', t);
    }
}

//*********************************************

class External
{
    var module;
    var names;
    function External(module, names)
    {
        self.module = module;
        self.names = names;
    }
    function emit(e)
    {
        // Import external symbols in the current namespace

        e.say(<<:
.sub 'importextern' :anon :load :init
    .local pmc ex, curns, srcns, symbols
    ex = new ['Exporter']
    curns = get_namespace
    symbols = new ['ResizableStringArray']
:>>
        );

        e.emitget_root_namespace("srcns",
                "['parrot'; '" + string(join("'; '", self.module)) + "']");

        for_each(self.names,
                function (string name)
                {
                    e.say(INDENT + "push symbols, '", name, "'");
                }
        );
        e.say(<<:
    ex.'destination'(curns)
    ex.'import'(srcns :named('source'), curns :named('destination'), symbols :named('globals'))
.end
:>>
        );
    }
}

class NamespacePath
{
    var hll;
    var path;

    function NamespacePath(string name[optional], int is_hll[optional])
    {
        string path[];
        if (is_hll)
            self.hll = name;
        else {
            if (name != null)
                push(path, name);
        }
        self.path = path;
    }
    function createchild(string name)
    {
        var child = new NamespacePath;
        child.hll = self.hll;
        var path = clone(self.path);
        push(path, name);
        child.path = path;
        return child;
    }
    function samehllas(fromns)
    {
        var fromkey = fromns.getpath();
        var hll = self.hll;
        var fromhll = fromkey != null ? fromkey.hll : null;
        if (hll == null)
            return fromhll == null;
        else
            return fromhll == null ? false : hll == fromhll;
    }
    function fullname()
    {
        string name = join('.', self.path);
        if (self.hll != null)
            return string(self.hll) + '.' + name;
        else
            return name;
    }
    function getparrotkey()
    {
        var path = self.path;
        string r;
        if (elements(path) != 0)
            r = "[ '" + string(join("'; '", path)) + "' ]";
        return r;
    }
    function getparrotrootkey()
    {
        var path = self.path;
        var hll = self.hll;
        string r = "[ '";
        if (hll != null) {
            // HLL namespace is stored in the root namespace
            // using its name in lower case as key.
            r += downcase(hll);
        }
        else
            r += "parrot";
        r += "'";
        if (elements(path) != 0)
            r += "; '" + string(join("'; '", path)) + "'";
        r += " ]";
        return r;
    }
    function emitnamespace(e)
    {
        var path = self.path;
        e.print(".namespace [ ");
        if (elements(path) != 0)
            e.print("'", join("'; '", path), "' ");
        e.say("]");
    }
    function emit_new(e, fromns, string regnew, string reginit[optional])
    {
        if (self.samehllas(fromns))
            e.print(sformat(INDENT + "new %0, %1",
                    regnew, self.getparrotkey()));
        else
            e.print(sformat(INDENT + "root_new %0, %1",
                    regnew, self.getparrotrootkey()));
        if (reginit != null && reginit != '')
            e.print(reginit);
        e.say();
    }
    function emit_get_namespace(e, fromns, string result)
    {
        if (self.samehllas(fromns))
            e.emitget_hll_namespace(result, self.getparrotkey());
        else
            e.emitget_root_namespace(result, self.getparrotrootkey());
    }
    function emit_get_class(e, fromns, string result)
    {
        if (self.samehllas(fromns))
            e.say(sformat(INDENT + "get_class %0, %1",
                    result, self.getparrotkey()));
        else {
            // There is no get_root_class. This will work for a now:
            // Get the namespace as root global object, and then get
            // its associated class.
            var hll = self.hll;
            var path = clone(self.path);
            string name = path.pop();
            string shll = hll != null ? downcase(hll) : 'parrot';
            if (elements(path) != 0)
                e.say(sformat(
                        INDENT + "get_root_global %0, ['%1'; '%2'], '%3'",
                        result, shll, join("'; '", path), name));
            else
                e.say(sformat(
                        INDENT + "get_root_global %0, ['%1'], '%2'",
                        result, shll, name));
            e.say(sformat(INDENT + "get_class %0, %0", result));
        }
    }
    function emit_get_global(e, fromns, string result, string name)
    {
        if (self.samehllas(fromns))
            e.emitget_hll_global(result, name, self.getparrotkey());
        else
            e.emitget_root_global(result, name, self.getparrotrootkey());
    }
}

//*********************************************
//            NamespaceBase
//*********************************************

class NamespaceBase : VarContainer
{
    var nspath;
    var externals;
    var namespaces;
    var classes;
    var funcont;
    var items;
    var owner;

    function NamespaceBase(nspath, previous)
    {
        self.VarContainer();
        self.nspath = nspath;
        if (previous == null) {
            self.namespaces = [];
            self.usednamespaces = [];
            self.classes = [];
            self.funcont = new FunctionContainer();
            createPredefConstString(self, '__NAMESPACE__', nspath.fullname());
        }
        else {
            self.locals = previous.locals;
            self.namespaces = previous.namespaces;
            self.usednamespaces = previous.usednamespaces;
            self.classes = previous.classes;
            self.funcont = previous.funcont;
        }
        self.items = [];
    }
    function getlabel(string name)
    {
        return string(null);
    }
    function addfunction(newfunc)
    {
        self.funcont.addfunction(newfunc);
    }
    function fixnamespaces()
    {
        for_each(self.namespaces, bindmethod("fixnamespaces"));
        var usens = method_fun(self, "usenamespace");
        for_each(self.usednamespaces,
                function (ns) { for_each(ns.usednamespaces, usens); } );
    }
    function getpath()
    {
        return self.nspath;
    }
    function usenamespace(nsused)
    {
        if (nsused === self)
            return;
        var usednamespaces = self.usednamespaces;
        if (find_same(usednamespaces, nsused) != null)
            return;
        push(usednamespaces, nsused);
    }
    function use(key)
    {
        var sym = self.scopesearch(key, 0);
        if (sym != null) {
            if (sym instanceof FunctionStatement)
                self.addfunction(sym);
        }
        else {
            string name = key.pop();
            var ns = self.scopesearch(key, SEARCH_NAMESPACE);
            if (ns != null) {
                sym = ns.getvar(name);
                if (sym != null)
                    self.createvarused(name, sym);
            }
        }
    }
    function getusedns(string name)
    {
        return find_if(self.usednamespaces,
            function (ns) { return ns.name == name; } );
    }
    function getlocalns(string name)
    {
        var ns = find_if(self.namespaces,
            function (ns) { return ns.name == name; } );
        if (ns != null)
            return ns;
        return self.getusedns(name);
    }

    function addextern(module, names)
    {
        var ext = new External(module, names);
        var externals = self.externals;
        if (externals == null)
            self.externals = externals = [ ext ];
        else
            push(externals, ext);
    }

    function checkclass_base(string name)
    {
        var cl = find_if(self.classes,
                function (cl) { return cl.name == name; } );
        if (cl != null)
            return cl;
        for (var ns in self.usednamespaces)
            if ((cl = ns.checkclass_base(name)) != null)
                return cl;
        return null;
    }
    function findsymbolbyname(string name)
    {
        var sym = self.checkclass_base(name);
        if (sym != null)
            return sym;
        var funcont = self.funcont;
        if ((sym = funcont.find(name)) != null)
            return sym;
        if ((sym = self.getlocalvar(name)) != null)
            return sym;
        return null;
    }
    function scopesearchlocal(key, int flags, int offset)
    {
        // Look for a symbol by its key in this namespace
        // and its childs.
        int keylen = elements(key);
        string name;
        var sym;
        var ns;
        switch (keylen - offset) {
          case 0:
            break;
          case 1:
            name = key[keylen - 1];
            switch (flags) {
              case SEARCH_NAMESPACE:
                return self.getlocalns(name);
              case SEARCH_CLASS:
                return self.checkclass_base(name);
              default:
                // The key contains the name, look by name
                if ((sym = self.findsymbolbyname(name)) != null)
                    return sym;
                for (ns in self.usednamespaces)
                    if ((sym = ns.findsymbolbyname(name)) != null)
                        return sym;
            }
            break;
          default:
            // The key is multi: look for a child namespace named
            // as the first key item, and look into it with the
            // remaining.
            name = key[offset];
            ns = self.getlocalns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
            ns = self.getusedns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
        }
        return null;
    }
    function declarenamespace(var start, string name)
    {
        var child = new NamespaceStatement(self, start, null, name, null);
        push(self.namespaces, child);
        return child;
    }
    function childnamespace(var start, string name, var modifier)
    {
        var existns = self.getlocalns(name);
        var child = new NamespaceStatement(self, start, existns, name, modifier);
        push(self.namespaces, child);
        push(self.items, child);
        return child;
    }
    function declareclass(statement)
    {
        push(self.classes, statement);
    }
    function addclass(statement)
    {
        push(self.classes, statement);
        push(self.items, statement);
    }
    function parsenamespace(start, tk)
    {
        var t = tk.get();
        string name = t;
        t = tk.get();

        var parent = self;
        for ( ; t.isop('.'); t = tk.get()) {
            parent = parent.childnamespace(start, name, null);
            name = tk.get();
        }

        var modifier;
        if (t.isop('[')) {
            modifier = new ModifierList(tk, self);
            t = tk.get();
        }

        RequireOp('{', t);
        var child = parent.childnamespace(start, name, modifier);
        child.parse(tk);
    }
    function parseextern(tk)
    {
        //Syntax: extern function_name;

        var t = tk.get();
        if (!t.iskeyword('function'))
            SyntaxError('Unsupported extern', t);
        t = tk.get();
        RequireIdentifier(t);
        ExpectOp(';', tk);
        var funex = new FunctionExtern(t, self);
        self.addfunction(funex);
    }
    function parse(tk)
    {
        var items = self.items;
        var t;
        for (t = tk.get(); !(t.iseof() || t.isop('}')); t = tk.get())
        {
            switch (t.checkkeyword()) {
              case 'namespace':
                self.parsenamespace(t, tk);
                break;
              case 'const':
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              case 'function':
                var f = new FunctionStatement(t, tk, self);
                self.addfunction(f);
                push(items, f);
                break;
              case 'inline':
                var inl = new InlineStatement(t, tk, self);
                self.addfunction(inl);
                break;
              case 'class':
                parseClass(t, tk, self);
                break;
              case 'extern':
                self.parseextern(tk);
                break;
              case 'using':
                parsensUsing(t, tk, self);
                break;
              case '$include_const':
                include_parrot(t, tk, self);
                break;
              case '$include':
                include_winxed(t, tk, self);
                break;
              case '$load':
                t = tk.get();
                if (! t.isstring())
                    Expected('string literal', t);
                ExpectOp(';', tk);
                self.addload((new StringLiteral(self, t)).getPirString());
                break;
              case '$loadlib':
                t = tk.get();
                if (! t.isstring())
                    Expected('string literal', t);
                ExpectOp(';', tk);
                self.addlib((new StringLiteral(self, t)).getPirString());
                break;
              default:
                Unexpected("token", t);
            }
        }
        if (t.iseof())
            self.unclosed_ns();
        else
            self.close_ns(t);
    }
    function optimize_base()
    {
        optimize_array(self.items);
    }
    function emit_base(var e)
    {
        var path = self.getpath();

        int activate = true;

        var externals = self.externals;
        if (externals != null) {
            path.emitnamespace(e);
            activate = false;
            emit_array(e, externals);
        }

        for (var item in self.items) {
            if ((item instanceof NamespaceStatement) ||
                    (item instanceof ClassStatement))
                activate = true;
            else
                if (activate) {
                    path.emitnamespace(e);
                    activate = false;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            NamespaceStatement
//*********************************************

class NamespaceStatement : NamespaceBase
{
    var parent;
    var start;
    var name;
    var modifier;
    var hll;

    function NamespaceStatement(var parent, var start, var previous,
            string name, var modifier)
    {
        self.modifier = modifier;
        int is_hll = false;
        if (modifier != null) {
            if (modifier.pick('HLL') != null) {
                self.hll = name;
                is_hll = true;
            }
        }
        var nspath = is_hll ?
            new NamespacePath(name, true) :
            parent.getpath().createchild(name);
        self.NamespaceBase(nspath, previous);

        self.parent = parent;
        self.start = start;
        self.owner = parent;
        self.name = name;
    }
    function dowarnings()
    {
        return self.parent.dowarnings();
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function addlib(string libname)
    {
        self.parent.addlib(libname);
    }
    function addload(string loadname)
    {
        self.parent.addload(loadname);
    }
    function checkclass(string name)
    {
        var cl = self.checkclass_base(name);
        if (cl == null)
            return self.parent.checkclass(name);
        return cl;
    }
    function scopesearch(key, int flags, int offset[optional])
    {
        var sym = self.scopesearchlocal(key, flags, offset);
        if (sym == null && offset <= 0)
            return self.parent.scopesearch(key, flags, offset);
        return sym;
    }
    function unclosed_ns()
    {
       SyntaxError('unclosed namespace', self.start);
    }
    function close_ns(t)
    {
        // Do nothing
    }
    function optimize()
    {
        var modifier = self.modifier;
        if (modifier != null)
            self.modifier = modifier.optimize();
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var hll = self.hll;
        if (hll !=  null)
            e.say(sformat(".HLL '%0'", hll));

        self.emit_base(e);

        if (hll !=  null)
            e.say(".HLL 'parrot'");
    }
}

//*********************************************
//            RootNamespace
//*********************************************

class RootNamespace : NamespaceBase
{
    var unit;
    var bultins_used;
    var libs;
    var loads;
    var subidgen;

    function RootNamespace(unit)
    {
        self.NamespaceBase(new NamespacePath(), null);
        self.unit = unit;
        self.bultins_used = {};
        self.subidgen = 0;
    }
    function use_builtin(string name)
    {
        var bultins_used = self.bultins_used;
        bultins_used[name] = true;
    }

    function generatesubid()
    {
        int idgen = ++self.subidgen;
        return 'WSubId_' + string(idgen);
    }

    function addlib(string libname)
    {
        var libs = self.libs;
        if (libs == null)
            self.libs = libs = {};
        libs[libname] = 1;
    }
    function addload(string name)
    {
        var loads = self.loads;
        if (loads == null)
            self.loads = loads = {};
        loads[name] = 1;
    }
    function checkclass(string name)
    {
        return self.checkclass_base(name);
    }
    function scopesearch(key, int flags, int offset[optional])
    {
        return self.scopesearchlocal(key, flags, offset);
    }
    function unclosed_ns()
    {
        // Do nothing
    }
    function close_ns(t)
    {
         SyntaxError('Cannot close root namespace', t);
    }
    function dowarnings()
    {
        return self.unit.dowarnings();
    }
    function optimize()
    {
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var bultins_used = self.bultins_used;

        // chomp uses a library function, load the libray if chomp is used
        if (bultins_used['chomp'] != null)
            self.addload('"String/Utils.pbc"');

        // Load trans opcodes if some of its corresponding builtins are used
        for (string trfun in split(" ",
                    "acos asin atan cos exp ln sin tan pow sinh cosh tanh"))
            if (bultins_used[trfun] != null) {
                self.addlib("'trans_ops'");
                break;
            }

        var libs = self.libs;
        if (libs != null)
            e.say(join("\n", transform(libs, [], addprefix(".loadlib "))));

        var loads = self.loads;
        if (loads != null) {
            e.say(sformat(
<<:
.sub initial_load_bytecode :anon :load :init
%0
.end
:>>
                , join("\n", transform(loads, [],
                       addprefix(INDENT + 'load_bytecode ')))));
        }
        if (libs != null || loads != null)
            e.comment('end libs');

        self.emit_base(e);
    }
    function emitinclude(var e)
    {
        var locals = self.locals;
        for (string localname in locals) {
            var data = locals[localname];
            if (!(data instanceof VarData) ||
                    data.gettype() != REGint ||
                    data.getflags() & VAR_is_extern)
                continue;
            var value = data.getvalue();
            e.say('.macro_const ', localname, ' ', value.getIntegerValue());
        }
    }
}

//*********************************************
//           Compiler classes
//*********************************************

class Builtin {
    var name;
    var variants;
    function Builtin(string name, variant)
    {
        self.name = name;
        self.variants = [ variant ];
    }
    function getname() { return string(self.name); }
    function addvariant(variant)
    {
        push(self.variants, variant);
    }
}

const string EVAL_NAME = '__eval__';

class BuiltinBuilder
{
    var entries;
    function BuiltinBuilder()
    {
        self.entries = {};
    }
    function add(builtin)
    {
        var entries = self.entries;
        string name = builtin.name;
        if (entries[name] != null)
            entries[name].addvariant(builtin);
        else
            entries[name] = new Builtin(name, builtin);
    }
    function put(ns)
    {
        var entries = self.entries;
        for (string s in entries)
            ns.addfunction(entries[s]);
    }
}

class WinxedCompileUnit
{
    var rootns;
    var warnings;

    function WinxedCompileUnit(int nowarn, int debug)
    {
        self.warnings = ! nowarn;
        var rootns = new RootNamespace(self);

        // Store predefined constants in the root namespace.

        createPredefConstInt(rootns, 'false', 0);
        createPredefConstInt(rootns, 'true', 1);

        // Tricky way of setting __STAGE__: stage 1 is built with
        // stage 0 and stage 2 is built with stage 1. Increment
        // the current stage and we are done.
        createPredefConstString(rootns, '__STAGE__',
                string(int(__STAGE__) + 1));

        createPredefConstInt(rootns, '__DEBUG__', debug);

        // Propagate value for exception type.
        createPredefConstInt(rootns, '__WINXED_ERROR__', __WINXED_ERROR__);

        // Builtins
        var builtins_ns = rootns.childnamespace(new TokenEof('__builtins__'),
                "Winxed_Builtins", null);
        var builder = new BuiltinBuilder();
        getbuiltins(builder);
        builder.put(builtins_ns);

        rootns.usenamespace(builtins_ns);

        self.rootns = rootns;
    }
    function dowarnings()
    {
        return int(self.warnings);
    }
    function parse(tk)
    {
        self.rootns.parse(tk);
        self.rootns.fixnamespaces();
    }
    function optimize()
    {
        self.rootns = self.rootns.optimize();
    }
    function emit(var e)
    {
        e.comment('THIS IS A GENERATED FILE! DO NOT EDIT!');
        e.comment('Begin generated code');
        e.say('');

        self.rootns.emit(e);

        e.comment('End generated code');
    }
    function emitinclude(var e)
    {
        e.comment('DO NOT EDIT THIS FILE');
        e.comment('Generated automatically from Winxed sources');

        self.rootns.emitinclude(e);

        e.comment('End');
    }
}

//*********************************************

class WinxedHLL
{
    function version()
    {
        int version[3] = [ VERSION_MAJOR, VERSION_MINOR, VERSION_BUILD ];
        return version;
    }
    function version_string()
    {
        return "Winxed " + string(join(".", self.version()));
    }
    function __private_compile_tail(winxed, target, output,
            string filename,
            int debug, int noan, int nowarn)
    {
        if (target == 'parse')
            return winxed;
        var handleout;
        if (output == null) {
            handleout  = new ['StringHandle'];
            handleout.open(EVAL_NAME, 'w');
        }
        else
            handleout = output;
        var emit = new Emit(handleout, nowarn);
        if (debug)
            emit.setDebug();
        if (noan)
            emit.disable_annotations();
        winxed.emit(emit);
        emit.close();
        if (output != null)
            return output;
        else {
            handleout.close();
            string pircode = handleout.read(0);
            var object;
            switch (target) {
              case 'pir':
                object = new ['String'];
                object =: pircode;
                break;
              case 'pbc':
              case '':
                var pircomp = compreg('PIR');
                object = pircomp.compile(pircode);
                break;
              default:
                die('Invalid target: ' + string(target));
            }
            return object;
        }
    }
    function __private_geninclude(winxed, output)
    {
        var handleout;
        if (output == null) {
            handleout = new ['StringHandle'];
            handleout.open(EVAL_NAME, 'w');
        }
        else
            handleout = output;
        var emit = new Emit(handleout, true);
        winxed.emitinclude(emit);
        emit.close();
        if (output != null)
            return output;
        else {
            handleout.close();
            return handleout.read(0);
        }
    }
    function compile(string code,
            string target[named,optional],
            output[named,optional],
            int debug[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        if (target == null)
            target = '';
        var handlein = new ['StringHandle'];
        handlein.open(EVAL_NAME, 'w');
        handlein.puts(code);
        handlein.close();
        handlein.open(EVAL_NAME, 'r');
        var tk = new Tokenizer(handlein, EVAL_NAME, nowarn);
        var winxed = new WinxedCompileUnit(nowarn, debug);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        if (target == 'include')
            return self.__private_geninclude(winxed, output);
        else
            return self.__private_compile_tail(winxed, target, output,
                    EVAL_NAME, debug, noan, nowarn);
    }
    function compile_from_file(string filename,
            string target[named,optional],
            output[named,optional],
            int debug[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        // output is supposed to be used with pir target for a now,.
        if (target == null)
            target = '';
        var handlein = new ['FileHandle'];
        handlein.open(filename, 'r');
        handlein.encoding('utf8');
        var tk = new Tokenizer(handlein, filename, nowarn);
        var winxed = new WinxedCompileUnit(nowarn, debug);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        if (target == 'include')
            return self.__private_geninclude(winxed, output);
        else
            return self.__private_compile_tail(winxed, target, output,
                    filename, debug, noan, nowarn);
    }
}

//*********************************************
//            Initialization
//*********************************************

function initializer [init,load]()
{
    var comp = new WinxedHLL;
    compreg('winxed', comp);
}

//*********************************************

} // namespace Compiler
} // namespace Winxed

// End
