#! winxed

/***********************************************************************
                   Winxed stage 2 compiler
***********************************************************************/

namespace Winxed
{
namespace Compiler
{

const int VERSION_MAJOR = 1;
const int VERSION_MINOR = 10;
const int VERSION_BUILD = -1;

function getVersion [anon] ()
{
    int version[3] = [ VERSION_MAJOR, VERSION_MINOR, VERSION_BUILD ];
    return version;
}


function getVersionString [anon] ()
{
    return "Winxed " + string(join(".", getVersion()));
}

//*********************************************
//          Character test functions
//*********************************************

inline isspace(string c) return int
{
    return c == " " || c == "\n" || c == "\t" || c == "\r";
}

inline isdigit(string c) return int
{
    return indexof("0123456789", c) > -1;
}

inline hexdigit(string c) return int
{
    int i = indexof("0123456789abcdef0123456789ABCDEF", c);
    if (i >= 0) i = i % 16;
    return i;
}

inline isidentstart(string c) return int
{
    return indexof(
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "_",
        c) > -1;
}

inline isident(string c) return int
{
    return indexof(
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "_$" +
        "0123456789",
        c) > -1;
}

function sformat(string format, var args[slurpy])
{
    var builder = new ["StringBuilder"];
    builder.append_format(format, args:[flat]);
    return string(builder);
}

inline quoted(string str) return string
{
    return "\"" + str + "\"";
}

// Algorithms

inline for_each(var src, var func)
{
    for (var item in src)
        func(item);
}

inline transform(var src, var dest, var func) return var
{
    for (var item in src)
        push(dest, func(item));
    return dest;
}

inline find_same(var src, var value) return var
{
    for (var item in src)
        if (item === value)
            return item;
    return null;
}

inline find_if(var src, var fun) return var
{
    for (var item in src)
        if (fun(item))
            return item;
    return null;
}

function bindfirst(var fun, var argfirst[slurpy])
{
    return function(var arglast[slurpy])
    {
        return fun(argfirst:[flat], arglast:[flat]);
    };
}

function bindlast(var fun, var arglast[slurpy])
{
    return function(var argfirst[slurpy])
    {
        return fun(argfirst:[flat], arglast:[flat]);
    };
}

function bindmethod(string name)
{
    return function(var obj, var args[slurpy])
    {
        return obj.*name(args:[flat]);
    };
}

function method_fun(var obj, string methodname)
{
    var method = find_method(obj, methodname);
    return function (var args[slurpy])
    {
        return obj.*method(args:[flat]);
    };
}

function addprefix(string prefix)
{
    return function (string str) { return prefix + str; };
}

inline clone_array(var src, var owner) return var
{
    return transform(src, [], bindlast(bindmethod("clone"), owner));
}

//*********************************************
//        Error handling exceptions
//*********************************************

const string
    ERR_INTERNAL = "internal",
    ERR_TOKEN    = "tokenizer",
    ERR_PARSER   = "parser";

class WinxedCompilerError
{
    // Payload for compiler exceptions.
    var type;     // internal, tokenizer, parser
    var filename;
    var line;
    var message;

    function WinxedCompilerError(
            string type,
            string message,
            string filename[optional],
            int line[optional])
    {
        self.type = type;
        self.message = message;
        self.filename = filename;
        self.line = line;
    }
}

function Warn(string msg, var pos [optional])
{
    var stderr = getstderr();
    stderr.print("WARNING: ");
    stderr.print(msg);
    if (pos != null) {
        stderr.print(" near ");
        stderr.print(pos.show());
    }
    stderr.print("\n");
}

function InternalError(string msg, var pos [optional], int has_pos [opt_flag])
{
    if (has_pos) {
        pos = pos.getstart();
        string desc = pos.show();
        msg = msg + " near " + desc;
    }
    var payload = has_pos ?
        new WinxedCompilerError(ERR_INTERNAL, msg,
                pos.filename(), pos.linenum()) :
        new WinxedCompilerError(ERR_INTERNAL, msg);
    throw Error(msg, 2, __WINXED_ERROR__, payload);
}

function SyntaxError(string msg, var pos)
{
    if (pos != null)
        pos = pos.getstart();
    int line = pos != null ? pos.linenum() : -1;
    string file = pos != null ? pos.filename() : "UNKNOWN";
    string desc = " near " + string(pos.viewable());
    throw Error(msg + " in " + file + " line " + string(line) + desc,
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_PARSER, msg + desc,
                   file, line));
}

function NoLeftSide(var pos)
{
    SyntaxError("Not a left-side expression", pos);
}

function Expected(string msg, var t)
{
    SyntaxError("Expected " + msg, t);
}

function Unexpected(string msg, var t)
{
    SyntaxError("Unexpected " + msg, t);
}

function ExpectedIdentifier(var t)
{
    SyntaxError("Expected identifier", t);
}

function ExpectedOp(string msg, var t)
{
    SyntaxError("Expected '" + msg + "'", t);
}

function RequireOp(string name, var t)
{
    if (! t.isop(name))
        ExpectedOp(name, t);
}

function RequireKeyword(string name, var t)
{
    if (! t.iskeyword(name))
        ExpectedOp(name, t);
}

function RequireIdentifier(var t)
{
    if (! t.isidentifier())
        ExpectedIdentifier(t);
}

function ExpectOp(string name, var tk)
{
    var t = tk.get();
    RequireOp(name, t);
}

function ExpectKeyword(string name, var tk)
{
    var t = tk.get();
    RequireKeyword(name, t);
}

function UndefinedVariable(string name, var t)
{
    SyntaxError("Variable '" + name + "' is not defined", t);
}

function Redeclared(var t)
{
     SyntaxError("Redeclared '" + string(t.getidentifier()) + "'", t);
}

//*********************************************
//                Token
//*********************************************

class Token
{
    var file;
    var line;
    function Token(string file, int line)
    {
        self.file = file;
        self.line = line;
    }
    function getstart() { return self; }

    function iseof()          { return false; }
    function iscomment()      { return false; }
    function isidentifier()   { return false; }
    function isint()          { return false; }
    function isfloat()        { return false; }
    function isstring()       { return false; }
    function issinglequoted() { return false; }

    function getintvalue()
    {
        InternalError("Not a literal int", self);
    }
    function rawstring()
    {
        InternalError("Not a literal string", self);
    }
    function getidentifier()
    {
        ExpectedIdentifier(self);
    }
    function iskeyword(string name) { return false; }
    function checkkeyword()         { return false; }
    function isop(string name)      { return false; }
    function checkop() { return ""; }
    function viewable() { return "(unknown)"; }
    function filename() { return self.file; }
    function linenum() { return self.line; }
    function show()
    {
        string r = self.viewable();
        return r + " at " + string(self.file) + " line " + string(self.line);
    }
}

class TokenEof : Token
{
    function TokenEof(string file)
    {
        self.Token(file, 0);
    }
    function iseof() { return true; }
    function viewable() { return "(End of file)"; }
}

class TokenWithVal : Token
{
    var str;
    function TokenWithVal(string file, int line, string str)
    {
        self.Token(file, line);
        self.str = str;
    }
    function get_string[vtable]() { return self.str; }
    function viewable()
    {
        return self.str;
    }
}

class TokenComment : Token
{
    function TokenComment(string file, int line)
    {
        self.Token(file, line);
    }
    function iscomment() { return true; }
    function viewable() { return "(comment)"; }
}

class TokenOp : TokenWithVal
{
    function TokenOp(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isop(string name)
    {
        return self.str == name;
    }
    function checkop()
    {
        return string(self.str);
    }
}

class TokenIdentifier : TokenWithVal
{
    function TokenIdentifier(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isidentifier() { return true; }
    function getidentifier()
    {
        return self.str;
    }
    function checkkeyword()
    {
        return string(self.str);
    }
    function iskeyword(string name)
    {
        return self.str == name;
    }
}

class TokenString : TokenWithVal
{
    function isstring() { return true; }
    function rawstring()
    {
        return self.str;
    }
}

class TokenQuoted : TokenString
{
    function TokenQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function get_string[vtable]()
    {
        return quoted(self.str);
    }
    function viewable()
    {
        return quoted(self.str);
    }
    function getasquoted()
    {
        return self.str;
    }
    function getPirString()
    {
        string str = self.str;
        string strunesc;
        try {
            strunesc = unescape(str);
        }
        catch () {
            SyntaxError("Invalid escape sequence in literal string", self);
        }
        int need_encoding = false;
        for (int code in strunesc) {
            if (code > 127) {
                need_encoding = true;
                break;
            }
        }
        str = quoted(escape(strunesc));
        string encoding = need_encoding ? "utf8:" : "";
        return encoding + str;
    }
}

class TokenSingleQuoted : TokenString
{
    function TokenSingleQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function issinglequoted() { return true; }
    function get_string[vtable]()
    {
        return "'" + string(self.str) + "'";
    }
    function viewable()
    {
        return "'" + string(self.str) + "'";
    }
    function getasquoted()
    {
        string s = "";
        for (string c in self.str) {
            switch (c) {
              case "\"":
              case "\\":
              case "'":
                c = "\\" + c;
                break;
            }
            s += c;
        }
        return s;
    }
    function getPirString()
    {
        string str = self.str;
        string quote = "'";
        int need_escape = false;
        for (int code in str) {
            if (code < 32 || code > 127) {
                need_escape = true;
                break;
            }
        }
        int need_encoding = false;
        if (need_escape) {
            quote = "\"";
            string result = "";
            for (string c in str) {
                if (c == "\\")
                    result += "\\\\";
                else
                {
                    int n = ord(c);
                    if (n < 32 || n > 127) {
                        if (n > 127)
                            need_encoding = true;
                        string h = n.get_as_base(16);
                        result += "\\x{" + h + "}";
                    }
                    else
                        result += c;
                }
            }
            str = result;
        }
        str = quote + str + quote;
        if (need_encoding)
            str = "utf8:" + str;
        return str;
    }
}

class TokenInteger : TokenWithVal
{
    function TokenInteger(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isint() { return true; }
    function getintvalue()
    {
        return int(self.str);
    }
}

class TokenFloat : TokenWithVal
{
    function TokenFloat(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isfloat() { return true; }
    function getfloatvalue()
    {
        return float(self.str);
    }
}


//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function TokenError(string msg, var tk, int line)
{
    throw Error(msg + " in " + string(tk.filename) + " line " + string(line),
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_TOKEN, msg, tk.filename, line));
}

function UnterminatedString(var tk, int line)
{
    TokenError("Unterminated string", tk, line);
}

function UnterminatedHeredoc(var tk, int line)
{
    TokenError("Unterminated heredoc", tk, line);
}

function UnclosedComment(var tk, int line)
{
    TokenError("Unclosed comment", tk, line);
}

function getquoted(var tk, string start, int line)
{
    string s = "";
    string c;
    for (c = tk.getchar(); c != "\""; c = tk.getchar()) {
        switch (c) {
          case "":
          case "\n":
            UnterminatedString(tk, line);
          case "\\":
            // Quick fix for escaped double quotes.
            string c2 = tk.getchar();
            if (c2 == "" || c2 == "\n")
                UnterminatedString(tk, line);
            s += c + c2;
            break;
          default:
            s += c;
        }
    }
    return new TokenQuoted(tk.filename, line, s);
}

function getsinglequoted(var tk, string start, int line)
{
    string s = "";
    string c;
    for (c = tk.getchar(); c != "'"; c = tk.getchar()) {
        if (c == "" || c == "\n")
            UnterminatedString(tk, line);
        s += c;
    }
    return new TokenSingleQuoted(tk.filename, line, s);
}

function getheredoc(var tk, string start, int linenum)
{
    string mark = "";
    string c;
    for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
        switch (c) {
          case "":
            UnterminatedHeredoc(tk, linenum);
          case "\r":
            break; // Quick fix for windows line-ending text files
          case "\"":
          case "\\":
            // Encode the mark the same way as the heredoc content
            // to simplify its detection
            mark += "\\" + c;
            break;
          default:
            mark += c;
        }
    }
    mark = mark + ":>>";

    string content = "";
    string line;
    do {
        line = "";
        for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
            switch (c) {
              case "":
                UnterminatedHeredoc(tk, linenum);
              case "\r":
                break; // Quick fix for windows line-ending text files
              case "\"":
              case "\\":
                line += "\\" + c;
                break;
              default:
                line += c;
            }
        }
        if (line != mark)
            content += line + "\\n";
    } while (line != mark);
    return new TokenQuoted(tk.filename, linenum, content);
}

function getident(var tk, string start, int line)
{
    string s = start;
    string c;
    for (c = tk.getchar(); isident(c); c = tk.getchar())
        s += c;
    tk.ungetchar(c);
    return new TokenIdentifier(tk.filename, line, s);
}

function getnumber(var tk, string start, int line)
{
    var filename = tk.filename;
    string c = tk.getchar();
    if (start == "0" && (c == "x" || c == "X")) {
        int hexval = 0, h;
        for (c = tk.getchar(); (h = hexdigit(c)) >= 0; c = tk.getchar())
            hexval = hexval * 16 + h;
        tk.ungetchar(c);
        return new TokenInteger(filename, line, hexval);
    }
    string s = start;
    for ( ; isdigit(c); c = tk.getchar())
        s += c;
    int isfloat = false;
    if (c == ".") {
        isfloat = true;
        do {
            s += c;
            c = tk.getchar();
        } while (isdigit(c));
    }
    if (c == "e" || c == "E") {
        isfloat = true;
        s += "E";
        if ((c = tk.getchar()) == "+" || c == "-") {
            s += c;
            c = tk.getchar();
        }
        for ( ; isdigit(c); c = tk.getchar())
            s += c;
    }
    tk.ungetchar(c);
    if (isfloat)
        return new TokenFloat(filename, line, s);
    else
        return new TokenInteger(filename, line, s);
}

function getlinecomment(var tk, string start, int line)
{
    string c;
    do
        c = tk.getchar();
    while (c != "" && c != "\n");
    return new TokenComment(tk.filename, line);
}

function getcomment(var tk, string start, int line)
{
    string c = tk.getchar();
    do {
        while (c != "" && c != "*")
            c = tk.getchar();
        if (c == "")
            UnclosedComment(tk, line);
        c = tk.getchar();
        if (c == "")
            UnclosedComment(tk, line);
    } while (c != "/");
    return new TokenComment(tk.filename, line);
}

function getop(var tk, string start, int line)
{
    string s = start;
    return new TokenOp(tk.filename, line, s);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var warnings;
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function Tokenizer(var handle, string filename, int nowarn)
    {
        self.warnings = new ["Boolean"](! nowarn);
        self.h = handle;
        self.pending = "";
        self.stacked = [];
        self.filename = filename;
        self.line = 1;
        var select = {
            "$": { "": getident, "{": getop },
            "\"": getquoted,
            "'": getsinglequoted,
            "=": {
                "=": { "": getop, "=": getop },
                ":": getop
            },
            "+": { "+": getop, "=": getop },
            "-": { "-": getop, "=": getop },
            "*": { "=": getop },
            "|": { "|": getop },
            "&": { "&": getop },
            "<": {
                "<": { "": getop, ":": getheredoc },
                "=": getop
            },
            ">": {
                ">": { "": getop, ">": getop },
                "=": getop
            },
            "!": {
                "=": { "": getop, "=": getop }
            },
            "%": { "%": getop, "=": getop },
            "/": { "=": getop, "/": getlinecomment, "*": getcomment },
            "#": getlinecomment
        };
        self.select = select;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function getchar()
    {
        var pending = self.pending;
        string c = pending;
        if (c != "")
            pending =: "";
        else {
            var h = self.h;
            c = h.read(1);
            if (c == "\n")
                ++self.line;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending =: c;
    }
    function get_token()
    {
        if (self.stacked)
            return self.stacked.pop();

        string c = self.getchar();
        while (isspace(c))
                c = self.getchar();
        int line = self.line;
        if (c == "")
            return new TokenEof(self.filename);
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);

        string op = c;
        var select = self.select;
        var current = select[c];

        while (current != null && (current instanceof "Hash")) {
            c = self.getchar();
            select = current;
            current = select[c];
            if (current == null) {
                self.ungetchar(c);
                current = select[""];
            }
            else
                op += c;
        }
        return current != null ?
            current(self, op, line) :
            getop(self, op, line);
    }
    function get(int withcomments [optional])
    {
        var t = self.get_token();
        while (!t.iseof() && !withcomments && t.iscomment())
           t = self.get_token();
        return t;
    }
    function unget(var t)
    {
        push(self.stacked, t);
    }
}

//*********************************************
//          PIR generation values
//*********************************************

// Register types
const string
    REGint =     "I",
    REGfloat =   "N",
    REGstring =  "S",
    REGvar =     "P",
// Pseudotypes for builtins
    REGarglist = "*",
    REGany     = "?",
    REGsame    = ":", // same as argument
    REGs_v     = "p", // string or var
    REGraw1    = "!", // raw mode one arg
    REGnone    = "v"; // void return

// Register reserved for temporal and dicardable results
const string DISCARD_IREG = "$I0";
const string DISCARD_NREG = "$N0";
const string DISCARD_SREG = "$S0";
const string DISCARD_PREG = "$P0";

function typetoregcheck(string type)
{
    switch (type) {
    case "int":    return REGint;
    case "float":  return REGfloat;
    case "string": return REGstring;
    case "var":    return REGvar;
    default:       return "";
    }
}

function typetopirname(string regtype)
{
    switch (regtype) {
    case REGint:    return "int";
    case REGfloat:  return "num";
    case REGstring: return "string";
    case REGvar:    return "pmc";
    default:        InternalError("Invalid reg type");
    }
}

//*********************************************
//            Emit
//*********************************************

const string INDENT =      "    ";
const string INDENTLABEL = "  ";

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    var debug;
    var noan;
    var warnings;

    function Emit(var handle, int nowarn)
    {
        self.handle = handle;
        self.file = "";
        self.line = 0;
        self.pendingf = false;
        self.pendingl = false;
        self.warnings = new ["Boolean"](! nowarn);
    }
    function setDebug()
    {
        self.debug = true;
    }
    function getDebug()
    {
        return self.debug != null;
    }
    function disable_annotations()
    {
        self.noan = true;
    }
    function close()
    {
        self.handle = null;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(join("", [
                ".annotate 'file', '",
                self.file,
                "'\n" ]
            ));
            self.pendingf =: false;
        }
        if (self.pendingl) {
            self.handle.print(join("", [
                ".annotate 'line', ",
                self.line,
                "\n" ]
            ));
            self.pendingl =: false;
        }
    }
    function vprint(var args)
    {
        for_each(args, method_fun(self.handle, "print"));
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.noan == null)
        {
            var file = self.file;
            var line = self.line;
            string tfile = t.file;
            int tline = t.line;
            if (file != tfile) {
                file =: tfile;
                self.pendingf =: true;
                line =: 0;
            }
            if (line != tline) {
                line =: tline;
                self.pendingl =: true;
            }
        }
    }
    function comment(var args [slurpy])
    {
        self.updateannot();
        self.handle.print("# " + join("", args) + "\n");
    }
    function emitlabel(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENTLABEL);
        handle.print(label);
        handle.print(":");
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }
    function emitgoto(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENT + "goto ");
        handle.print(label);
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }

    function emitarg1(string op, string arg1)
    {
        self.say(INDENT, op, " ", arg1);
    }
    function emitarg2(string op, string arg1, string arg2)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2);
    }
    function emitarg3(string op, string arg1, string arg2, string arg3)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", arg3);
    }
    function emitcompare(string op, string arg1, string arg2, string label)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", label);
    }
    function emitif(string value, string label)
    {
        self.say(INDENT + "if ", value, " goto ", label);
    }
    function emitunless(string value, string label)
    {
        self.say(INDENT + "unless ", value, " goto ", label);
    }
    function emitif_null(string value, string label)
    {
        self.say(INDENT + "if_null ", value, ", ", label);
    }
    function emitunless_null(string value, string label)
    {
        self.say(INDENT + "unless_null ", value, ", ", label);
    }
    function emitnull(string dst)
    {
        self.say(INDENT + "null ", dst);
    }

    function emitinc(string arg)
    {
        self.say(INDENT + "inc ", arg);
    }
    function emitdec(string arg)
    {
        self.say(INDENT + "dec ", arg);
    }
    function emitset(string dst, string src)
    {
        self.say(INDENT + "set ", dst, ", ", src);
    }
    function emitassign(string dst, string src)
    {
        self.say(INDENT + "assign ", dst, ", ", src);
    }
    function emitbox(string dst, string src)
    {
        self.say(INDENT + "box ", dst, ", ", src);
    }
    function emitunbox(string dst, string src)
    {
        self.say(INDENT + "unbox ", dst, ", ", src);
    }
    function emitbinop(string op, string res, string dst, string src)
    {
        self.say(INDENT, op, " ", res, ", ", dst, ", ", src);
    }
    function emitaddto(string dst, string src)
    {
        self.say(INDENT + "add ", dst, ", ", src);
    }
    function emitsubto(string dst, string src)
    {
        self.say(INDENT + "sub ", dst, ", ", src);
    }
    function emitadd(string dst, string src1, string src2)
    {
        self.say(INDENT + "add ", dst, ", ", src1, ", ", src2);
    }
    function emitsub(string dst, string src1, string src2)
    {
        self.say(INDENT + "sub ", dst, ", ", src1, ", ", src2);
    }
    function emitmul(string dst, string src1, string src2)
    {
        self.say(INDENT + "mul ", dst, ", ", src1, ", ", src2);
    }
    function emitdiv(string dst, string src1, string src2)
    {
        self.say(INDENT + "div ", dst, ", ", src1, ", ", src2);
    }
    function emitconcat1(string dst, string src)
    {
        self.say(INDENT + "concat ", dst, ", ", dst, ", ", src);
    }
    function emitconcat(string dst, string src1, string src2)
    {
        self.say(INDENT + "concat ", dst, ", ", src1, ", ", src2);
    }
    function emitprint(string arg)
    {
        self.say(INDENT + "print ", arg);
    }
    function emitsay(string arg)
    {
        self.say(INDENT + "say ", arg);
    }
    function emitget_hll_namespace(string reg, string key)
    {
        self.say(INDENT + "get_hll_namespace ", reg, ", " + key);
    }
    function emitget_root_namespace(string reg, string key)
    {
        self.say(INDENT + "get_root_namespace ", reg, ", " + key);
    }
    function emitget_hll_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_hll_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitget_root_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_root_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitfind_lex(string reg, string name)
    {
        self.say(INDENT + "find_lex ", reg, ", ", name);
    }
    function emitstore_lex(string name, string reg)
    {
        self.say(INDENT + "store_lex ", name, ", ", reg);
    }
    function emitrepeat(string dst, string src1, string src2)
    {
        self.say(INDENT + "repeat ", dst, ", ", src1, ", ", src2);
    }
}

//*********************************************
//         Helper functions and constants
//*********************************************

// Scope search flags
const int
    SEARCH_NAMESPACE = 1,
    SEARCH_CLASS     = 2;

// Var flags
const int
    VAR_is_volatile = 1,      // volatile qualifier
    VAR_is_lexical  = 2,      // lexicalized local variable
    VAR_is_extern   = 4;      // externaly defined constant, do not export

const string
    NULL = "null",
    SELF = "self";


function integerValue(var owner, var start, int value)
{
    return new IntegerLiteral(owner, start, value);
}

function floatValue(var owner, var start, float value)
{
    :TokenFloat t(start.file, start.line, value);
    return new FloatLiteral(owner, t);
}

function stringQuotedValue(var owner, var start, string value)
{
    :TokenQuoted t(start.file, start.line, value);
    return new StringLiteral(owner, t);
}

function floatAsString(float n)
/*
    Make sure that a float value is recognized as such by the
    PIR compiler, adding a dot if needed.
*/
{
    string aux = n;
    if (aux.is_integer(aux))
        aux += ".0";
    return aux;
}

function floatresult(string r1, string r2)
/*
    Check if the passed types can give a float result in arithmetic
    operations.
*/
{
    int result = (r1 == REGfloat && (r2 == REGfloat || r2 == REGint)) ||
           (r2 == REGfloat && (r1 == REGfloat || r1 == REGint));
    return result;
}

// Predefined constants

// Fake filename and line number for the tokens.
const string PREDEFCONST_FILENAME = "__predefconst__";
const int PREDEFCONST_LINENUM = 0;

function createPredefConstInt(var scope, string name, int value)
{
    :TokenIdentifier tid(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGint, VAR_is_extern);
    cst.setvalue(integerValue(scope, tid, value));
}

function createPredefConstString(var scope, string name, string value)
{
    :TokenIdentifier tid(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGstring, VAR_is_extern);
    cst.setvalue(new StringLiteral(scope,
        new TokenQuoted(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM, value)));
}

//*********************************************
//             Builtins
//*********************************************

const int
    BULTIN_arglist = -1,
    BULTIN_raw1    = -2;

// Helpers for compile time evaluation

inline int_from_literal(var arg) return int
{
    __ASSERT__(arg instanceof Literal);
    int value = arg.getIntegerValue();
    return value;
}

inline float_from_literal(var arg) return float
{
    __ASSERT__(arg instanceof Literal);
    float value = arg.getFloatValue();
    return value;
}

inline string_from_literal(var arg) return string
{
    __ASSERT__(arg instanceof Literal);
    string value = arg.getStringValue();
    return value;
}

/*
    Get a literal from a builtin with just one param.
    The argument list validity should be checked before, so
    check here only in debug builds.
*/
function int_from_literal_arg1(var args)
{
    if (__DEBUG__) {
        if (elements(args) != 1)
            InternalError("call to " + __FUNCTION__ + " with invalid args");
    }
    return int_from_literal(args[0].arg);
}
function string_from_literal_arg1(var args)
{
    if (__DEBUG__) {
        if (elements(args) != 1)
            InternalError("call to " + __FUNCTION__ + " with invalid args");
    }
    return string_from_literal(args[0].arg);
}

// Invokable object generated from a string body
class Builtin_frombody
{
    const string resultmark = "%0";
    var body;
    var typeresult;
    function Builtin_frombody(string typeresult, string bodystr)
    {
        if (__DEBUG__) {
            // Minimal sanity check
            int pos = indexof(bodystr, resultmark);
            if (typeresult == REGnone && pos != -1)
                InternalError("void builtin with " + resultmark);
            if (typeresult != REGnone && pos == -1)
                InternalError("non void builtin without " + resultmark);
            switch (typeresult) {
              case REGint: case REGfloat: case REGstring:
              case REGvar: case REGnone:
                break;
              case REGsame:
                // TODO: must check it has one argument
                break;
              default:
                InternalError("Invalid result type in builtin");
            }
        }

        // Predecorate output
        int l = length(bodystr) - 1;
        if (substr(bodystr, l, 1) == "\n")
            bodystr = substr(bodystr, 0, l);
        bodystr = INDENT + join("\n" + INDENT, split("\n", bodystr));
        self.body = bodystr;
        self.typeresult = typeresult;
    }
    function invoke [vtable](var e, var owner, var start, string result, var args)
    {
        string typeresult = self.typeresult;

        if (typeresult == REGnone) {
            if (result != null && result != "")
                SyntaxError("using return value from void builtin", start);
        }
        else {
            if (result == null || result == "")
                InternalError("Bad result in non void builtin");
        }

        e.annotate(start);
        e.say(sformat(self.body, result, args:[flat]));
    }
}

class BuiltinBase
{
    var name;
    var body;
    var typeresult;
    var type0;
    var type1;
    var type2;
    var type3;
    var nparams;

    function BuiltinBase(string name, var body,
        string typeresult,
        string type0,
        string type1,
        string type2,
        string type3)
    {
        self.name = name;
        if (body != null && body instanceof "String")
            self.body = new Builtin_frombody(typeresult, body);
        else
            self.body = body;
        self.typeresult = typeresult;
        int n = 0;
        if (type0 != null) {
            self.type0 = type0;
            switch (type0) {
              case REGarglist:
                n = BULTIN_arglist;
                break;
              case REGraw1:
                n = BULTIN_raw1;
                if (type1 != null)
                    InternalError("Invalid builtin '" + name + "'");
                break;
              default:
                n = 1;
                if (type1 != null) {
                    self.type1 = type1;
                    ++n;
                }
                if (type2 != null) {
                    self.type2 = type2;
                    ++n;
                }
                if (type3 != null) {
                    self.type3 = type3;
                    ++n;
                }
            }
        }
        self.nparams = n;
    }
    function isreplaceexpr() { return false; }
    function iscompileevaluable() { return false; }
    function name()
    {
        return string(self.name);
    }
    function result()
    {
        return self.typeresult;
    }
    function params() { return self.nparams; }
    function paramtype(int i)
    {
        string type;
        switch (i) {
        case 0: type = self.type0; break;
        case 1: type = self.type1; break;
        case 2: type = self.type2; break;
        case 3: type = self.type3; break;
        default:
            InternalError("Invalid builtin arg");
        }
        return type;
    }
    function expand(var e, var owner, var start, string result, var args)
    {
        string name = self.name;

        if (e.getDebug()) {
            // Special case for a now.
            if (name != "__ASSERT__")
                e.comment("builtin ", name);
        }

        string typeresult = self.typeresult;
        if (typeresult != REGnone && result == "")
            result = owner.tempreg(typeresult);
        var fun = self.body;
        fun(e, owner, start, result, args);
    }
}

class BuiltinFunction : BuiltinBase
{
    function BuiltinFunction(string name, var body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
    }
}

class BuiltinFunctionEval : BuiltinBase
{
    var evalfun;
    function BuiltinFunctionEval(string name, var evalfun, var body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
        self.evalfun = evalfun;
    }
    function iscompileevaluable() { return true; }
}

class BuiltinExpr : BuiltinBase
{
    var exprfun;
    function BuiltinExpr(string name, var exprfun,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, null, typeresult, type0, type1, type2, type3);
        self.exprfun = exprfun;
    }
    function isreplaceexpr() { return true; }
    function replaceexpr(var owner, var start, var args)
    {
        var exprfun = self.exprfun;
        return exprfun(owner, start, args);
    }
}

function Builtin_say(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    int n = elements(args) - 1;
    if (n >= 0) {
        for (int i = 0; i < n; ++i)
            e.emitprint(args[i]);
        e.emitsay(args[n]);
    }
    else
        e.emitsay("''");
}

function Builtin_cry(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    e.say(sformat(
<<:
    getstderr $P0
%0
    print $P0, "\n"
:>>
        , join("\n", transform(args, [], addprefix(INDENT + "print $P0, ")))));
}

function Builtin_print(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    for_each(args, method_fun(e, "emitprint"));
}

function Builtin_abs(var e, var owner, var start, string result, var args)
{
    var arg = args[0];
    string argreg = arg.emit_get(e);
    if (arg.checkresult() == REGstring) {
        string aux = owner.tempreg(REGfloat);
        e.annotate(start);
        e.emitset(aux, argreg);
        e.emitarg2("abs", aux, aux);
        e.emitset(result, aux);
    }
    else {
        e.annotate(start);
        e.emitarg2("abs", result, argreg);
    }
}

function Builtin_ASSERT(var e, var owner, var start, string result, var args)
{
    __ASSERT__(elements(args) == 1); // Best place to use it

    if (e.getDebug()) {
        e.annotate(start);
        string label = owner.genlabel();
        var arg = args[0];
        var reg = arg.emit_getint(e);
        e.emitif(reg, label);
        e.print(sformat(
<<:
    getstderr $P0
    print $P0, "Assertion failed at '%0' line "
    print $P0, %1
    print $P0, "\n"
    exit 1
:>>
            , start.filename(), start.linenum()));
        e.emitlabel(label);
    }
}

// invoke is a quick & dirty way to allow use of multiple return values.
// It's a wrap around the call that gives the signature object returned.
function Builtin_invoke(var e, var owner, var start, string result, var args)
{
    var arg = args[0];
    if (! (arg instanceof CallExpr))
        SyntaxError("invoke argument must be callable", start);
    arg.emit(e, "(" + result + " :call_sig)");
}

function builtineval_length(var owner, var start, var args)
{
    string s = string_from_literal_arg1(args);
    return integerValue(owner, start, length(s));
}

function builtineval_bytelength(var owner, var start, var args)
{
    string s = string_from_literal_arg1(args);
    return integerValue(owner, start, bytelength(s));
}

function builtineval_ord(var owner, var start, var args)
{
    int nargs = elements(args);
    var arg = args[0].arg;
    string s = string_from_literal(arg);
    int pos = 0;
    if (nargs > 1) {
        var argpos = args[1].arg;
        pos = int_from_literal(argpos);
    }
    return integerValue(owner, start, ord(s, pos));
}

function builtineval_chr(var owner, var start, var args)
{
    return stringQuotedValue(owner, start, chr(int_from_literal_arg1(args)));
}

function builtineval_substr(var owner, var start, var args)
{
    int nargs = elements(args);
    var argstr = args[0].arg;
    var argpos = args[1].arg;
    string str = string_from_literal(argstr);
    int pos = int_from_literal(argpos);
    string result;
    if (nargs > 2) {
        var arglen = args[2].arg;
        int len = int_from_literal(arglen);
        result = substr(str, pos, len);
    }
    else
        result = substr(str, pos);
    return stringQuotedValue(owner, start, result);
}

function builtineval_indexof(var owner, var start, var args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    string strfrom = string_from_literal(argstrfrom);
    string strsearch = string_from_literal(argstrsearch);
    return integerValue(owner, start, indexof(strfrom, strsearch));
}

function builtineval_indexof_pos(var owner, var start, var args)
{
    var argstrfrom = args[0].arg;
    var argstrsearch = args[1].arg;
    var argpos = args[2].arg;
    string strfrom = string_from_literal(argstrfrom);
    string strsearch = string_from_literal(argstrsearch);
    int pos = int_from_literal(args[2].arg);
    return integerValue(owner, start, indexof(strfrom, strsearch, pos));
}

function builtineval_upcase(var owner, var start, var args)
{
    return stringQuotedValue(owner, start,
            upcase(string_from_literal_arg1(args)));
}

function builtineval_downcase(var owner, var start, var args)
{
    return stringQuotedValue(owner, start,
            downcase(string_from_literal_arg1(args)));
}

function builtineval_escape(var owner, var start, var args)
{
    // This is a unescaped string. To get a escaped string
    // in the output we need to escape twice.
    return stringQuotedValue(owner, start,
            escape(escape(string_from_literal_arg1(args))));
}

function builtin_sleep(var e, var owner, var start, string result, var args)
{
    var expr = args[0];
    string reg;
    string type = expr.checkresult();
    switch (type) {
      case REGint:
        reg = expr.emit_getint(e);
        break;
      case REGfloat:
        reg = expr.emit_get(e);
        break;
      default:
        if (expr.isnull())
            reg = "0";
        else {
            string aux = expr.emit_get(e);
            reg = DISCARD_NREG;
            e.annotate(start);
            e.emitset(reg, aux);
        }
    }
    e.annotate(start);
    e.emitarg1("sleep", reg);
}

function getbuiltins(var builder)
{
    builder.add(new BuiltinExpr("int",
        builtinexpr_intcast,
        REGstring, REGraw1
    ));
    builder.add(new BuiltinExpr("float",
        builtinexpr_floatcast,
        REGstring, REGraw1
    ));
    builder.add(new BuiltinExpr("string",
        builtinexpr_stringcast,
        REGstring, REGraw1
    ));

    builder.add(new BuiltinExpr("var",
        builtinexpr_varcast,
        REGvar, REGraw1
    ));
    builder.add(new BuiltinFunction("die",
        "die %1",
        REGnone, REGstring
    ));
    builder.add(new BuiltinFunction("exit",
        "exit %1",
        REGnone, REGint
    ));
    builder.add(new BuiltinFunction("time",
        "time %0",
        REGint
    ));
    builder.add(new BuiltinFunction("floattime",
        "time %0",
        REGfloat
    ));
    builder.add(new BuiltinFunction("sleep",
        builtin_sleep,
        REGnone, REGraw1
    ));
    builder.add(new BuiltinFunction("spawnw",
        "spawnw %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction("getstdin",
        "getstdin %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("getstdout",
        "getstdout %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("getstderr",
        "getstderr %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("open",
<<:
root_new %0, ["parrot";"FileHandle"]
%0."open"(%1)
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("open",
<<:
root_new %0, ["parrot";"FileHandle"]
%0."open"(%1,%2)
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
:>>
        , REGvar, REGstring, REGint
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
%0["type"] = %3
:>>
        , REGvar, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
%0["type"] = %3
%0["payload"] = %4
:>>
        , REGvar, REGstring, REGint, REGint, REGvar
    ));
    builder.add(new BuiltinFunction("elements",
        "elements %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunctionEval("length",
        builtineval_length,
        "length %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("bytelength",
        builtineval_bytelength,
        "bytelength %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("chr",
        builtineval_chr,
<<:
chr $S0, %1
find_encoding $I0, "utf8"
trans_encoding %0, $S0, $I0
:>>
        , REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("ord",
        builtineval_ord,
        "ord %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("ord",
        builtineval_ord,
        "ord %0, %1, %2",
        REGint, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("substr",
        builtineval_substr,
        "substr %0, %1, %2",
        REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("substr",
        builtineval_substr,
        "substr %0, %1, %2, %3",
        REGstring, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction("replace",
        "replace %0, %1, %2, %3, %4",
        REGstring, REGstring, REGint, REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("indexof",
        builtineval_indexof,
        "index %0, %1, %2",
        REGint, REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval("indexof",
        builtineval_indexof_pos,
        "index %0, %1, %2, %3",
        REGint, REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunction("join",
        "join %0, %1, %2",
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunctionEval("escape",
        builtineval_escape,
        "escape %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("unescape",
<<:
$P0 = new ["String"]
$P0 = %1
%0 = $P0."unescape"("utf8")
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("unescape",
<<:
$P0 = new ["String"]
$P0 = %1
%0 = $P0."unescape"(%2)
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("trans_encoding",
<<:
find_encoding $I0, %2
trans_encoding %0, %1, $I0
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("encoding_name",
<<:
encoding $I0, %1
encodingname %0, $I0
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval("upcase",
        builtineval_upcase,
        "upcase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunctionEval("downcase",
        builtineval_downcase,
        "downcase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("titlecase",
        "titlecase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("split",
        "split %0, %1, %2",
        REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("chomp",
<<:
$P0 = get_root_global ["parrot";"String";"Utils"], "chomp"
%0 = $P0(%1)
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("chomp",
<<:
$P0 = get_root_global ["parrot";"String";"Utils"], "chomp"
%0 = $P0(%1, %2)
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("push",
        "push %1, %2",
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction("unshift",
        "unshift %1, %2",
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction("pop_var",
        "pop %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("shift_var",
        "shift %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("pop_int",
        "pop %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction("shift_int",
        "shift %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction("pop_float",
        "pop %0, %1",
        REGfloat, REGvar
    ));
    builder.add(new BuiltinFunction("shift_float",
        "shift %0, %1",
        REGfloat, REGvar
    ));
    builder.add(new BuiltinFunction("pop_string",
        "pop %0, %1",
        REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("shift_string",
        "shift %0, %1",
        REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("abs",
        Builtin_abs,
        REGsame, REGraw1
    ));
    builder.add(new BuiltinFunction("sqrt",
        "sqrt %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("pow",
        "pow %0, %1, %2",
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("exp",
        "exp %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("ln",
        "ln %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("sin",
        "sin %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("cos",
        "cos %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("tan",
        "tan %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("asin",
        "asin %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("acos",
        "acos %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("atan",
        "atan %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("atan",
        "atan %0, %1, %2",
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("sinh",
        "sinh %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("cosh",
        "cosh %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("tanh",
        "tanh %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("getinterp",
        "getinterp %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("getcontext",
/*
        DEPRECATED: for compatibility only, use get_context instead.
*/
        "get_context %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("get_context",
        "get_context %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("get_class",
        "get_class %0, %1",
        REGvar, REGs_v
    ));
    builder.add(new BuiltinFunction("typeof",
        "typeof %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("getattribute",
        "getattribute %0, %1, %2",
        REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("getattribute",
        "getattribute %0, %1, %2, %3",
        REGvar, REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("setattribute",
        "setattribute %1, %2, %3, %4",
        REGnone, REGvar, REGvar, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("find_method",
        "find_method %0, %1, %2",
        REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("callmethodwithargs",
        "%0 = %1.%2(%3 :flat)",
        REGvar, REGvar, REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("clone",
        "clone %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("compreg",
        "compreg %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("compreg",
        "compreg %1, %2",
        REGnone, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("load_language",
<<:
load_language %1
compreg %0, %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("load_language",
<<:
load_language %1
compreg %0, %2
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("loadlib",
        "loadlib %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("load_bytecode",
        "load_bytecode %1",
        REGnone, REGstring
    ));
    builder.add(new BuiltinFunction("load_packfile",
        "load_bytecode %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("dlfunc",
        "dlfunc %0, %1, %2, %3",
        REGvar, REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("sprintf",
        "sprintf %0, %1, %2",
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("print",
        Builtin_print,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("say",
        Builtin_say,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("cry",
        Builtin_cry,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("__ASSERT__",
        Builtin_ASSERT,
        REGnone, REGraw1
    ));
    builder.add(new BuiltinFunction("invoke",
        Builtin_invoke,
        REGvar, REGraw1
    ));
}

//*********************************************
//               Auxiliar functions
//*********************************************

inline optimize_array(var arr)
{
    int n = arr != null ? elements(arr) : 0;
    for (int i = 0; i < n; ++i)
        arr[i] = arr[i].optimize();
}

inline emit_array(var e, var arr)
{
    for_each(arr, bindlast(bindmethod("emit"), e));
}

function parseDotted(var tk)
{
    var list = [];
    var t = tk.get();
    if (t.isidentifier()) {
        push(list, t);
        while ((t = tk.get()).isop(".")) {
            t = tk.get();
            push(list, t);
        }
    }
    tk.unget(t);
    return list;
}

function parseList(var tk, var owner, var fn, string oper_end[optional])
/*
  Parse a comma separated list of items.
  Calls the passed fn to parse each item.
*/
{
    var list = [];
    var t;
    do {
        var value = fn(tk, owner);
        push(list, value);
    } while ((t = tk.get()).isop(","));
    if (oper_end == null)
        tk.unget(t);
    else
        if (! t.isop(oper_end))
            SyntaxError("Unfinished argument list", t);
    return list;
}

function parseListOrEmpty(var tk, var owner, var fn, string oper_end)
/*
  Parse a comma separated list of items.
  Calls the passed fn to parse each item.
  Return null if empty.
*/
{
    var t = tk.get();
    if (t.isop(oper_end))
        return null;
    tk.unget(t);
    var list = [];
    do {
        var value = fn(tk, owner);
        push(list, value);
    } while ((t = tk.get()).isop(","));
    if (! t.isop(oper_end))
        SyntaxError("Unfinished argument list", t);
    return list;
}

// Helper to parse identifier lists using parseList
function parseIdentifier(var tk, var unused)
{
    var t = tk.get();
    if (!t.isidentifier())
        ExpectedIdentifier(t);
    return t;
}

function toIdentifierList(var tlist)
{
    string list[];
    transform(tlist, list, bindmethod("getidentifier"));
    return list;
}

function toModuleFilename(var tlist)
{
    return "\"" + join("/", toIdentifierList(tlist)) + ".pbc\"";
}

//*********************************************
//               CommonBase
//*********************************************

class CommonBase
{
    var start;
    var owner;

    function initbase(var start, var owner)
    {
        __ASSERT__(start instanceof Token);
        __ASSERT__((owner instanceof Statement) ||
                   (owner instanceof ClassStatement) ||
                   (owner instanceof NamespaceBase));
        self.start = start;
        self.owner = owner;
    }
    function clone(var owner)
    {
        SyntaxError("Cannot use " + string(typeof(self)) + " in inline (yet)",
                self);
    }
    function getstart()
    {
        return self.start;
    }
    function viewable()
    {
        if (self.start != null)
            return self.start.viewable();
        else
            return "";
    }
    function annotate(var e)
    {
        e.annotate(self.start);
    }
    function getpath()
    {
        return self.owner.getpath();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function usesubid(string id)
    {
        self.owner.usesubid(id);
    }
    function addlocalfunction(var fn)
    {
        return self.owner.addlocalfunction(fn);
    }
    function scopesearch(var key, int flags)
    {
        return self.owner.scopesearch(key, flags);
    }
    function dowarnings()
    {
        return self.owner.dowarnings();
    }
}

//*********************************************
//             CollectValues
// Emit an get registers for a collection of
// values avoiding redundant setting of null
// registers.
//*********************************************

class CollectValues
{
    var owner;
    var e;
    var pnull;
    function CollectValues(var owner, var e)
    {
        self.owner = owner;
        self.e = e;
    }
    function add(var value)
    {
        __ASSERT__(value instanceof Expr);
        var e = self.e;
        string valuereg;
        if (value.isnull()) {
            var pnull = self.pnull;
            if (pnull == null) {
                string regnull = self.owner.tempreg(REGvar);
                e.emitnull(regnull);
                self.pnull = pnull = regnull;
            }
            valuereg = pnull;
        }
        else
            valuereg = value.emit_get(e);
        return valuereg;
    }
}

//*********************************************
//          SimpleArgList
//*********************************************

// A list of arguments without modifiers.

class SimpleArgList
{
    var args;

    function SimpleArgList(var tk, var owner, string oper_end)
    {
        self.args = parseList(tk, owner, parseExpr, oper_end);
    }
    function clone(var owner)
    {
        :SimpleArgList cloned;
        cloned.args = clone_array(self.args, owner);
        return cloned;
    }

    function numargs()
    {
        return elements(self.args);
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }

    function optimizeargs()
    {
        optimize_array(self.args);
    }
    function getargvalues(var e)
    {
        return transform(self.args, [], bindlast(bindmethod("emit_get"), e));
    }
    function emitargs(var e)
    {
        e.print(join(", ", self.getargvalues(e)));
    }
}

//*********************************************
//            Modifiers
//*********************************************

class Modifier
{
    var name;
    var args;

    function clone(var owner)
    {
        var args = self.args;
        return new Modifier(self.name,
                args != null ? args.clone(owner) : null);
    }
    function getname() { return self.name; }
    function numargs()
    {
        var args = self.args;
        int nargs = args == null ? 0 : args.numargs();
        return nargs;
    }
    function getarg(int argnum)
    {
        var args = self.args;
        if (argnum >= args.numargs())
            InternalError("Wrong modifier arg number");
        return args.getarg(argnum);
    }
    function Modifier(string name, var args)
    {
        self.name = name;
        if (args != null)
            self.args = args;
    }
    function optimize()
    {
        if (self.args != null)
            self.args.optimizeargs();
        return self;
    }
}

function parseModifier(var tk, var owner)
{
    var t = tk.get();
    string name = t.getidentifier();
    t = tk.get();
    var args;
    if (t.isop("("))
        args = new SimpleArgList(tk, owner, ")");
    else
        tk.unget(t);
    return new Modifier(name, args);
}


class ModifierList
{
    var list;

    function ModifierList(var tk, var owner)
    {
        self.list = parseList(tk, owner, parseModifier, "]");
    }
    function clonemodifiers(var owner)
    {
        return clone_array(self.list, owner);
    }
    function optimize()
    {
        optimize_array(self.list);
    }
    function getlist() { return self.list; }
    function pick(string name)
    {
        return find_if(self.list,
                 function (var mod) { return mod.getname() == name; }
        );
    }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

inline getparrotkey(var path) return string
{
    string r;
    if (elements(path) != 0)
        r = "[ '" + string(join("'; '", path)) + "' ]";
    return r;
}

function parseUsing(var t, var tk, var owner)
{
    var taux = tk.get();
    switch {
      case taux.iskeyword("extern"):
        return new ExternStatement(t, tk, owner);
      case taux.iskeyword("static"):
        return new StaticStatement(t, tk, owner);
      case taux.iskeyword("namespace"):
        return new UsingNamespaceStatement(taux, tk, owner);
      default:
        tk.unget(taux);
        return new UsingStatement(t, tk, owner);
    }
}

function parseSig(var start, var tk, var owner)
{
    :SigParameterList params(tk, owner);
    var t = tk.get();
    if (! t.isop("="))
        Expected("'='", t);
    var expr = parseExpr(tk, owner);
    return new MultiAssignStatement(start, owner, params, expr);
}

function parseClassSpecifier(var tk, var owner)
{
    var t = tk.get();
    if (t.isstring())
        return new ClassSpecifierStr(owner, t);
    if (t.isop("["))
        return new ClassSpecifierParrotKey(tk, owner, t);
    if (t.isidentifier())
        return new ClassSpecifierId(tk, owner, t);
    SyntaxError("Invalid class", t);
}

function parseStatement(var tk, var owner)
{
    var t = tk.get();
    var t2;
    if (t.isop(";"))
        return new EmptyStatement;
    if (t.isop("{"))
        return new CompoundStatement(t, tk, owner);
    if (t.isop("${"))
        return new PiropStatement(t, tk, owner);
    if (t.isop(":")) {
        var open = tk.get();
        switch {
          case open.isop("("):
            return parseSig(t, tk, owner);
          case open.isidentifier():
            // EXPERIMENTAL
            var cl = new ClassSpecifierId(tk, owner, open);
            var tname = tk.get();
            RequireIdentifier(tname);

            // Violating encapsulation for fun and profit!
            var varst = new VarStatement;
            varst.initvarbase(tname, owner, tname, 0);
            var newexpr = new NewQualifiedExpr;
            newexpr.Expr(varst, tname);
            newexpr.nskey = cl;
            t = tk.get();
            if (t.isop("(")) {
                newexpr.parseinitializer(tk);
                t = tk.get();
            }
            RequireOp(";", t);
            varst.init = newexpr;

            return varst;
          default:
            Unexpected("':'", t);
        }
    }

    switch (t.checkkeyword()) {
      case "using":
        return parseUsing(t, tk, owner);
      case "const":
        return parseConst(t, tk, owner);
        break;
      case "volatile":
        return parseVolatile(t, tk, owner);
        break;
      case "var":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseVar(t, tk, owner);
        break;
      case "string":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseString(t, tk, owner);
        break;
      case "int":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseInt(t, tk, owner);
        break;
      case "float":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseFloat(t, tk, owner);
        break;
      case "return":
        return parseReturn(t, tk, owner);
      case "yield":
        return new YieldStatement(t, tk, owner);
      case "goto":
        return parseGoto(t, tk, owner);
      case "if":
        return new IfStatement(t, tk, owner);
      case "while":
        return new WhileStatement(t, tk, owner);
      case "do":
        return new DoStatement(t, tk, owner);
      case "continue":
        return new ContinueStatement(t, tk, owner);
      case "break":
        return new BreakStatement(t, tk, owner);
      case "switch":
        return parseSwitch(t, tk, owner);
      case "for":
        return parseFor(t, tk, owner);
      case "throw":
        return new ThrowStatement(t, tk, owner);
      case "try":
        return new TryStatement(t, tk, owner);
      case "inline":
        :InlineStatement inl(t, tk, owner);
        owner.addinline(inl);
        return new EmptyStatement;
    }

    if (t.isidentifier()) {
        var t2 = tk.get();
        if (t2.isop(":"))
            return new LabelStatement(t, owner);
        tk.unget(t2);
    }
    tk.unget(t);
    return new ExprStatement(t, tk, owner);
}

//*********************************************
//            Statement
//*********************************************

class Statement : CommonBase
{
    function Statement(var start, var owner)
    {
        self.initbase(start, owner);
    }
    function isempty() { return false; }
    function allowtailcall()
    {
        return self.owner.allowtailcall();
    }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function getlabel(string name)
    {
        return self.owner.getlabel(name);
    }
    function createlabel(var name)
    {
        return self.owner.createlabel(name);
    }
    function createconst(var name, string type, int flags [optional])
    {
        return self.owner.createconst(name, type, flags);
    }
    function createvar(var name, string type, int flags[optional])
    {
        return self.owner.createvar(name, type, flags);
    }
    function createvarused(var name, var data)
    {
        return self.owner.createvarused(name, data);
    }
    function createvarnamed(var name, string type, string pirname)
    {
        return self.owner.createvarnamed(name, type, pirname);
    }
    function getvar(var name)
    {
        return self.owner.getvar(name);
    }
    function checkclass(string name)
    {
        return self.owner.checkclass(name);
    }
    function usenamespace(var ns)
    {
        self.owner.usenamespace(ns);
    }

    function getouter()
    {
        // Returns the nearest outer scope. In this base case,
        // just propagate it. Deriveds that are appropiate
        // scopes will override.
        return self.owner.getouter();
    }
    function getlexicalouter()
    {
        // Same as getouter but for outer able to contains lexicals,
        // skiping inline blocks.
        return self.owner.getlexicalouter();
    }
    function getcontinuelabel(var pos)
    {
        return self.owner.getcontinuelabel(pos);
    }
    function getbreaklabel(var pos)
    {
        return self.owner.getbreaklabel(pos);
    }
    function optimize()
    {
        InternalError("**checking**", self.start);
        // Return unchanged by default
        return self;
    }
}

class EmptyStatement : Statement
{
    function isempty() { return true; }
    function clone(var owner) { return self; }
    function annotate(var e)
    {
        InternalError("Attempt to annotate empty statement");
    }
    function optimize() { return self; }
    function emit(var e)
    {
        // Do nothing
    }
}

class MultiStatementBase
{
    var statements;

    function optimize()
    {
        var statements = self.statements;
        int n = elements(statements);
        int empty = true;
        for (int i = 0; i < n; ++i) {
            var st = statements[i].optimize();
            if (empty && ! st.isempty())
                empty = false;
            statements[i] = st;
        }
        return empty ? new EmptyStatement : self;
    }
}

class MultiStatement : MultiStatementBase
{
    function MultiStatement(var st1, var st2)
    {
        self.statements = [st1, st2];
    }
    function clone(var owner)
    {
        :MultiStatement cloned;
        cloned.statements = clone_array(self.statements, owner);
        return cloned;
    }
    function isempty() { return false; }
    function push(var statement)
    {
        push(self.statements, statement);
        return self;
    }
    function emit(var e)
    {
        emit_array(e, self.statements);
    }
}

inline addtomulti(var multi, var newst) return var
{
    switch {
      case multi == null:
        return newst;
      case multi instanceof MultiStatement:
        return multi.push(newst);
      default:
        return new MultiStatement(multi, newst);
    }
}

//*********************************************
//           PiropStatement
//*********************************************

function parsePiropArg(var tk, var owner)
{
    var arg;
    var t = tk.get();
    if (t.isop(":")) {
        t = tk.get();
        if (! t.isidentifier())
            SyntaxError("Label expected", t);
        arg = new Reflabel(owner, t);
    }
    else {
        tk.unget(t);
        arg = parseExpr(tk, owner);
    }
    return arg;
}

class PiropStatement : Statement
{
    var opname;
    var args;

    function PiropStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        int dotted = t.isop(".");
        if (dotted)
            t = tk.get();
        string opname = t.getidentifier();
        self.opname = (dotted ? "." : "") + opname;
        self.args = parseListOrEmpty(tk, owner, parsePiropArg, "}");
        ExpectOp(";", tk);
    }
    function clone(var owner)
    {
        :PiropStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.opname = self.opname;
        cloned.args = clone_array(self.args, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.args);
        return self;
    }
    function emit(var e)
    {
        string opname = self.opname;
        self.annotate(e);
        if (e.getDebug())
            e.comment("pirop ", opname);
        var args = self.args;
        e.print(INDENT);
        if (args == null)
            e.say(opname);
        else
            e.say(opname, " ", join(", ",
                    transform(args, [], bindlast(bindmethod("emit_get"), e))
            ));
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement : Statement
{
    var path;
    function ExternStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(";", tk);
        self.path = toIdentifierList(path);
        return self;
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        e.say(INDENT, "load_bytecode '", join("/", self.path), ".pbc'");
    }
}

//*********************************************
//            StaticStatement
//*********************************************

class StaticStatement : Statement
{
    var names;
    function StaticStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var names = parseList(tk, null, parseIdentifier, ";");
        for (var name in names) {
            string id = self.generatesubid();
            self.createvarnamed(name, REGvar, id);
        }
        self.names = names;
    }
    function optimize()
    {
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        for (var name in self.names)
            e.say(".const 'Sub' ", self.getvar(name).getreg(),
                    " = '", name, "'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement : Statement
{
    var path;
    var subid;

    function UsingStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(";", tk);
        self.path = path;
    }
    function optimize()
    {
        var path = self.path;
        var name = path[-1];

        var symbol = self.scopesearch(path, 0);
        switch {
          case symbol == null:
            if (elements(path) != 0) {
                var p = clone(path);
                p.pop();
                var ns = self.scopesearch(p, SEARCH_NAMESPACE);
                if (ns != null) {
                    symbol = ns.getvar(name);
                    if (symbol != null) {
                        self.createvarused(name, symbol);
                        return new EmptyStatement;
                    }
                }
            }
            break;
          case symbol instanceof FunctionStatement:
            string subid = symbol.makesubid();
            self.createvarnamed(name, REGvar, subid);
            self.subid = subid;
            self.usesubid(subid);
            return self;
        }
        self.createvar(name, REGvar);
        return self;
    }
    function emit(var e)
    {
        var path = self.path;
        var name = path[-1];
        var vdata = self.getvar(name);
        if (self.subid == null) {
            self.annotate(e);
            string key;
            if (elements(path) > 1) {
                path.pop();
                key = getparrotkey(path);
            }
            e.emitget_hll_global(vdata.getreg(), name.getidentifier(), key);
        }
    }
}

//*********************************************
//            UsingNamespaceStatement
//*********************************************

// Common part of using namespace from different kinds of scopes.
function usingNamespace(var start, var tk, var owner)
{
    var nskey = parseDotted(tk);
    if (elements(nskey) == 0)
        Expected("namespace identifier", start);
    var nssym = owner.scopesearch(nskey, SEARCH_NAMESPACE);
    if (nssym == null)
        SyntaxError("unknow namespace", start);
    owner.usenamespace(nssym);
}

class UsingNamespaceStatement : Statement
{
    function UsingNamespaceStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        usingNamespace(start, tk, owner);
        ExpectOp(";", tk);
    }
    function optimize()
    {
        return self;
    }
    function emit(var e)
    {
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function ExprStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.expr = parseList(tk, self, parseExpr, ";");
    }
    function clone(var owner)
    {
        :ExprStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.expr = clone_array(self.expr, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.expr);
        return self;
    }
    function emit(var e)
    {
        for_each(self.expr, bindlast(bindmethod("emit_void"), e));
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarData
{
    var type;
    var reg;
    var scope;
    var flags;
    var lexname;

    function VarData(string type, var reg, var scope, int flags)
    {
        // Sanity check
        __ASSERT__(type == REGint || type == REGfloat || type == REGstring ||
                type == REGvar);

        self.type = type;
        self.reg = reg;
        self.scope = scope;
        self.flags = flags;
    }
    function setlex(string name)
    {
        self.lexname = name;
    }
    function createlex(string lexname)
    {
        // Set the lexname and make the variable a lexical
        // in its outer.
        self.setlex(lexname);
        self.getscope().getouter().setlex(lexname, self.reg);
    }
    function gettype() { return self.type; }
    function getreg() { return self.reg; }
    function getscope() { return self.scope; }
    function getvalue() { return self.value; }
    function isconst() { return false; }
    function getlex()
    {
        var lexname = self.lexname;
        return lexname != null ? string(lexname) : null;
    }
    function getflags() { return self.flags; }
    function issubid()
    {
        var reg = self.reg;
        return reg != null && substr(reg, 0, 7) == "WSubId_";
    }
}

class ConstantInternalFail
{
    var name;
    function ConstantInternalFail(var name)
    {
        self.name = name;
    }
    function get_string[vtable]()
    {
        InternalError("Attempt to use unexpanded constant!!!", self.name);
    }
}

class VarData_const : VarData
{
    var value;

    function VarData_const(string type, var name, var scope, int flags)
    {
        self.VarData(type, new ConstantInternalFail(name), scope, flags);
    }
    function isconst() { return true; }
    function setvalue(var value)
    {
        if (self.value != null)
            InternalError("Attempt change value of constant!!!");
        self.value = value;
    }
}


class VarContainer
{
    var locals;
    var usednamespaces;

    function VarContainer()
    {
        self.locals = {};
    }
    function createvar(var name, string type, int flags[optional])
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name.getidentifier();
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        string reg = self.createreg(type);
        :VarData data(type, reg, self, flags);
        locals[sname] = data;
        return data;
    }
    function createvarused(var name, var data)
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        locals[sname] = data;
    }
    function createvarnamed(var name, string type, string pirname)
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name;
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        locals[sname] = new VarData(type, pirname, self, 0);
    }
    function createconst(var name, string type, int flags[optional])
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name.getidentifier();
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        :VarData_const data(type, name, self, flags);
        locals[sname] = data;
        return data;
    }
    function getlocalvar(var name)
    {
        var locals = self.locals;
        return locals[string(name)];
    }
    function getusedvar(var name)
    {
        var sym;
        for (var ns in self.usednamespaces) {
            if ((sym = ns.getlocalvar(name)) != null)
                return sym;
        }
        return null;
    }
    function getvar(var name)
    {
        __ASSERT__(name instanceof TokenIdentifier);
        var sym;
        if ((sym = self.getlocalvar(name)) != null)
            return sym;
        if ((sym = self.getusedvar(name)) != null)
            return sym;
        var owner = self.owner;
        if (owner != null)
            return owner.getvar(name);
        return null;
    }
    function makelexical(var vardesc)
    {
        var lexowner = self.getlexicalouter();
        string lexname = lexowner.createlex(vardesc);
        return lexname;
    }
    function makelexicalself()
    {
        const string lexname = "'__WLEX_self'";
        self.setlex(lexname, SELF);
        return lexname;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
    var inlines;
    function BlockStatement(var start, var owner)
    {
        self.Statement(start, owner);
        self.VarContainer();
    }
    function addinline(var inl)
    {
        __ASSERT__(inl instanceof InlineStatement);
        string name = inl.name;
        var inlines = self.inlines;
        if (inlines != null)
            inlines[name] = inl;
        else
            self.inlines = { name : inl };
    }
    function scopesearch(var key, int flags)
    {
        if (flags == 0 && elements(key) == 1) {
            var inlines = self.inlines;
            if (inlines != null) {
                var inl = inlines[string(key[0])];
                if (inl != null)
                    return inl;
            }
        }
        return self.owner.scopesearch(key, flags);
    }
}

//*********************************************
//            Expr
//*********************************************

class Expr : CommonBase
{
    function Expr(var owner, var start)
    {
        self.initbase(start, owner);
    }
    function issimple() { return false; }
    function isliteral() { return false; }
    function isintegerliteral() { return false; }
    function isintegerzero() { return false; }
    function isfloatliteral() { return false; }
    function isstringliteral() { return false; }
    function isidentifier() { return false; }
    function isnull() { return false; }
    function hascompilevalue() { return false; }
    function isnegable() { return false; }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function optimize()
    {
        // By default return same expression unchanged
        return self;
    }
    function cantailcall() { return false; }
    function emit_init(var e, string result)
    {
        // By default does the same as plane emit, some expressions
        // can override it for optimization.
        self.emit(e, result);
    }
    function emit_get(var e)
    {
        string reg = self.tempreg(self.checkresult());
        self.emit(e, reg);
        return reg;
    }
    function emit_void(var e)
    {
        string type = self.checkresult();
        string reg;
        switch (type) {
          case REGint:    reg = DISCARD_IREG; break;
          case REGfloat:  reg = DISCARD_NREG; break;
          case REGstring: reg = DISCARD_SREG; break;
          case REGvar:    reg = DISCARD_PREG; break;
          default:
            InternalError("Unexcpected emit_void with type '" + type + "'", self.start);
        }
        self.emit(e, reg);
    }
    function emit_get_nonull(var e)
    {
        // Must be overriden by any possible null
        return self.emit_get(e);
    }
    function emit_getint(var e)
    {
        string reg = self.emit_get_nonull(e);
        if (self.checkresult() != REGint) {
            string aux = self.tempreg(REGint);
            self.annotate(e);
            e.emitset(aux, reg);
            reg = aux;
        }
        return reg;
    }
    function emit_getvar(var e)
    {
        string type = self.checkresult();
        string reg = self.emit_get(e);
        if (type != REGvar) {
            string auxreg = reg;
            reg = self.tempreg(REGvar);
            e.emitbox(reg, auxreg);
        }
        return reg;
    }
    function emit_assign_get(var e, var expr)
    {
        NoLeftSide(self);
    }
}

class SimpleExpr : Expr
{
    function issimple() { return true; }
}


class FinalExpr : Expr
// An expr crated during optimize, never parsed
{
    function optimize()
    {
        InternalError("misuse of " + string(typeof(self)), self);
    }
}

//**********************************************************************

class FunctionExpr : Expr
{
    var fn;
    function FunctionExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        if (!t.isop("("))
            Expected("anonymous function", t);
        self.fn = new LocalFunctionStatement(start, tk, owner);
    }
    function clone(var owner)
    {
        :FunctionExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.fn = self.fn.clone(owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.fn = self.fn.optimize();
        self.usesubid(self.fn.getsubid());
        return self;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        var fn = self.fn;
        string subid = fn.getsubid();
        if (fn.needclosure())
            e.emitarg2("newclosure", result, subid);
        else
            e.emitset(result, subid);
    }
    function emit_void(var e)
    {
    }
}

//*********************************************

// Condition class, contains and works with expressions used in
// conditional operators and statements.

const int CONDisruntime = 0, CONDistrue = 1, CONDisfalse = 2;

// Abstract base classes for expressions with specialized code generation
// for conditions.
class ConditionFriendlyIf
{
    function emit_if(var e, string labeltrue)
    {
        InternalError(__FUNCTION__ + " not overriden", self);
    }
}
class ConditionFriendlyElse
{
    function emit_else(var e, string labelfalse)
    {
        InternalError(__FUNCTION__ + " not overriden", self);
    }
}
class ConditionFriendlyExpr : ConditionFriendlyIf, ConditionFriendlyElse
{
}

class Condition
{
    var condexpr;
    function set(var expr)
    {
        self.condexpr = expr;
        return self;
    }
    function optimize_condition()
    {
        self.condexpr = self.condexpr.optimize();
    }
    function optimize()
    {
        self.condexpr = self.condexpr.optimize();
        return self;
    }
    function getvalue()
    {
        var condexpr = self.condexpr;
        if (condexpr.isintegerliteral())
            return condexpr.isintegerzero() ? CONDisfalse : CONDistrue;
        return CONDisruntime;
    }
    function emit_if(var e, string labeltrue, string labelfalse)
    {
        var condexpr = self.condexpr;

        if (condexpr instanceof ConditionFriendlyIf)
            condexpr.emit_if(e, labeltrue);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGstring:
              case REGint:
              case REGfloat:
                e.emitif(reg, labeltrue);
                break;
              default:
                InternalError("Invalid if condition");
            }
        }
    }
    function emit_else(var e, string labelfalse)
    {
        var condexpr = self.condexpr;

        if (condexpr instanceof ConditionFriendlyElse)
            condexpr.emit_else(e, labelfalse);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGstring:
              case REGint:
              case REGfloat:
                e.emitunless(reg, labelfalse);
                break;
              default:
                InternalError("Invalid if condition");
            }
        }
    }
}

//*********************************************

class Literal : SimpleExpr
{
    function isliteral() { return true; }
    function hascompilevalue() { return true; }
    function emit_void(var e) { }
}

//*********************************************

class IntegerLiteral : Literal
{
    var intval;
    function IntegerLiteral(var owner, var start, int value)
    {
        self.Expr(owner, start);
        self.intval = value;
    }
    function clone(var owner)
    {
        return new IntegerLiteral(owner, self.start, self.intval);
    }
    function isintegerliteral() { return true; }
    function isintegerzero()
    {
        return int(self.intval) == 0;
    }
    function checkresult() { return REGint; }
    function getIntegerValue()
    {
        return int(self.intval);
    }
    function getFloatValue()
    {
        return float(self.intval);
    }
    function getStringValue()
    {
        return string(self.intval);
    }
    function getLiteralInteger()
    {
        return self;
    }
    function getLiteralFloat()
    {
        return floatValue(self.owner, self.start, self.intval);
    }
    function getLiteralString()
    {
        return stringQuotedValue(self.owner, self.start, self.intval);
    }
    function emit(var e, string result)
    {
        int value = self.getIntegerValue();
        if (value == 0)
            e.emitnull(result);
        else
            e.emitset(result, value);
    }
    function emit_get(var e)
    {
        return self.getIntegerValue();
    }
    function emit_getint(var e)
    {
        // Just a shortcut
        return self.getIntegerValue();
    }
}

//*********************************************

class FloatLiteral : Literal
{
    var numval;
    function FloatLiteral(var owner, var start)
    {
        self.Expr(owner, start);
        self.numval = start;
    }
    function clone(var owner)
    {
        return new FloatLiteral(owner, self.numval);
    }
    function isfloatliteral() { return true; }
    function checkresult() { return REGfloat; }
    function getIntegerValue()
    {
        int ival = self.getFloatValue();
        return ival;
    }
    function getFloatValue()
    {
        float value = self.numval.getfloatvalue();
        return value;
    }
    function getStringValue()
    {
        string str = self.getFloatValue();
        return str;
    }
    function getLiteralInteger()
    {
        return integerValue(self.owner, self.start, self.getFloatValue());
    }
    function getLiteralFloat()
    {
        return self;
    }
    function getLiteralString()
    {
        return stringQuotedValue(self.owner, self.start, self.getFloatValue());
    }
    function emit(var e, string result)
    {
        string n = self.emit_get(e);
        e.emitset(result, n);
    }
    function emit_get(var e)
    {
        float value = self.getFloatValue();
        return floatAsString(value);
    }
}

//*********************************************

class StringLiteral : Literal
{
    var strval;
    function StringLiteral(var owner, var start)
    {
        self.Expr(owner, start);
        self.strval = start;
    }
    function clone(var owner)
    {
        return new StringLiteral(owner, self.strval);
    }
    function isstringliteral() { return true; }
    function checkresult() { return REGstring; }
    function getPirString()
    {
        var strtok = self.strval;
        string str = strtok.getPirString();
        return str;
    }
    function getIntegerValue()
    {
        int ival = self.getStringValue();
        return ival;
    }
    function getFloatValue()
    {
        float nval = self.getStringValue();
        return nval;
    }
    function getStringValue()
    {
        var strtok = self.strval;
        string str = strtok.str;
        if (strtok instanceof TokenQuoted)
            str = unescape(str);
        return str;
    }
    function getLiteralInteger()
    {
        return integerValue(self.owner, self.start, self.getStringValue());
    }
    function getLiteralFloat()
    {
        return floatValue(self.owner, self.start, self.getStringValue());
    }
    function getLiteralString()
    {
        return self;
    }
    function emit(var e, string result)
    {
        e.emitset(result, self.getPirString());
    }
    function emit_get(var e)
    {
        return self.getPirString();
    }
}

//*********************************************

function concat_literal(var lexpr, var rexpr)
{
    __ASSERT__(lexpr.isstringliteral());
    __ASSERT__(rexpr.isstringliteral());

    var etok = lexpr.strval;
    var rtok = rexpr.strval;
    // If both are single quoted, result is single quoted.
    // If one is double quoted, result is double quoted.
    var t = etok.issinglequoted() && rtok.issinglequoted()
        ?
        new TokenSingleQuoted(etok.file, etok.line,
                string(etok.str) + string(rtok.str))
        :
        new TokenQuoted(etok.file, etok.line,
                string(etok.getasquoted()) + string(rtok.getasquoted()));
    return new StringLiteral(lexpr.owner, t);
}

//*********************************************

class FunctionId : FinalExpr
{
    var subid;
    function FunctionId(var owner, var name, string id)
    {
        self.Expr(owner, name);
        self.subid = id;
    }
    function checkresult() { return REGvar; }
    function emitvar(var e, string result)
    {
        var name = self.start;
        var sym = self.scopesearch([name], 0);
        __ASSERT__(sym != null && (sym instanceof FunctionStatement));
        var path = sym.owner.getpath();
        self.annotate(e);
        e.emitget_hll_global(result, name, path.getparrotkey());
    }
    function emit_get(var e)
    {
        return self.subid;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        e.emitset(result, self.subid);
    }
}

class FunctionRef : FinalExpr
{
    var sym;
    function FunctionRef(var owner, var start, var sym)
    {
        self.Expr(owner, start);
        self.sym = sym;
    }
    function checkresult() { return REGvar; }
    function emit(var e, string result)
    {
        var sym = self.sym;
        var path = sym.owner.getpath();
        self.annotate(e);
        path.emit_get_global(e, self.owner, result, sym.name);
    }
}

class NullExpr : FinalExpr
{
    function NullExpr(var owner, var start)
    {
        self.Expr(owner, start);
    }
    function isnull() { return true; }
    function emit_get_nonull(var e)
    {
        SyntaxError("Invalid 'null' usage", self);
    }
    function checkresult() { return REGvar; }
    function emit_void(var e) { }
    function emit(var e, string result)
    {
        self.annotate(e);
        e.emitnull(result);
    }
}

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return true; }
    function IdentifierExpr(var owner, var name)
    {
        __ASSERT__(name instanceof TokenIdentifier);
        self.Expr(owner, name);
        self.name = name;
    }
    function clone(var owner)
    {
        return new IdentifierExpr(owner, self.name);
    }
    function isnull()
    {
        var name = self.name;
        if (self.owner.getvar(name) != null)
            return false;
        return name.iskeyword(NULL);
    }
    function emit_get_nonull(var e)
    {
        if (self.isnull())
            SyntaxError("Invalid 'null' usage", self);
        return self.emit_get(e);
    }
    function checkresult()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null)
            return desc.gettype();
        else {
            switch (name) {
              case SELF:
              case NULL:
                return REGvar;
              default:
                return "";
            }
        }
    }
    function getName()
    {
        string s = self.name;
        return s;
    }
    function checkVar()
    {
        return self.owner.getvar(string(self.name));
    }
    function checkIdentifier()
    {
        var name = self.name;
        if (name == null)
            InternalError("Bad thing");
        var desc = self.owner.getvar(name);
        string s;
        if (desc == null) {
            switch (name) {
              case SELF:
              case NULL:
                s = name; break;
              default:
                s = "";
            }
        }
        else
            s = desc.getreg();
        return s;
    }
    function getIdentifier()
    {
        var value = self.checkIdentifier();
        if (value == "")
            UndefinedVariable(self.name, self);
        return value;
    }
    function optimize()
    {
        var name = self.name;
        var owner = self.owner;
        var desc = owner.getvar(name);
        if (desc != null) {
            __ASSERT__(desc instanceof VarData);
            if (desc.isconst())
                return desc.getvalue();
            int flags = desc.getflags();
            if (flags & VAR_is_volatile) {
                if (flags & VAR_is_lexical)
                    return new LexicalVolatileExpr(self, desc);
            }
            else {
                // const Sub previous definition may be in a code path
                // not taken. Better allow redundant definitions than
                // leave undefined depending on runtime conditions.
                // TODO: improve this.
                var reg = desc.getreg();
                if (reg != null && substr(reg, 0, 7) == "WSubId_")
                    return new FunctionId(owner, name, reg);
            }
        }
        else {
            var sym = self.scopesearch([name], 0);
            switch {
              case sym == null:
                if (name.iskeyword(NULL))
                    return new NullExpr(self.owner, name);
                break;
              case sym instanceof FunctionStatement:
                if (!sym.ismulti()) {
                    string id = sym.makesubid();
                    self.usesubid(id);
                    owner.createvarnamed(name, REGvar, id);
                    return new FunctionId(owner, name, id);
                }
                else
                    return new FunctionRef(owner, name, sym);
                break;
              case sym instanceof FunctionExtern:
                return new FunctionRef(owner, name, sym);
              case sym instanceof InlineStatement:
                return new InlineRef(owner, name, sym);
            }
        }
        return self;
    }
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(var e) { }
    function emit_get(var e)
    {
        string reg;
        reg = self.getIdentifier();
        var desc = self.owner.getvar(self.name);
        int flags = desc == null ? 0 : desc.getflags();
        if (flags & VAR_is_volatile) {
            if (flags & VAR_is_lexical) {
                string lexname = desc.getlex();
                if (lexname != null)
                    self.annotate(e);
                    e.emitfind_lex(reg, lexname);
            }
        }
        return reg;
    }
    function emit_assign_get(var e, var expr)
    {
        self.annotate(e);
        if (self.isnull())
            SyntaxError("Cannot assign to null", self);
        string typeleft = self.checkresult();
        string lreg = self.getIdentifier();
        if (expr.isnull()) {
            switch (typeleft) {
              case REGstring:
              case REGvar:
                e.emitnull(lreg);
                break;
              default:
                SyntaxError("Can't assign null to that type", self);
            }
        }
        else if (expr instanceof IndexExpr)
            expr.emit(e, lreg);
        else {
            string typeright = expr.checkresult();
            if (typeright == REGnone)
                SyntaxError("Can't assign from void expression", self);
            if (typeleft == typeright) {
                expr.emit(e, lreg);
            }
            else {
                string rreg = expr.emit_get(e);
                self.annotate(e);
                if (typeleft == REGvar && typeright != REGvar)
                    e.emitbox(lreg, rreg);
                else
                    e.emitset(lreg, rreg);
            }
        }
        return lreg;
    }
}

//*********************************************

class LexicalVolatileExpr : FinalExpr
{
    var desc;
    function LexicalVolatileExpr(var idexpr, var desc)
    {
        self.Expr(idexpr.owner, idexpr.start);
        self.desc = desc;
    }
    function checkresult()
    {
        return self.desc.gettype();
    }
    function emit_get(var e)
    {
        var desc = self.desc;
        string lexname = desc.getlex();
        string reg = self.owner.tempreg(desc.gettype());
        e.emitfind_lex(reg, lexname);
        return reg;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_assign_get(var e, var expr)
    {
        var owner = self.owner;
        var desc = self.desc;
        string typelex = desc.gettype();
        string lreg;
        switch {
          case expr.isnull():
            lreg = owner.tempreg(typelex);
            e.emitnull(lreg);
            break;
          case expr instanceof IndexExpr:
            lreg = owner.tempreg(typelex);
            expr.emit(e, lreg);
            break;
          default:
            if (typelex == REGvar)
                lreg = expr.emit_getvar(e);
            else if (typelex == expr.checkresult())
                lreg = expr.emit_get(e);
            else {
                lreg = owner.tempreg(typelex);
                expr.emit(e, lreg);
            }
        }

        e.emitstore_lex(desc.getlex(), lreg);
        return lreg;
    }
    function emit_store(var e, string reg)
    {
        e.emitstore_lex(self.desc.getlex(), reg);
    }
}

//*********************************************

class OpExpr : Expr
{
    function initop(var owner, var start)
    {
        self.Expr(owner, start);
    }
}

//*********************************************

class OpNamespaceExpr : OpExpr
{
    var key;
    function OpNamespaceExpr(var tk, var owner, var start)
    {
        self.initop(owner, start);
        self.key = parseDotted(tk);
        if (elements(self.key) == 0)
            Expected("namespace identifier", start);
    }
    function checkresult() { return REGvar; }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var sym = owner.scopesearch(self.key, SEARCH_NAMESPACE);
        if (sym == null)
            SyntaxError("unknown namespace", self);
        var path = sym.getpath();
        path.emit_get_namespace(e, owner, result);
    }
}

//*********************************************

class OpClassExpr : OpExpr
{
    var clspec;

    function OpClassExpr(var tk, var owner, var start)
    {
        self.initop(owner, start);
        self.clspec = parseClassSpecifier(tk, owner);
    }
    function checkresult() { return REGvar; }
    function get_class_raw_key()
    {
        var owner = self.owner;
        var clspec = self.clspec;
        var clkey;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifierParrotKey:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifier:
            SyntaxError(string(typeof(clspec)) + " not supported yet here",
                    clspec.start);
        }
        InternalError("Unexpected class key", clspec.start);
    }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var clspec = self.clspec;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            var clkey = clspec.checknskey(owner);
            if (clkey != null) {
                clkey.emit_get_class(e, owner, result);
                return;
            }
            break;
        }

        e.print(INDENT + "get_class ", result, ", ");
        clspec.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpUnaryExpr : OpExpr
{
    var subexpr;
    function OpUnaryExpr(var owner, var start, var subexpr)
    {
        self.initop(owner, start);
        self.subexpr = subexpr;
    }
    function cloneunary(var cloned, var owner)
    {
        cloned.OpUnaryExpr(owner, self.start, self.subexpr.clone(owner));
        return cloned;
    }
    function optimizearg()
    {
        self.subexpr = self.subexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpBinaryExpr : OpExpr
{
    var lexpr;
    var rexpr;
    function initbinary(var owner, var start, var lexpr, var rexpr)
    {
        self.initop(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
    }
    function set(var owner, var t, var lexpr, var rexpr)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        return self;
    }
    function clonebinary(var cloned, var owner)
    {
        cloned.initbinary(owner, self.start,
                self.lexpr.clone(owner), self.rexpr.clone(owner));
        return cloned;
    }
    function setfrom(var from)
    {
        return self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function optimizearg()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
    function emit_intleft(var e)
    {
        return self.lexpr.emit_getint(e);
    }
    function emit_intright(var e)
    {
        return self.rexpr.emit_getint(e);
    }
}

//*********************************************

class OpBinaryIntExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = lexpr.getIntegerValue();
            int ri = rexpr.getIntegerValue();
            return integerValue(self.owner, self.start, self.do_op(li, ri));
        }
        return self;
    }
}

//*********************************************

class OpDelExBase : OpUnaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function optimize()
    {
        self.optimizearg();
        var expr = self.subexpr;
        if ((!(expr instanceof IndexExpr)) || expr.checkresult() == REGstring)
            SyntaxError("invalid operand", self);
        return self;
    }
}


class OpDeleteExpr : OpDelExBase
{
    function OpDeleteExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit_void(var e)
    {
        var expr = self.subexpr;
        expr.emit_prep(e);
        self.annotate(e);
        e.print(INDENT + "delete ");
        expr.emit_aux(e);
        e.say();
    }
    function emit(var e, string result)
    {
        self.emit_void(e);
        e.emitset(result, "1");
    }
}

class OpExistsExpr : OpDelExBase
{
    function OpExistsExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit(var e, string result)
    {
        var expr = self.subexpr;
        expr.emit_prep(e);
        self.annotate(e);
        e.print(INDENT + "exists ", result, ", ");
        expr.emit_aux(e);
        e.say();
    }
}

class OpDefinedExpr : OpDelExBase
{
    function OpDefinedExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function optimize()
    {
        self.optimizearg();
        var expr = self.subexpr;
        if (expr.checkresult() != REGvar || expr.isnull())
            SyntaxError("invalid operand", self);
        return self;
    }
    function emit(var e, string result)
    {
        var expr = self.subexpr;
        if (expr instanceof IndexExpr) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print(INDENT + "defined ", result, ", ");
            expr.emit_aux(e);
            e.say();
        }
        else {
            string reg = expr.emit_get(e);
            e.say(INDENT + " defined ", result, ", ", reg);
        }
    }
}

//*********************************************

class OpUnaryMinusExpr : OpUnaryExpr
{
    function OpUnaryMinusExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpUnaryMinusExpr, owner);
    }
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        var subexpr = self.subexpr;
        self.optimizearg();
        if (subexpr.isintegerliteral()) {
            int i = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, -i);
        }
        if (subexpr.isfloatliteral()) {
            float n = subexpr.getFloatValue();
            return floatValue(self.owner, subexpr.start, -n);
        }
        return self;
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2("neg", result, reg);
    }
}

//*********************************************

class OpNotExpr : OpUnaryExpr, ConditionFriendlyExpr
{
    function OpNotExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpNotExpr, owner);
    }
    function isnegable() { return true; }
    function checkresult()
    {
        return REGint;
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            int n = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, ! n);
        }
        if (subexpr.isnegable())
            return subexpr.negated();
        return self;
    }
    function negated()
    {
        return self.subexpr;
    }
    function emit(var e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_get(e);
        self.annotate(e);
        switch (subexpr.checkresult()) {
          case REGint:
            e.emitarg2("not", result, reg);
            break;
          case REGstring:
            // No appropiate op for string. Do it the hard way.
            e.emitset(result, 0);
            string label = self.genlabel();
            e.emitif(reg, label);
            e.emitinc(result);
            e.emitlabel(label);
            break;
          case REGvar:
            e.emitarg2("isfalse", result, reg);
            break;
          default:
            e.emitarg2("isfalse", result, reg);
        }
    }
    function emit_if(var e, string labelif)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitunless(reg, labelif);
    }
    function emit_else(var e, string labelelse)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitif(reg, labelelse);
    }
}

//*********************************************

class OpBinNotExpr : OpUnaryExpr
{
    function OpBinNotExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpBinNotExpr, owner);
    }
    function checkresult()
    {
        return REGint;
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            int n = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, ~ n);
        }
        return self;
    }
    function emit(var e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_getint(e);
        self.annotate(e);
        e.emitarg3("bxor", result, reg, -1);
    }
}

//*********************************************

class OpIncDec : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function iflexical(var e, string reg)
    {
        var expr = self.subexpr;
        if (expr instanceof LexicalVolatileExpr)
            expr.emit_store(e, reg);
    }
}

//*********************************************

class OpPreIncDec : OpIncDec
{
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_void(var e)
    {
        self.emit_get(e);
    }
}

class OpPreIncExpr : OpPreIncDec
{
    function OpPreIncExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpPreIncExpr, owner);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

class OpPreDecExpr : OpPreIncDec
{
    function OpPreDecExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpPreDecExpr, owner);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

//*********************************************

class OpPostIncExpr : OpIncDec
{
    function OpPostIncExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpPostIncExpr, owner);
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2("clone", aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2("clone", result, reg);
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
}

class OpPostDecExpr : OpIncDec
{
    function OpPostDecExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function clone(var owner)
    {
        return self.cloneunary(new OpPostDecExpr, owner);
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2("clone", aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2("clone", result, reg);
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
    }
}

//*********************************************

class OpBaseAssignExpr : Expr
{
    var lexpr;
    var rexpr;
    function set(var owner, var start, var lexpr, var rexpr)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
        return self;
    }
    function cloneassign(var cloned, var owner)
    {
        return cloned.set(owner, self.start,
                self.lexpr.clone(owner), self.rexpr.clone(owner));
    }
    function checkresult()
    {
        return self.lexpr.checkresult();
    }
    function optimize_base()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_base();
    }
    function checkleft()
    {
        var lexpr = self.lexpr;
        if (lexpr.isnull() || lexpr.isliteral())
            NoLeftSide(lexpr);
    }
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(var e)
    {
        self.emit_get(e);
    }
}

//*********************************************

class OpAssignExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpAssignExpr, owner);
    }
    function emit_get(var e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        return lexpr.emit_assign_get(e, self.rexpr);
    }
    function emit_void(var e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        lexpr.emit_assign_get(e, self.rexpr);
    }
}

//*********************************************

class OpAssignToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpAssignToExpr, owner);
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitassign(result, reg);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        if (lexpr.checkresult() != REGvar)
            SyntaxError("Wrong dest type in =:", lexpr);
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitassign(reg, reg2);
        return reg;
    }
    function emit_void(var e)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
    }
}

//*********************************************

class OpAddToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpAddToExpr, owner);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        if (ltype == REGstring && (rexpr instanceof ConcatString))
            rexpr.emit_concat_to(e, reg);
        else {
            string reg2 = rexpr.emit_get(e);
            string aux;
            self.annotate(e);
            switch (ltype) {
              case REGstring:
                if (rtype != REGstring) {
                    aux = self.tempreg(REGstring);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitconcat1(reg, reg2);
                break;
              case REGint:
              case REGfloat:
                if (ltype != rtype) {
                    aux = self.tempreg(ltype);
                    e.emitset(aux, reg2);
                    reg2 = aux;
                }
                e.emitaddto(reg, reg2);
                break;
              default:
                e.emitaddto(reg, reg2);
            }
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpSubToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpSubToExpr, owner);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        string reg2 = rexpr.emit_get(e);
        string aux;
        self.annotate(e);
        switch (ltype) {
          case REGstring:
            SyntaxError("-= can't be applied to string", self);
          case REGint:
          case REGfloat:
            if (ltype != rtype) {
                aux = self.tempreg(ltype);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitsubto(reg, reg2);
            break;
          default:
            e.emitsubto(reg, reg2);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpMulToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpMulToExpr, owner);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string lreg = lexpr.emit_get(e);
        string rreg;
        switch (lexpr.checkresult()) {
          case REGstring:
            rreg = rexpr.emit_getint(e);
            self.annotate(e);
            e.emitrepeat(lreg, lreg, rreg);
            break;
          default:
            rreg = rexpr.emit_get(e);
            self.annotate(e);
            e.emitarg2("mul", lreg, rreg);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, lreg);
        return lreg;
    }
}

//*********************************************

class OpDivToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpDivToExpr, owner);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2("div", reg, reg2);
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpModToExpr : OpBaseAssignExpr
{
    function clone(var owner)
    {
        return self.cloneassign(new OpModToExpr, owner);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2("mod", reg, reg2);
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

const int
    COMPARATOR_DEFAULT = 0,
    COMPARATOR_IF      = 1,
    COMPARATOR_ELSE    = 2;

class ComparatorBaseExpr : OpBinaryExpr, ConditionFriendlyExpr
{
    function checkresult() { return REGint; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = lexpr.getIntegerValue();
            int ri = rexpr.getIntegerValue();
            return integerValue(self.owner, self.start, self.int_op(li, ri));
        }
        return self;
    }
    function emit_comparator(var e, string result, int doifelse[optional])
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        string regl = self.lexpr.emit_get(e);
        string regr = self.rexpr.emit_get(e);
        self.annotate(e);
        string aux;
        switch {
          case rl == REGint && rr == REGfloat:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rl == REGfloat && rr == REGint:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGint && rl == REGvar:
            aux = self.tempreg(REGint);
            e.emitset( aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGint:
            aux = self.tempreg(REGint);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGfloat && rl == REGvar:
            aux = self.tempreg(REGfloat);
            e.emitset( aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGfloat:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGstring && rl == REGvar:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGstring:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regr);
            regr = aux;
            break;
        }

        switch (doifelse) {
          case COMPARATOR_DEFAULT:
            self.emitop(e, result, regl, regr);
            break;
          case COMPARATOR_IF:
            self.emitop_if(e, result, regl, regr);
            break;
          case COMPARATOR_ELSE:
            self.emitop_else(e, result, regl, regr);
            break;
        }
    }
    function emit(var e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emit_if(var e, string labeltrue)
    {
        self.emit_comparator(e, labeltrue, COMPARATOR_IF);
    }
    function emit_else(var e, string labelfalse)
    {
        self.emit_comparator(e, labelfalse, COMPARATOR_ELSE);
    }
}

//*********************************************

class Negable
{
    var positive;

    function Negable(int positive)
    {
        self.positive = new ["Boolean"](positive);
    }
    function isnegable() { return true; }
    function negated()
    {
        int positive = ! self.positive;
        self.positive =: positive;
        return self;
    }
}

//*********************************************

// Null checkers, created during optimize of Equal and NotEqual
// to simplify its emit functions.

class CheckerExpr : Expr, Negable, ConditionFriendlyExpr
{
    var expr;

    function CheckerExpr(var base, var expr, int positive)
    {
        self.Expr(base.owner, base.start);
        self.Negable(positive);
        self.expr = expr;
    }
    function isnegable() { return true; }
    function checkresult() { return REGint; }
}

class NullCheckerExpr : CheckerExpr
{
    function NullCheckerExpr(var base, var expr, int checknull)
    {
        self.CheckerExpr(base, expr, checknull);
    }
    function emit(var e, string result)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        e.emitarg2("isnull", result, reg);
        if (! self.positive)
            e.emitarg1("not", result);
    }
    function emit_if(var e, string labelif)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitif_null(reg, labelif);
        else
            e.emitunless_null(reg, labelif);
    }
    function emit_else(var e, string labelelse)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless_null(reg, labelelse);
        else
            e.emitif_null(reg, labelelse);
    }
}

class ZeroCheckerExpr : CheckerExpr
{
    function ZeroCheckerExpr(var base, var expr, int positive)
    {
        self.CheckerExpr(base, expr, positive);
    }
    function emit(var e, string result)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitarg3("iseq", result, reg, 0);
        else
            e.emitarg3("isne", result, reg, 0);
    }
    function emit_if(var e, string labelif)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless(reg, labelif);
        else
            e.emitif(reg, labelif);
    }
    function emit_else(var e, string labelelse)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitif(reg, labelelse);
        else
            e.emitunless(reg, labelelse);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr, Negable
{
    function OpEqualExpr(var owner, var start, var lexpr, var rexpr, int positive)
    {
        self.set(owner, start, lexpr, rexpr);
        self.Negable(positive);
    }
    function clone(var owner)
    {
        var cloned = self.clonebinary(new OpEqualExpr, owner);
        cloned.Negable(self.positive);
        return cloned;
    }
    function isnegable() { return true; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        int lnull = lexpr.isnull();
        int rnull = rexpr.isnull();
        switch {
          case lnull && rnull:
            return integerValue(self.owner, self.start, self.positive);
          case lnull:
            return new NullCheckerExpr(self, rexpr, self.positive);
          case rnull:
            return new NullCheckerExpr(self, lexpr, self.positive);
        }
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            switch {
              case ltype == REGint && rtype == REGint:
                int li = lexpr.getIntegerValue();
                int ri = rexpr.getIntegerValue();
                int vi = self.positive ? li == ri : li != ri;
                return integerValue(self.owner, self.start, vi);
              case ltype == REGfloat && rtype == REGfloat:
              case ltype == REGfloat && rtype == REGint:
              case ltype == REGint   && rtype == REGfloat:
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                int vf = self.positive ? lf == rf : lf != rf;
                return integerValue(self.owner, self.start, vf);
              case ltype == REGstring && rtype == REGstring:
                string ls = (lexpr.strval).str;
                string rs = (rexpr.strval).str;
                int vs = self.positive ? ls == rs : ls != rs;
                return integerValue(self.owner, self.start, vs);
            }
        }
        if (rexpr.isintegerzero())
            return new ZeroCheckerExpr(self, lexpr, self.positive);
        if (lexpr.isintegerzero())
            return new ZeroCheckerExpr(self, rexpr, self.positive);
        return self;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        self.annotate(e);
        e.emitbinop(self.positive ? "iseq" : "isne", result, regl, regr);
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        self.emit_comparator(e, result);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? "eq" : "ne", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? "ne" : "eq", regl, regr, labelelse);
    }
}


//**********************************************************************

class OpSameExpr : ComparatorBaseExpr, Negable
{
    var positive;
    function OpSameExpr(var owner, var t, var lexpr, var rexpr, int positive)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        self.Negable(positive);
    }
    function clone(var owner)
    {
        var cloned = self.clonebinary(new OpSameExpr, owner);
        cloned.Negable(self.positive);
        return cloned;
    }
    function isnegable() { return true; }
    function int_op(int left, int right)
    {
        return self.positive ? (left == right) : (left != right);
    }
    function emitop(var e, string result, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "issame" : "isntsame";
        e.emitbinop(op, result, regl, regr);
    }
    function emit(var e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "eq_addr" : "ne_addr";
        e.emitcompare(op, regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "ne_addr" : "eq_addr";
        e.emitcompare(op, regl, regr, labelelse);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function clone(var owner)
    {
        return self.clonebinary(new OpLessExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left < right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("islt", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("lt", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("ge", regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function clone(var owner)
    {
        return self.clonebinary(new OpGreaterExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left > right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isgt", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("gt", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("le", regl, regr, labelelse);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function clone(var owner)
    {
        return self.clonebinary(new OpLessEqualExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left <= right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isle", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("le", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("gt", regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function clone(var owner)
    {
        return self.clonebinary(new OpGreaterEqualExpr, owner);
    }
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left >= right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isge", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("ge", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("lt", regl, regr, labelelse);
    }
}

//*********************************************

class OpBaseBoolExpr : OpBinaryExpr
{
    function checkresult()
    {
        return self.lexpr.checkresult() == REGint && self.rexpr.checkresult() == REGint ?
            REGint : REGvar;
    }
}

//*********************************************

class OpBoolAndExpr : OpBaseBoolExpr, ConditionFriendlyElse
{
    function OpBoolAndExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpBoolAndExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln != 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("and", result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitunless(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(var e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("and", DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitunless(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
    function emit_else(var e, string labelelse)
    {
        var lexpr = self.lexpr;
        if (lexpr instanceof ConditionFriendlyElse)
            lexpr.emit_else(e, labelelse);
        else {
            string lreg = lexpr.emit_get(e);
            e.emitunless(lreg, labelelse);
        }
        var rexpr = self.rexpr;
        if (rexpr instanceof ConditionFriendlyElse)
            rexpr.emit_else(e, labelelse);
        else {
            string rreg = rexpr.emit_get(e);
            e.emitunless(rreg, labelelse);
        }
    }
}

//*********************************************

class OpBoolOrExpr : OpBaseBoolExpr
{
    function OpBoolOrExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpBoolOrExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln == 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("or", result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitif(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(var e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("or", DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitif(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
}

//*********************************************

class OpBaseBinExpr : OpBinaryIntExpr
{
}

//*********************************************

class OpBinAndExpr : OpBaseBinExpr
{
    function OpBinAndExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpBinAndExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("band", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left & right;
    }
}

//*********************************************

class OpBinOrExpr : OpBaseBinExpr
{
    function OpBinOrExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpBinOrExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("bor", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left | right;
    }
}

//*********************************************

class OpBinXorExpr : OpBaseBinExpr
{
    function OpBinXorExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpBinXorExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("bxor", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left ^ right;
    }
}

//*********************************************

class ConcatString : FinalExpr
{
    var values;
    function ConcatString(var owner, var start, var lexpr, var rexpr)
    {
        self.Expr(owner, start);
        switch {
          case lexpr instanceof ConcatString:
            self.values = lexpr.values;
            if (rexpr instanceof ConcatString)
                self.append(rexpr.values);
            else
                self.pushexpr(rexpr);
            break;
          case rexpr instanceof ConcatString:
            self.values = rexpr.values;
            self.unshiftexpr(lexpr);
            break;
          default:
            self.values = [lexpr, rexpr];
        }
    }
    function pushexpr(var rexpr)
    {
        var values = self.values;
        var last = values[-1];
        if (last.isstringliteral() && rexpr.isstringliteral())
            values[-1] = concat_literal(last, rexpr);
        else
            push(values, rexpr);
    }
    function unshiftexpr(var lexpr)
    {
        var values = self.values;
        var first = values[0];
        if (first.isstringliteral() && lexpr.isstringliteral())
            values[0] = concat_literal(lexpr, first);
        else
            unshift(values, lexpr);
    }
    function append(var rvalues)
    {
        var values = self.values;
        var last = values[-1];
        if (last.isstringliteral()) {
            var first = rvalues[0];
            if (first.isstringliteral()) {
                values[-1] = concat_literal(last, first);
                rvalues.shift();
            }
        }
        values.append(rvalues);
    }

    function checkresult() { return REGstring; }
    function getregs(var e)
    {
        var values = self.values;
        int nvalues = elements(values);
        string regvalues[nvalues];
        for (int i = 0; i < nvalues; ++i)
            regvalues[i] = string(values[i].emit_get(e));
        return regvalues;
    }
    function emit(var e, string result)
    {
        string auxreg = self.emit_get(e);
        e.emitset(result, auxreg);
    }
    function emit_get(var e)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        string auxreg = self.tempreg(REGstring);
        self.annotate(e);
        e.emitconcat(auxreg, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(auxreg, regvalues[i]);
        return auxreg;
    }
    function emit_init(var e, string result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        e.emitconcat(result, regvalues[0], regvalues[1]);
        for (int i = 2; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
    function emit_concat_to(var e, string result)
    {
        var regvalues = self.getregs(e);
        int nvalues = elements(regvalues);
        self.annotate(e);
        for (int i = 0; i < nvalues; ++i)
            e.emitconcat1(result, regvalues[i]);
    }
}

//*********************************************

class RepeatString : OpBinaryExpr
{
    function RepeatString(var from)
    {
        self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function checkresult() { return REGstring; }
    function emit(var e, string result)
    {
        var rexpr = self.rexpr;
        string lreg = self.lexpr.emit_get(e);
        string rreg = rexpr.emit_getint(e);
        self.annotate(e);
        e.emitrepeat(result, lreg, rreg);
    }
}

//*********************************************

class OpAddExpr : OpBinaryExpr
{
    function OpAddExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpAddExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGstring && rtype == REGstring)
                return concat_literal(lexpr, rexpr);
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln + rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                return floatValue(self.owner, self.start, lf + rf);
            }
        }
        if (ltype == REGstring && rtype == REGstring) {
            return new ConcatString(self.owner, self.start, lexpr, rexpr);
        }
        return self;
    }
    function checkresult()
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGint && rr == REGstring)
            return REGstring;
        if (rl == REGstring && rr == REGint)
            return REGstring;
        if (floatresult(rl, rr))
            return REGfloat;
        return REGint;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string restype = self.checkresult();
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();

        string rleft = lexpr.emit_get(e);
        string rright = rexpr.emit_get(e);
        if (restype == REGstring) {
            if (ltype != REGstring || rtype != REGstring) {
                string aux = self.tempreg(REGstring);
                if (ltype != REGstring) {
                    e.emitset(aux, rleft);
                    rleft = aux;
                }
                else {
                    e.emitset(aux, rright);
                    rright = aux;
                }
            }
            e.emitconcat(result, rleft, rright);
        }
        else {
            if (restype == REGint && (ltype != REGint || rtype != REGint)) {
                string l;
                if (ltype == REGint) l = rleft;
                else {
                    l = self.tempreg(REGint);
                    e.emitset(l, rleft);
                }
                string r;
                if (rtype == REGint) r = rright;
                else {
                    r = self.tempreg(REGint);
                    e.emitset(r, rright);
                }
                e.emitadd(result, l, r);
            }
            else
                e.emitadd(result, rleft, rright);
        }
    }
}

//*********************************************

class OpSubExpr : OpBinaryExpr
{
    function OpSubExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpSubExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln - rn);
            }
        }
        return self;
    }
    function checkresult()
    {
        string ltype = self.lexpr.checkresult();
        string rtype = self.rexpr.checkresult();
        switch {
          case ltype == rtype:
            return ltype;
          case ltype == REGvar || rtype == REGvar:
            return REGvar;
          case ltype == REGint && rtype == REGfloat:
            return REGfloat;
          case ltype == REGfloat && rtype == REGint:
            return REGfloat;
          default:
            return REGint;
        }
    }
    function emit(var e, string result)
    {
        string type = self.checkresult();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg = lexpr.emit_get(e);
        string rreg = rexpr.emit_get(e);
        string aux;
        if (ltype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, lreg);
            else
                e.emitset(aux, lreg);
            lreg = aux;
        }
        if (rtype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, rreg);
            else
                e.emitset(aux, rreg);
            rreg = aux;
        }
        e.emitsub(result, lreg, rreg);
    }
}

//*********************************************

class OpMulExpr : OpBinaryExpr
{
    function OpMulExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpMulExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln * rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                return floatValue(self.owner, self.start, lf * rf);
            }
        }
        if (ltype == REGstring)
            return new RepeatString(self);
        return self;
    }
    function checkresult()
    {
        var lexpr = self.lexpr;
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGstring)
            return REGstring;
        else
            return REGfloat;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg, rreg;
        if (ltype == rtype && (ltype == REGint || ltype == REGfloat || ltype == REGvar)) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            e.emitmul(result, lreg, rreg);
            return;
        }

        // Quick fix for some float mul
        // TODO: rewrite this mess
        if (ltype == REGfloat) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            string rval;
            switch (rtype) {
              case REGint:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
                rval = rreg;
                break;
              case REGfloat:
                rval = rreg;
                break;
              default:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
            }
            self.annotate(e);
            e.emitmul(result, lreg, rval);
            return;
        }

        int nleft, nright;
        if ((!lexpr.issimple()) || lexpr.isidentifier()) {
            lreg = self.tempreg(self.checkresult());
            lexpr.emit(e, lreg);
        }
        else {
            nleft = lexpr.getIntegerValue();
            lreg = nleft;
        }
        if ((!rexpr.issimple()) || rexpr.isidentifier()) {
            rreg = self.tempreg(self.checkresult());
            rexpr.emit(e, rreg);
        }
        else {
            switch (rtype) {
              case REGstring:
                rreg = self.tempreg(self.checkresult());
                rexpr.emit(e, rreg);
                break;
              case REGfloat:
                rreg = rexpr.emit_get(e);
                break;
              case REGint:
              default:
                nright = rexpr.getIntegerValue();
                rreg = nright;
                break;
            }
        }
        self.annotate(e);
        e.emitmul(result, lreg, rreg);
    }
}

//*********************************************

class OpDivExpr : OpBinaryExpr
{
    function OpDivExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpDivExpr, owner);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            var lval;
            var rval;
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                if (rn != 0)
                    return floatValue(self.owner, self.start, ln / rn);
            }
            if (floatresult(ltype, rtype)) {
                float lf = lexpr.getFloatValue();
                float rf = rexpr.getFloatValue();
                if (rf != 0)
                    return floatValue(self.owner, self.start, lf / rf);
            }
        }
        return self;
    }
    function checkresult()
    {
        return REGfloat;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var aux;
        var lreg = lexpr.emit_get(e);
        if (lexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, lreg);
            lreg = aux;
        }
        var rexpr = self.rexpr;
        var rreg = rexpr.emit_get(e);
        if (rexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, rreg);
            rreg = aux;
        }
        self.annotate(e);
        e.emitdiv(result, lreg, rreg);
    }
}

//*********************************************

class OpModExpr : OpBinaryIntExpr
{
    function OpModExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpModExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("mod", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left % right;
    }
}

//*********************************************

class OpCModExpr : OpBinaryExpr
{
    function OpCModExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpCModExpr, owner);
    }
    function checkresult()
    {
        return REGint;
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);

        // WORKAROUND:
        // e.say("cmod ", result, ", ", lreg, ", ", rreg);
        // cmod is now a dynop. Silly workaround, use mod instead.
        e.emitbinop("mod", result, lreg, rreg);
    }
}

//*********************************************

class OpShiftleftExpr : OpBinaryIntExpr
{
    function OpShiftleftExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpShiftleftExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("shl", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left << right;
    }
}

//*********************************************

class OpShiftrightExpr : OpBinaryIntExpr
{
    function OpShiftrightExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpShiftrightExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("shr", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left >> right;
    }
}

//*********************************************

class OpShiftlrightExpr : OpBinaryIntExpr
{
    function OpShiftlrightExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function clone(var owner)
    {
        return self.clonebinary(new OpShiftlrightExpr, owner);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("lsr", result, lreg, rreg);
    }
    function do_op(int left, int right)
    {
        return left >>> right;
    }
}

//*********************************************

class ArgumentModifierList : ModifierList
{
    function ArgumentModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function clone(var owner)
    {
        :ArgumentModifierList cloned;
        cloned.list = self.clonemodifiers(owner);
        return cloned;
    }
    function emitmodifiers(var e)
    {
        int isflat = false, isnamed = false;
        string setname = "";
        for (var modif in self.getlist()) {
            switch (modif.getname()) {
              case "flat":
                isflat = true;
                break;
              case "named":
                isnamed = true;
                switch (modif.numargs()) {
                  case 0:
                    break;
                  case 1:
                    var argmod = modif.getarg(0);
                    if (! argmod.isstringliteral())
                        SyntaxError("Invalid modifier", argmod);
                    setname = argmod.getPirString();
                    break;
                  default:
                    SyntaxError("Invalid modifier", argmod);
                }
            }
        }
        switch {
          case isflat && isnamed:
            e.print(" :flat :named");
            break;
          case isflat:
            e.print(" :flat");
            break;
          case isnamed:
            e.print(" :named");
            if (setname != "")
                e.print("(", setname, ")");
            break;
        }
    }
}

class Argument
{
    var arg;
    var modifiers;
    function Argument(var arg, var modifiers)
    {
        self.arg = arg;
        self.modifiers = modifiers;
    }
    function clone(var owner)
    {
        :Argument cloned;
        cloned.arg = self.arg.clone(owner);
        if (self.modifiers != null)
            cloned.modifiers = self.modifiers.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.arg = self.arg.optimize();
        if (self.modifiers != null)
            self.modifiers.optimize();
        return self;
    }
    function hascompilevalue()
    {
        return self.arg.hascompilevalue();
    }
}

function parseArgument(var tk, var owner)
{
    var modifier = null;
    var expr = parseExpr(tk, owner);
    var t = tk.get();
    if (t.isop(":")) {
        t = tk.get();
        if (t.isop("[")) {
            modifier = new ArgumentModifierList(tk, owner);
        }
        else
            Expected("modifier list", t);
    }
    else
        tk.unget(t);
    return new Argument(expr, modifier);
}

class ArgumentList
{
    var owner;
    var start;
    var args;
    var argregs;

    function ArgumentList(var owner, var start, var tk, string delimiter)
    {
        self.owner = owner;
        self.start = start;
        self.args = parseListOrEmpty(tk, owner, parseArgument, delimiter);
    }
    function clone(var owner)
    {
        :ArgumentList cloned;
        cloned.owner = owner;
        cloned.start = self.start;
        var args = self.args;
        if (args != null)
            cloned.args = clone_array(args, owner);
        return cloned;
    }
    function numargs()
    {
        var args = self.args;
        return args == null ? 0 : elements(args);
    }
    function getrawargs()
    {
        return self.args;
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }
    function getfreearg(int i)
    {
        var args = self.args;
        return args[i].arg;
    }
    function optimize()
    {
        optimize_array(self.args);
        return self;
    }
    function getargvalues(var e)
    {
        var argregs = self.argregs;
        if (argregs == null) {
            string argregs[];
            :CollectValues collect(self.owner, e);
            for (var argitem in self.args) {
                string reg = collect.add(argitem.arg);
                push(argregs, reg);
            }
            self.argregs = argregs;
        }
        return argregs;
    }
    function emitargs(var e)
    {
        var args = self.args;
        var argreg = self.getargvalues(e);

        string sep = "";
        int n = self.numargs();
        for (int i = 0; i < n; ++i) {
            e.print(sep, argreg[i]);
            var modifiers = args[i].modifiers;
            if (modifiers != null)
                modifiers.emitmodifiers(e);
            sep = ", ";
        }
    }
}

function arglist_hascompilevalue(var arglist)
{
    for (var arg in arglist)
        if (! arg.hascompilevalue())
            return false;
    return true;
}

//*********************************************
//           Builtin typecasts
//*********************************************

class CastExpr : FinalExpr
{
    var arg;
    var type;
    function CastExpr(var owner, var start, var arg, string type)
    {
        self.Expr(owner, start);
        self.arg = arg;
        self.type = type;
    }
    function emit(var e, string result)
    {
        var arg = self.arg;
        string type = self.type;
        string argtype = arg.checkresult();
        switch {
          case arg instanceof IndexExpr:
          case arg instanceof CallExpr:
          case argtype == type:
            arg.emit(e, result);
            break;
          case arg.isnull():
            e.emitnull(result);
            break;
          default:
            string aux = arg.emit_get(e);
            e.emitset(result, aux);
        }
    }
}

class IntCastExpr : CastExpr
{
    function IntCastExpr(var owner, var start, var arg)
    {
        self.CastExpr(owner, start, arg, REGint);
    }
    function checkresult() { return REGint; }
}

class FloatCastExpr : CastExpr
{
    function FloatCastExpr(var owner, var start, var arg)
    {
        self.CastExpr(owner, start, arg, REGfloat);
    }
    function checkresult() { return REGfloat; }
}

class StringCastExpr : CastExpr
{
    function StringCastExpr(var owner, var start, var arg)
    {
        self.CastExpr(owner, start, arg, REGstring);
    }
    function checkresult() { return REGstring; }
}

class BoxExpr : FinalExpr
{
    var arg;
    function BoxExpr(var owner, var start, var arg)
    {
        self.Expr(owner, start);
        self.arg = arg;
    }
    function checkresult() { return REGvar; }
    function emit(var e, string result)
    {
        var arg = self.arg;
        string reg = arg.emit_get(e);
        self.annotate(e);
        e.emitbox(result, reg);
    }
}

class VarCastExpr : FinalExpr
{
    var arg;
    function VarCastExpr(var owner, var start, var arg)
    {
        self.Expr(owner, start);
        self.arg = arg;
    }
    function checkresult() { return REGvar; }
    function emit(var e, string result)
    {
        var arg = self.arg;
        string argtype = arg.checkresult();
        var sym;
        switch {
          case arg instanceof FunctionId:
            arg.emitvar(e, result);
            break;
          case arg instanceof IdentifierExpr:
            string idname = arg.getName();
            string id = arg.checkIdentifier();
            var desc = arg.checkVar();
            if (id != "" && desc != null && ! desc.issubid()) {
                // The cast is redundant in this case
                arg.emit(e, result);
            }
            else {
                sym = arg.scopesearch([idname], 0);
                if (sym != null && sym instanceof FunctionStatement) {
                    var path = sym.owner.getpath();
                    self.annotate(e);
                    e.emitget_hll_global(result, idname, getparrotkey(path));
                }
            }
            break;
          case arg instanceof MemberExpr:
            // If it's a known function avoid using it bt subid,
            // else, look up in the hll namespace at runtime.
            string key[];
            arg.buildkey(key);
            sym = self.owner.scopesearch(key, 0);
            if (sym != null && sym instanceof FunctionStatement) {
                var path = sym.owner.getpath();
                string funname = sym.name.getidentifier();
                self.annotate(e);
                e.emitget_hll_global(result, funname, path.getparrotkey());
            }
            else {
                if (key[0] == SELF && self.owner.getouter().ismethod()) {
                    // Special case for self in methods:
                    // var(self.f)(); gives the same result as
                    // var temp = self.f; temp();
                    // instead of a method call.
                    arg.emit(e, result);
                }
                else {
                    string varname = key.pop();
                    self.annotate(e);
                    e.emitget_hll_global(result, varname, getparrotkey(key));
                }
            }
            break;
          default:
            self.annotate(e);
            arg.emit(e, result);
        }
    }
}


function builtinexpr_intcast(var owner, var start, var args)
{
    __ASSERT__(args.numargs() == 1);
    var arg = args.getarg(0).arg;
    if (arg.hascompilevalue())
        return integerValue(owner, start, int_from_literal(arg));
    else
        return new IntCastExpr(owner, start, arg);
}

function builtinexpr_floatcast(var owner, var start, var args)
{
    __ASSERT__(args.numargs() == 1);
    var arg = args.getarg(0).arg;
    if (arg.hascompilevalue())
        return floatValue(owner, start, float_from_literal(arg));
    else
        return new FloatCastExpr(owner, start, arg);
}

function builtinexpr_stringcast(var owner, var start, var args)
{
    __ASSERT__(args.numargs() == 1);
    var arg = args.getarg(0).arg;
    if (arg.hascompilevalue())
        return stringQuotedValue(owner, start, string_from_literal(arg));
    else
        return new StringCastExpr(owner, start, arg);
}

function builtinexpr_varcast(var owner, var start, var args)
{
    __ASSERT__(args.numargs() == 1);
    var arg = args.getarg(0).arg;
    string argtype = arg.checkresult();
    switch (argtype) {
      case REGint:
      case REGfloat:
      case REGstring:
        return new BoxExpr(owner, start, arg);
      default:
        return new VarCastExpr(owner, start, arg);
    }
}

//*********************************************

class CallBuiltinExpr : FinalExpr
{
    var builtin;
    var args;

    function CallBuiltinExpr(var owner, var start, var builtin, var args)
    {
        self.Expr(owner, start);
        self.builtin = builtin;
        self.args = args;
    }
    function checkresult()
    {
        string result = self.builtin.result();
        if (result == REGsame)
            result = self.args[0].arg.checkresult();
        return result;
    }
    function emit_void(var e)
    {
        self.emit(e, "");
    }
    function emit_get(var e)
    {
        string type = self.checkresult();
        switch (type)
        {
          case REGint: case REGfloat: case REGstring: case REGvar:
            break;
          case REGnone:
            SyntaxError("Can't use result of a void builtin", self);
          default:
            InternalError("Unexpected result type '" + type + "'", self);
        }
        string reg = self.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var start = self.start;
        var builtin = self.builtin;
        var args = self.args;
        string argreg[];
        var arg;
        switch (builtin.params()) {
          case BULTIN_arglist:
            :CollectValues collectarglist(owner, e);
            for (arg in args)
                push(argreg, collectarglist.add(arg.arg));
            break;
          case BULTIN_raw1:
            var rawargs = [];
            for (arg in args)
                push(rawargs, arg.arg);
            builtin.expand(e, owner, start, result, rawargs);
            return;
          default:
            int n = elements(args);
            :CollectValues collectdefault(owner, e);
            for (int i = 0; i < n; ++i) {
                arg = args[i].arg;
                string argtype = arg.checkresult();
                string paramtype = builtin.paramtype(i);
                string argr;
                if (arg.isnull()) {
                    switch (paramtype) {
                      case REGint:
                      case REGfloat:
                      case REGstring:
                        argr = self.tempreg(paramtype);
                        e.emitnull(argr);
                        break;
                      default:
                        argr = collectdefault.add(arg);
                    }
                }
                else {
                    if (argtype == paramtype || paramtype == REGany ||
                            (paramtype == REGs_v &&
                             (argtype == REGstring || argtype == REGvar)))
                        argr = arg.emit_get(e);
                    else {
                        if (paramtype == REGs_v)
                            paramtype = REGvar;
                        string aux = arg.emit_get(e);
                        switch (paramtype) {
                          case REGvar:
                            switch (argtype) {
                              case REGint:
                              case REGfloat:
                              case REGstring:
                                argr = self.tempreg(paramtype);
                                e.emitbox(argr, aux);
                                break;
                              default:
                                argr = aux;
                            }
                            break;
                          case REGint:
                          case REGfloat:
                          case REGstring:
                            argr = self.tempreg(paramtype);
                            e.emitset(argr, aux);
                            break;
                          default:
                            argr = aux;
                        }
                    }
                }
                push(argreg, argr);
            }
        }
        builtin.expand(e, owner, start, result, argreg);
    }
}

//*********************************************

function gencallbuiltin(var owner, var start, var builtin, var args)
{
    var name = builtin.getname();
    string callname = name.getidentifier();
    owner.use_builtin(callname);
    int nargs = args == null ? 0 : args.numargs();
    var rawargs = nargs == 0 ? [] : args.getrawargs();

    var variants = builtin.variants;
    var variant;
    for (var v in variants) {
        int vargs = v.nparams;
        if (vargs == nargs ||
                vargs == BULTIN_arglist ||
                (vargs == BULTIN_raw1 && nargs == 1))
            variant = v;
    }
    if (variant == null)
        SyntaxError("Wrong arguments for builtin", start);

    if (variant.isreplaceexpr())
        return variant.replaceexpr(owner, start, args);

    // Check for compile time evaluation.
    if (variant.iscompileevaluable()) {
        if (arglist_hascompilevalue(rawargs)) {
            var evalfun = variant.evalfun;
            try {
                return evalfun(owner.owner, owner.start, rawargs);
            }
            catch (ex) {
                SyntaxError("Compile time evaluation of builtin " + callname +
                        " failed: '" + string(ex["message"]) + "'", start);
            }
        }
    }

    return new CallBuiltinExpr(owner, start, variant, rawargs);
}

class CallExpr : Expr
{
    var funref;
    var args;

    function CallExpr(var tk, var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.funref = subexpr;
        var t = tk.get();
        if (! t.isop(")")) {
            tk.unget(t);
            self.args = new ArgumentList(owner, start, tk, ")");
        }
    }
    function clone(var owner)
    {
        :CallExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.funref = self.funref.clone(owner);
        var args = self.args;
        if (args != null)
            cloned.args = args.clone(owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        var funref = self.funref.optimize();
        self.funref = funref;
        var args = self.args;
        if (args != null)
            self.args = args = args.optimize();
        var owner = self.owner;

        if (funref instanceof MemberExpr) {
            var sym = funref.search_nonmember();
            var start = self.start;
            switch {
              case sym == null:
                return new CallMemberExpr(self, funref, args);
              case sym instanceof FunctionStatement:
                if (!sym.ismulti()) {
                    string subid = sym.makesubid();
                    self.usesubid(subid);
                    return new CallSubid(self, funref, args, subid);
                }
                else {
                    self.funref = new FunctionRef(owner, start, sym);
                    return self;
                }
                break;
              case sym instanceof FunctionExtern:
                self.funref = new FunctionRef(owner, start, sym);
                return self;
              case sym instanceof Builtin:
                return gencallbuiltin(owner, funref.start, sym, args);
                break;
              default:
                InternalError("unexpected type found in scope", start);
            }
        }
        if (funref instanceof MemberRefExpr)
            return new CallMemberRefExpr(self, funref, args);
        if (funref instanceof InlineRef)
            return new CallInlineExpr(owner, funref, args);

        // Check for bultins
        if (funref.isidentifier()) {
            if (funref.checkIdentifier() == "") {
                var sym = self.scopesearch([ funref.getName() ], 0);
                if (sym != null && sym instanceof Builtin)
                    return gencallbuiltin(owner, funref.start, sym, args);
            }
        }

        return self;
    }
    function cantailcall()
    {
        return true;
    }
    function emitcall(var e)
    {
        var funref = self.funref;
        string call;

        if (funref.isidentifier()/* && funref.subid == null*/) {
            call = funref.checkIdentifier();
            if (call == "") {
                var sym = self.scopesearch([ funref.getName() ], 0);
                switch {
                  case sym == null:
                    call = join("", [ "'", funref.getName(), "'" ] );
                    break;
                  case sym instanceof FunctionExtern:
                    call = sym.emit_get(e, self);
                    break;
                  case sym instanceof Builtin:
                    InternalError("Builtin unexpected here", self);
                  default:
                    call = join("", [ "'", funref.getName(), "'" ] );
                }
            }
        }
        else
            call = funref.emit_get(e);
        return call;
    }
    function prepareargs(var e)
    {
        var args = self.args;
        if (args != null)
            args.getargvalues(e);
    }
    function emitargs(var e)
    {
        e.print("(");
        var args = self.args;
        if (args != null)
            args.emitargs(e);
        e.say(")");
    }
    function emit(var e, string result)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);

        self.annotate(e);

        e.print(INDENT);
        if (result == ".tailcall")
            e.print(".tailcall ");
        else
            e.print(result, " = ");

        e.print(call);
        self.emitargs(e);
    }
    function emit_void(var e)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);
        self.annotate(e);
        e.print(INDENT);
        e.print(call);
        self.emitargs(e);
    }
}

//*********************************************

// CallExpr variants. Always created from CallExpr, never directly.

class CallSubid : CallExpr
{
    var subid;
    function CallSubid(var callst, var funref, var args, string subid)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
        self.subid = subid;
    }
    function emitcall(var e)
    {
        return self.subid;
    }
}

// Method call by name.
class CallMemberExpr : CallExpr
{
    function CallMemberExpr(var callst, var funref, var args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(var e)
    {
        var funref = self.funref;

        var first = funref.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first.isidentifier()) {
            string check = first.checkIdentifier();
            if (check == null || check == "") {
                // The other usages are covered in other conditions,
                // here we have a qualified symbol not found in scope,
                // assume is function in a namespace not declared here.
                string key[];
                funref.buildkey(key);
                string fun = key.pop();
                var reg = self.tempreg(REGvar);
                self.annotate(e);
                e.emitget_hll_global(reg, fun, getparrotkey(key));
                return reg;
            }
        }
        return join("", [ funref.emit_left_get(e),
                ".'", funref.get_member(), "'" ] );
    }
}

// Method call by reference.
// The reference is a expression, its result must be a var containing a
// invokable or a string with the method name.
class CallMemberRefExpr : CallExpr
{
    function CallMemberRefExpr(var callst, var funref, var args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(var e)
    {
        var funref = self.funref;
        var right = funref.right;
        var type = right.checkresult();
        if (type != REGvar && type != REGstring)
            SyntaxError("Invalid expression type in '.*'", funref);
        // We want a well defined order of evaluation here, so use variables
        // to store intermediate results.
        string lreg = funref.emit_left_get(e);
        string rreg = right.emit_get(e);
        return lreg + "." + rreg;
    }
}

//*********************************************

class MemberExprBase : Expr
{
    var left;
    function MemberExprBase(var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.left = subexpr;
    }
    function emit_left_get(var e)
    {
        return self.left.emit_getvar(e);
    }
}

class MemberExpr : MemberExprBase
{
    var right;

    function MemberExpr(var owner, var start, var subexpr, var right)
    {
        self.MemberExprBase(owner, start, subexpr);
        self.right = right;
    }
    function clone(var owner)
    {
        :MemberExpr cloned;
        cloned.MemberExprBase(owner, self.start, self.left.clone(owner));
        cloned.right = self.right;
        return cloned;
    }
    function checkresult() { return REGvar; }
    function search_nonmember()
    {
        // Check if the first element of the member expression
        // is an identfier. In that case, if it's not in scope
        // look for a function in accessible namespaces.
        var sym;
        var first = self.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first instanceof IdentifierExpr) {
            var idfirst = first.checkIdentifier();
            if (idfirst == null || idfirst == "") {
                var key = [ ];
                self.buildkey(key);
                return self.scopesearch(key, 0);
            }
        }
        return null;
    }
    function optimize()
    {
        self.left = self.left.optimize();

        var sym = self.search_nonmember();
        switch {
          case sym == null:
            break;
          case sym instanceof FunctionStatement:
            if (sym.ismulti())
              return new FunctionRef(self.owner, self.start, sym);
            break;
          case sym instanceof FunctionExtern:
            return new FunctionRef(self.owner, self.start, sym);
          case (sym instanceof VarData) && sym.isconst():
            return sym.getvalue();
        }
        return self;
    }
    function buildkey(var key)
    {
        var left = self.left;
        if (left instanceof IdentifierExpr)
            push(key, left.getName());
        else
            left.buildkey(key);
        push(key, self.right.getidentifier());
    }
    function get_member()
    {
        return self.right;
    }
    function __emit_get_left(var e)
    {
        var left = self.left;
        if (left.checkresult() != REGvar)
            SyntaxError("non-var at left of '.'", self);
        return left.emit_get_nonull(e);
    }
    function emit_get(var e)
    {
        string result = self.tempreg(REGvar);
        self.emit(e, result);
        return result;
    }
    function emit(var e, string result)
    {
        string obj = self.__emit_get_left(e);
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, "getattribute ", result, ", ", obj, ", '", ident, "'");
    }
    function emit_assign_get(var e, var expr)
    {
        string obj = self.__emit_get_left(e);
        string value = self.tempreg(REGvar);
        if (expr.isnull())
            e.emitnull(value);
        else {
            string rreg = expr.emit_get(e);
            if (expr.checkresult() != REGvar)
                e.emitbox(value, rreg);
            else
                value = rreg;
        }
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, "setattribute ", obj, ", '", ident, "', ", value);
        return value;
    }
}

// Member dereference via a var or string expresion.
// When used for method calls is handled by CallMemberRefExpr.
// For attribute access only string is allowed.
class MemberRefExpr : MemberExprBase
{
    var right;
    function MemberRefExpr(var owner, var start, var left, var right)
    {
        self.MemberExprBase(owner, start, left);
        self.right = right;
    }
    function clone(var owner)
    {
        return new MemberRefExpr(owner, self.start,
                self.left.clone(owner),
                self.right.clone(owner));
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.left = self.left.optimize();
        self.right = self.right.optimize();
        return self;
    }
    function emit(var e, string result)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        self.annotate(e);
        e.say(INDENT, "getattribute ", result, ", ", lreg, ", ", rreg);
    }
    function emit_assign_get(var e, var expr)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        string vreg;
        switch {
          case expr.isnull():
            vreg = self.tempreg(REGvar);
            self.annotate(e);
            e.emitnull(vreg);
            break;
          case expr.checkresult() == REGvar:
            vreg = expr.emit_get(e);
            __ASSERT__(vreg != NULL);
            break;
          default:
            vreg = self.tempreg(REGvar);
            string aux = expr.emit_get(e);
            self.annotate(e);
            e.emitbox(vreg, aux);
        }

        self.annotate(e);
        e.say(INDENT, "setattribute ",  lreg, ", ", rreg, ", ", vreg);
        return vreg;
    }
}

//*********************************************

class StringIndexExpr : Expr
{
    var left;
    var arg;
    function StringIndexExpr(var owner, var start, var left, var arg)
    {
        self.Expr(owner, start);
        self.left = left;
        self.arg = arg;
    }
    function checkresult()
    {
       return REGstring;
    }
    function emit(var e, string result)
    {
        string lreg = self.left.emit_get(e);
        string rreg = self.arg.emit_getint(e);
        self.annotate(e);
        e.say(sformat(INDENT + "substr %0, %1, %2, 1",
                result, lreg, rreg));
    }
}

//*********************************************

class IndexExpr : Expr
{
    var left;
    var regleft;
    var args;
    var argregs;

    function IndexExpr(var tk, var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.left = subexpr;
        self.args = new SimpleArgList(tk, owner, "]");
    }
    function clone(var owner)
    {
        :IndexExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.left = self.left.clone(owner);
        cloned.args = self.args.clone(owner);
        return cloned;
    }
    function checkresult()
    {
       return REGvar;
    }
    function optimize()
    {
        var left = self.left.optimize();
        self.left = left;
        var args = self.args;
        args.optimizeargs();

        switch (left.checkresult()) {
          case REGstring:
            if (args.numargs() != 1)
               SyntaxError("Bad string index", self);
            var arg = args.getarg(0);
            // Optimize case of string constant indexed with int constant
            // evaluating it at compile time.
            if (left.isstringliteral() && arg.isintegerliteral()) {
                int ival = arg.getIntegerValue();
                string sval = left.getStringValue();
                return stringQuotedValue(self.owner, self.start,
                        substr(sval, ival, 1));
            }
            return new StringIndexExpr(self.owner, self.start, left, arg);
          case REGvar:
            break;
          default:
            SyntaxError("Type not valid for indexing", left);
        }

        return self;
    }
    function emit_prep(var e)
    {
        if (self.regleft != null || self.argregs != null)
            InternalError("wrong call to IndexExpr.emit_args", self.start);
        var left = self.left;
        self.regleft = left.isidentifier() ?
            left.getIdentifier() :
            left.emit_get(e);
        self.argregs = self.args.getargvalues(e);
    }
    function emit_aux(var e)
    {
        var regleft = self.regleft;
        var argregs = self.argregs;
        if (regleft == null || argregs == null)
            InternalError("wrong call to IndexExpr.emit_aux", self.start);
        e.print(self.regleft, "[");
        e.print(join("; ", argregs));
        e.print("]");
    }
    function emit(var e, string result)
    {
        self.emit_prep(e);
        self.annotate(e);
        e.print(INDENT, result, " = ");
        self.emit_aux(e);
        e.say("");
    }
    function emit_getint(var e)
    {
        string result = self.tempreg(REGint);
        self.emit(e, result);
        return result;
    }
    function emit_assign_get(var e, var expr)
    {
        self.emit_prep(e);
        string rreg;
        if (expr.isnull()) {
            rreg = self.tempreg(REGvar);
            e.emitnull(rreg);
        }
        else
            rreg = expr.emit_get(e);
        self.annotate(e);
        e.print(INDENT);
        self.emit_aux(e);
        e.say(" = ", rreg);
        return rreg;
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var values;

    function ArrayExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.values = parseListOrEmpty(tk, owner, parseExpr, "]");
    }
    function clone(var owner)
    {
        :ArrayExpr cloned;
        cloned.Expr(owner, self.start);
        if (self.values != null)
            cloned.values = clone_array(self.values, owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.values);
        return self;
    }
    function emit(var e, string result)
    {
        string value = self.emit_get(e);
        e.emitset(result, value);
    }
    function emit_void(var e)
    {
        // No need to create the container, but the
        // initializers may have secondary effects,
        // so they should be evaluated.
        self.emit_init(e, "");
    }
    function emit_get(var e)
    {
        string container = self.tempreg(REGvar);
        self.emit_init(e, container);
        return container;
    }
    function emit_init(var e, string container)
    {
        self.annotate(e);
        var values = self.values;
        int size = values == null ? 0 : elements(values);
        if (container != "") {
            e.say(INDENT, "root_new ", container, ", ['parrot';'ResizablePMCArray']");
            if (size > 0)
                e.emitassign(container, size);
        }
        :CollectValues collect(self.owner, e);
        int i = 0;
        for (var value in values) {
            string valuereg = collect.add(value);
            if (container != "") {
                self.annotate(e);
                e.say(sformat(INDENT + "%0[%1] = %2", container, i, valuereg));
                ++i;
            }
        }
    }
}

//*********************************************

class HashExpr : Expr
{
    var keys;
    var values;

    function HashExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        var keys = [];
        var values = [];
        if (!t.isop("}")) {
            tk.unget(t);
            do {
                var key = parseExpr(tk, owner);
                ExpectOp(":", tk);
                var value = parseExpr(tk, owner);
                push(keys, key);
                push(values, value);

            } while ((t = tk.get()).isop(","));
            if (! t.isop("}"))
                Expected("',' or '}'", t);
        }
        self.keys = keys;
        self.values = values;
    }
    function clone(var owner)
    {
        :HashExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.keys = clone_array(self.keys, owner);
        cloned.values = clone_array(self.values, owner);
        return cloned;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.keys);
        optimize_array(self.values);
        return self;
    }
    function emit(var e, string result)
    {
        self.annotate(e);

        // In void context there is no need to create the container,
        // but the keys and values may have secondary effects,
        // so they should ve evaluated.
        if (result != "")
            e.say(INDENT, "root_new ", result, ", ['parrot';'Hash']");

        var keys = self.keys;
        var values = self.values;
        :CollectValues collectvalues(self.owner, e);
        int n = keys;
        for (int i = 0; i < n; ++i) {
            var key = keys[i];
            string keyreg;
            if (key.isidentifier() && key.checkIdentifier() == "") {
                string id = key.getName();
                keyreg = self.tempreg(REGvar);
                e.emitget_hll_global(keyreg, id);
            }
            else
                keyreg = key.emit_get(e);

            string valuereg = collectvalues.add(values[i]);
            if (result != "")
                e.say(INDENT, result, "[", keyreg, "] = ", valuereg);
        }
    }
    function emit_void(var e)
    {
        self.emit(e, "");
    }
    function emit_get(var e)
    {
        string container = self.tempreg(REGvar);
        self.emit(e, container);
        return container;
    }
}

//**********************************************************************

class NewBaseExpr : Expr
{
    var initializer;
    // The value of initializer is:
    // * null if no arguments          -> no parenthesis
    // * empty array if zero arguments -> parenthesized empty list
    // * non empty array otherwise     -> parenthesized non empty list

    function checkresult() { return REGvar; }
    function parseinitializer(var tk)
    {
        // Called with the tokenizer pointing right after the
        // opening parenthesis
        self.initializer = new ArgumentList(self.owner, self.start, tk, ")");
    }
    function numargs()
    {
        var initializer = self.initializer;
        return initializer == null ? -1 : int(initializer.numargs());
    }
    function optimize_initializer()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer.optimize();
    }
    function optimize()
    {
        self.optimize_initializer();
        return self;
    }
    function emit_constructor(var e, string regnew, string constructor)
    {
        var initializer = self.initializer;
        if (initializer != null)
            initializer.getargvalues(e);
        e.print(INDENT, regnew, ".'", constructor, "'(");
        if (initializer != null)
            initializer.emitargs(e);
        e.say(")");
    }
}

//**********************************************************************

function warn_class_unknown(var e, string name, var pos)
{
    e.warn("class " + name + " not found at compile time", pos);
}

class NewExpr : NewBaseExpr
{
    var value;

    function NewExpr(var tk, var owner, var start, var firstvalue)
    {
        self.Expr(owner, start);

        if (! (firstvalue.isstring() || firstvalue.isidentifier()))
            SyntaxError("Unimplemented", firstvalue);
        self.value = firstvalue;
        var t = tk.get();

        if (t.isop("("))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function clone(var owner)
    {
        :NewExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.value = self.value;
        if (self.initializer != null)
            cloned.initializer = self.initializer.clone(owner);
        return cloned;
    }
    function optimize()
    {
        var value = self.value;
        if (value.isidentifier()) {
            // The identifier can be a string constant, check for that case
            // and obtain the string value.
            var desc = self.owner.getvar(value);
            if (desc != null && desc.isconst()) {
                value = desc.getvalue();
                if (! (value instanceof StringLiteral))
                    SyntaxError("Constant value must evaluate to a string", value);
                self.value = value.strval;
            }
        }
        self.optimize_initializer();
        return self;
    }
    function emit(var e, string result, int is_init[optional])
    {
        self.annotate(e);

        var initializer = self.initializer;
        var value = self.value;
        int numinits = self.numargs();

        const int BYNAME = 0, BYIDENT = 1;
        int type = value.isstring() ? BYNAME :
                value.isidentifier() ? BYIDENT : -1;

        string reginit = "";
        string regnew = result;
        string constructor;
        switch (numinits) {
          case -1:
          case 0:
            break;
          case 1:
            if (type == BYIDENT) {
                if (! is_init)
                    regnew = self.tempreg(REGvar);
            }
            else {
                var initval = initializer.getfreearg(0);
                reginit = initval.emit_get(e);
                reginit = ", " + reginit;
            }
            break;
          default:
            if (type != BYIDENT)
                SyntaxError("Multiple init arguments not allowed here", self);
            if (! is_init)
                regnew = self.tempreg(REGvar);
        }

        if (regnew == "")
            regnew = self.tempreg(REGvar);

        switch (type) {
          case BYNAME:
            // By name, usually a pmc.
            string name = value.rawstring();
            var aux = get_class(name);
            if (aux == null)
                warn_class_unknown(e, name , value);

            // Avoid using root_new here for a now.
            //e.say("root_new ", regnew, ", ['parrot'; ", value, " ]", reginit);
            e.say(INDENT, "new ", regnew, ", [ ", value, " ]", reginit);
            if (numinits > 1) {
                e.say(regnew, ".'", value, "'()");
            }
            break;
          case BYIDENT:
            var id = self.owner.getvar(value);
            if (id == null) {
                var cl = self.owner.checkclass(value);
                if (cl != null) {
                    var key = cl.getpath();
                    key.emit_new(e, self, regnew, reginit);
                }
                else {
                    id = self.scopesearch( [value], SEARCH_CLASS);
                    if (id != null)
                        e.say(INDENT, "new ", regnew, ", ", id.getclasskey(), reginit);
                    else {
                        warn_class_unknown(e, value.getidentifier(), value);
                        e.say(INDENT, "new ", regnew, ", ['", value, "']", reginit);
                    }
                }
                constructor = value;
            }
            else {
                //say("new with var");
                e.say(INDENT, "new ", regnew, ", ", id.getreg(), "", reginit);
            }
            break;
          default:
            InternalError("Unexpected type in new");
        }
        if (numinits > 1 || (numinits >= 0 && type == BYIDENT)) {
            self.emit_constructor(e, regnew, constructor);
            if (! is_init)
                e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

class NewIndexedExpr : NewBaseExpr
{
    var nskey;

    function NewIndexedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        :ClassSpecifierParrotKey nskey(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop("("))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(var e, string result)
    {
        string reginit;
        switch (self.numargs()) {
          case -1:
          case 0:
            break;
          case 1:
            var initval = self.initializer.getfreearg(0);
            reginit = initval.emit_get(e);
            break;
          default:
            SyntaxError("Multiple init arguments not allowed here", self);
        }
        var nskey = self.nskey;

        e.print(INDENT);
        if (nskey.hasHLL())
            e.print("root_");
        e.print("new ", result, ", ");
        nskey.emit(e, null);
        if (reginit != null)
            e.print(", ", reginit);
        e.say();
    }
}

//**********************************************************************

class NewQualifiedExpr : NewBaseExpr
{
    var nskey;

    function NewQualifiedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        :ClassSpecifierId nskey(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop("("))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(var e, string result)
    {
        int numinits = self.numargs();
        string regnew = result;
        if (numinits > 0)
            regnew = self.tempreg(REGvar);
        var nskey = self.nskey;

        if (regnew == "")
            regnew = self.tempreg(REGvar);

        nskey.emit_new(e, self, regnew);

        if (numinits >= 0) {
            string constructor = nskey.last();
            self.emit_constructor(e, regnew, constructor);
            e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

function parseNew(var tk, var owner, var start)
{
    var t = tk.get();

    switch {
      case t.isop("("):
        // Not a new operator, but a call to a function called new.
        return new CallExpr(tk, owner, start,
                new StringLiteral(owner, start));
      case t.isop("["):
        // Class specifier is a key
        return new NewIndexedExpr(tk, owner, start);
      case t.isidentifier():
        // Special case here. It can be an id, a qualified id or
        // a const string
        var t2 = tk.get();
        tk.unget(t2);
        if (t2.isop(".")) {
            // Qualified id
            return new NewQualifiedExpr(tk, owner, t);
        }
        // Else let the default handle it
      default:
        // Remainig cases
        return new NewExpr(tk, owner, start, t);
    }
}

//**********************************************************************

class OpInstanceOfExpr : Expr
{
    var lexpr;
    var checked;

    function OpInstanceOfExpr(var owner, var start, var lexpr, var tk)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.checked = parseClassSpecifier(tk, owner);
    }
    function clone(var owner)
    {
        :OpInstanceOfExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.lexpr = self.lexpr.clone(owner);
        cloned.checked = self.checked.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.lexpr = self.lexpr.optimize();
        return self;
    }
    function checkresult() { return REGint; }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        string ltype = lexpr.checkresult();
        if (ltype != REGvar)
            SyntaxError("Invalid instanceof left operand", lexpr);
        var checked = self.checked;

        string check = lexpr.emit_get(e);
        self.annotate(e);
        e.print(INDENT + "isa ", result, ", ", check, ", ");
        checked.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpConditionalExpr : Expr
{
    var condition;
    var etrue;
    var efalse;

    function OpConditionalExpr(var owner, var start,
            var condition, var etrue, var efalse)
    {
        self.Expr(owner, start);
        self.condition = (new Condition).set(condition);
        self.etrue = etrue;
        self.efalse = efalse;
        return self;
    }
    function clone(var owner)
    {
        :OpConditionalExpr cloned;
        cloned.Expr(owner, self.start);
        cloned.condition = (new Condition).set(self.condition.condexpr.clone(owner));
        cloned.etrue = self.etrue.clone(owner);
        cloned.efalse = self.efalse.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        switch (self.condition.getvalue()) {
          case CONDistrue:
            return self.etrue.optimize();
          case CONDisfalse:
            return self.efalse.optimize();
          default:
            self.etrue = self.etrue.optimize();
            self.efalse = self.efalse.optimize();
            return self;
        }
    }
    function checkresult()
    {
        var etrue = self.etrue;
        if (etrue.isnull())
            return self.efalse.checkresult();
        else
            return etrue.checkresult();
    }
    function emit(var e, string result)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        var etrue = self.etrue;
        string tres = self.checkresult();
        if (etrue.isnull())
            e.emitnull(result);
        else
            etrue.emit(e, result);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        var efalse = self.efalse;
        if (efalse.isnull())
            e.emitnull(result);
        else {
            string tfalse = efalse.checkresult();
            if (tres == REGvar && tfalse != REGvar) {
                string r = efalse.emit_get(e);
                e.emitbox(result, r);
            }
            else
            {
                if (tfalse == REGvar) {
                    var aux = efalse.emit_get(e);
                    e.emitset(result, aux);
                }
                else
                    efalse.emit(e, result);
            }
        }
        e.emitlabel(cond_end);
    }
    function emit_void(var e)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        self.etrue.emit_void(e);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        self.efalse.emit_void(e);
        e.emitlabel(cond_end);
    }
}

//*********************************************
//           Expressions parser
//*********************************************

const int
    Code_none          =  0,
    Code_paren         =  1,
    Code_bracket       =  2,
    Code_dot           =  3,
    Code_assign        =  4,
    Code_assign_to     =  5,
    Code_add_assign    =  6,
    Code_add           =  7,
    Code_minus         =  8,
    Code_inc           =  9,
    Code_dec           = 10,
    Code_not           = 11,
    Code_equal         = 12,
    Code_not_equal     = 13,
    Code_less          = 14,
    Code_less_equal    = 15,
    Code_greater       = 16,
    Code_greater_equal = 17,
    Code_sub_assign    = 18,
    Code_mul           = 19,
    Code_div           = 20,
    Code_mod           = 21,
    Code_cmod          = 22,
    Code_mul_assign    = 23,
    Code_div_assign    = 24,
    Code_same          = 25,
    Code_not_same      = 26,
    Code_instanceof    = 27,
    Code_shiftleft     = 28,
    Code_shiftright    = 29,
    Code_shiftlright   = 30,
    Code_mod_assign    = 31,
    Code_delete        = 32,
    Code_exists        = 33,
    Code_bin_not       = 34,
    Code_defined       = 35;

function getOpCode_2(var t)
{
    switch (t.checkop()) {
    case "(": return Code_paren;
    case "[": return Code_bracket;
    case ".": return Code_dot;
    default:  return Code_none;
    }
}

function getOpCode_4(var t)
{
    switch (t.checkop()) {
    case "-":  return Code_minus;
    case "!":  return Code_not;
    case "~":  return Code_bin_not;
    case "++": return Code_inc;
    case "--": return Code_dec;
    default:
        if (t.iskeyword("delete")) return Code_delete;
        else if (t.iskeyword("exists")) return Code_exists;
        else if (t.iskeyword("defined")) return Code_defined;
        else return Code_none;
    }
}

function getOpCode_5(var t)
{
    switch (t.checkop()) {
    case "*":  return Code_mul;
    case "/":  return Code_div;
    case "%":  return Code_mod;
    case "%%": return Code_cmod;
    default:   return Code_none;
    }
}

function getOpCode_7(var t)
{
    switch (t.checkop()) {
    case "<<":  return Code_shiftleft;
    case ">>":  return Code_shiftright;
    case ">>>": return Code_shiftlright;
    default:    return Code_none;
    }
}

function getOpCode_8(var t)
{
    switch (t.checkop()) {
    case "<":  return Code_less;
    case ">":  return Code_greater;
    case "<=": return Code_less_equal;
    case ">=": return Code_greater_equal;
    default:
        if (t.iskeyword("instanceof")) return Code_instanceof;
        else return Code_none;
    }
}

function getOpCode_9(var t)
{
    switch (t.checkop()) {
    case "==":  return Code_equal;
    case "!=":  return Code_not_equal;
    case "===":  return Code_same;
    case "!==":  return Code_not_same;
    default:   return Code_none;
    }
}

function getOpCode_16(var t)
{
    switch (t.checkop()) {
    case "=":  return Code_assign;
    case "=:": return Code_assign_to;
    case "+=": return Code_add_assign;
    case "-=": return Code_sub_assign;
    case "*=": return Code_mul_assign;
    case "/=": return Code_div_assign;
    case "%=": return Code_mod_assign;
    default:   return Code_none;
    }
}

function parseExpr_0(var tk, var owner)
{
    var t = tk.get();
    var expr;

    switch {
      case t.isop("("):
        expr = parseExpr(tk, owner);
        ExpectOp(")", tk);
        return expr;
      case t.isop("["):
        return new ArrayExpr(tk, owner, t);
      case t.isop("{"):
        return new HashExpr(tk, owner, t);
      case t.isstring():
        return new StringLiteral(owner, t);
      case t.isint():
        return integerValue(owner, t, t.getintvalue());
      case t.isfloat():
        return new FloatLiteral(owner, t);
      case t.iskeyword("new"):
        return parseNew(tk, owner, t);
      case t.iskeyword("function"):
        return new FunctionExpr(tk, owner, t);
      case t.iskeyword("class"):
        return new OpClassExpr(tk, owner, t);
      case t.iskeyword("namespace"):
        return new OpNamespaceExpr(tk, owner, t);
      case t.isidentifier():
        return new IdentifierExpr(owner, t);
      default:
        Expected("expression", t);
    }
}

function parseExpr_2(var tk, var owner)
{
    var subexpr = parseExpr_0(tk, owner);
    var t;
    var start;
    int code;
    while ((code = getOpCode_2(t = tk.get())) != Code_none ) {
        switch (code) {
          case Code_paren:
            subexpr = new CallExpr(tk, owner, t, subexpr);
            break;
          case Code_bracket:
            subexpr = new IndexExpr(tk, owner, t, subexpr);
            break;
          case Code_dot:
            start = t;
            t = tk.get();
            if (t.isop("*")) {
                var right = parseExpr_0(tk, owner);
                subexpr = new MemberRefExpr(owner, t, subexpr, right);
            }
            else
                subexpr = new MemberExpr(owner, start, subexpr, t);
            break;
          default:
            InternalError("Unexpected code in parseExpr_2");
        }
    }
    tk.unget(t);
    return subexpr;
}

function parseExpr_3(var tk, var owner)
{
    var subexpr = parseExpr_2(tk, owner);
    var t = tk.get();
    switch {
      case t.isop("++"):
        return new OpPostIncExpr(owner, t, subexpr);
      case t.isop("--"):
        return new OpPostDecExpr(owner, t, subexpr);
      default:
        tk.unget(t);
        return subexpr;
    }
}

function parseExpr_4(var tk, var owner)
{
    var t = tk.get();
    int code = getOpCode_4(t);
    if (code != Code_none) {
        var subexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_minus:
            return new OpUnaryMinusExpr(owner, t, subexpr);
          case Code_not:
            return new OpNotExpr(owner, t, subexpr);
          case Code_bin_not:
            return new OpBinNotExpr(owner, t, subexpr);
          case Code_inc:
            return new OpPreIncExpr(owner, t, subexpr);
          case Code_dec:
            return new OpPreDecExpr(owner, t, subexpr);
          case Code_delete:
            return new OpDeleteExpr(owner, t, subexpr);
          case Code_exists:
            return new OpExistsExpr(owner, t, subexpr);
          case Code_defined:
            return new OpDefinedExpr(owner, t, subexpr);
          default:
            InternalError("Invalid code in parseExpr_4", t);
        }
    }
    else {
        tk.unget(t);
        return  parseExpr_3(tk, owner);
    }
}

function parseExpr_5(var tk, var owner)
{
    var lexpr = parseExpr_4(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_5(t = tk.get())) != Code_none) {
        var rexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_mul:
            lexpr = new OpMulExpr(owner, t, lexpr, rexpr);
            break;
          case Code_div:
            lexpr = new OpDivExpr(owner, t, lexpr, rexpr);
            break;
          case Code_mod:
            lexpr = new OpModExpr(owner, t, lexpr, rexpr);
            break;
          case Code_cmod:
            lexpr = new OpCModExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError("Invalid code in parseExpr_5", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_6(var tk, var owner)
{
    var lexpr = parseExpr_5(tk, owner);
    var t;
    while ((t = tk.get()).isop("+") || t.isop("-")) {
        var rexpr = parseExpr_5(tk, owner);
        var expr;
        if (t.isop("+"))
            expr = new OpAddExpr(owner, t, lexpr, rexpr);
        else
            expr = new OpSubExpr(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_7(var tk, var owner)
{
    var lexpr = parseExpr_6(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_7(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_shiftleft:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftleftExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftrightExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftlright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftlrightExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError("Invalid code in parseExpr_7", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_8(var tk, var owner)
{
    var lexpr = parseExpr_7(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_8(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_less:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_less_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_instanceof:
            lexpr = new OpInstanceOfExpr(owner, t, lexpr, tk);
            break;
          default:
            InternalError("Invalid code in parseExpr_9", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_9(var tk, var owner)
{
    var lexpr = parseExpr_8(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_9(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, false);
            break;
          case Code_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, false);
            break;
          default:
            InternalError("Invalid code in parseExpr_8", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_10(var tk, var owner)
{
    var lexpr = parseExpr_9(tk, owner);
    var t;
    while ((t = tk.get()).isop("&")) {
        var rexpr = parseExpr_9(tk, owner);
        lexpr = new OpBinAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_11(var tk, var owner)
{
    var lexpr = parseExpr_10(tk, owner);
    var t;
    while ((t = tk.get()).isop("^")) {
        var rexpr = parseExpr_10(tk, owner);
        lexpr = new OpBinXorExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_12(var tk, var owner)
{
    var lexpr = parseExpr_11(tk, owner);
    var t;
    while ((t = tk.get()).isop("|")) {
        var rexpr = parseExpr_11(tk, owner);
        lexpr = new OpBinOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_13(var tk, var owner)
{
    var lexpr = parseExpr_12(tk, owner);
    var t;
    while ((t = tk.get()).isop("&&")) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_14(var tk, var owner)
{
    var lexpr = parseExpr_13(tk, owner);
    var t;
    while ((t = tk.get()).isop("||")) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_15(var tk, var owner)
{
    var econd = parseExpr_14(tk, owner);
    var t = tk.get();
    if (t.isop("?")) {
        var etrue = parseExpr_16(tk, owner);
        ExpectOp(":", tk);
        var efalse = parseExpr_16(tk, owner);
        return new OpConditionalExpr(owner, t, econd, etrue, efalse);
    }
    else {
        tk.unget(t);
        return econd;
    }
}

function parseExpr_16(var tk, var owner)
{
    var lexpr = parseExpr_15(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_16(t = tk.get())) != Code_none ) {
        var rexpr = parseExpr_16(tk, owner);
        var expr;
        switch (code) {
          case Code_assign:
            expr = new OpAssignExpr;
            break;
          case Code_assign_to:
            expr = new OpAssignToExpr;
            break;
          case Code_add_assign:
            expr = new OpAddToExpr;
            break;
          case Code_sub_assign:
            expr = new OpSubToExpr;
            break;
          case Code_mul_assign:
            expr = new OpMulToExpr;
            break;
          case Code_div_assign:
            expr = new OpDivToExpr;
            break;
          case Code_mod_assign:
            expr = new OpModToExpr;
            break;
          default:
            InternalError("Unexpected code in parseExpr_16", t);
        }
        expr.set(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr(var tk, var owner)
{
    return parseExpr_16(tk, owner);
}

//*********************************************
//         Breakable and Continuable
//*********************************************

// Abstract base class for statments that can contain break
// and continue statments. Continuable is always breakable.

class Breakable
{
    var brlabel;

    function genbreaklabel()
    {
        if (self.brlabel != null)
            InternalError("attempt to generate break label twice");
        string label = self.genlabel();
        self.brlabel = label;
        return label;
    }
    function getbreaklabel(var pos)
    {
        var label = self.brlabel;
        if (label == null)
            InternalError("attempt to get break label before creating it");
        return label;
    }
}

class Continuable : Breakable
{
    var cntlabel;

    function gencontinuelabel()
    {
        if (self.cntlabel != null)
            InternalError("attempt to generate continue label twice");
        string label = self.genlabel();
        self.cntlabel = label;
        return label;
    }
    function getcontinuelabel(var pos)
    {
        var label = self.cntlabel;
        if (label == null)
            InternalError("attempt to get continue label before creating it");
        return label;
    }
}

//*********************************************
//            ReturnYieldStatement
//*********************************************

// Return and Yield statements and a base class
// that does almost all.

class ReturnYieldStatement : Statement
{
    var values;

    function parse(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.values = new ArgumentList(owner, start, tk, ";");
        }
    }
    function optimize()
    {
        var values = self.values;
        if (values != null)
            values = values.optimize();
        return self;
    }
    function emit(var e)
    {
        //var args = [];
        var values = self.values;
        int n = values == null ? 0 : int(values.numargs());

        // Experimental tailcall optimization
        if (n == 1 && (self instanceof ReturnStatement)) {
            var func = values.getfreearg(0);
            if (func.cantailcall() && self.owner.allowtailcall()) {
                self.annotate(e);
                return func.emit(e, ".tailcall");
            }
        }

        if (n > 0)
            values.getargvalues(e);

        self.annotate(e);
        self.emitret(e);
        if (n > 0)
            values.emitargs(e);
        e.say(")");
    }
}

class ReturnStatement : ReturnYieldStatement
{
    function ReturnStatement(var start, var tk, var owner)
    {
        self.parse(start, tk, owner);
    }
    function clone(var owner)
    {
        :ReturnStatement cloned;
        cloned.Statement(self.start, owner);
        if (self.values != null)
            cloned.values = self.values.clone(owner);
        return cloned;
    }
    function emitret(var e)
    {
        e.print(INDENT, ".return(");
    }
}

class YieldStatement : ReturnYieldStatement
{
    function YieldStatement(var start, var tk, var owner)
    {
        self.parse(start, tk, owner);
    }
    function clone(var owner)
    {
        SyntaxError("inlined yield not allowed", self);
    }
    function emitret(var e)
    {
        e.print(INDENT, ".yield(");
    }
}

class InlineReturnStatement : Statement
{
    var expr;
    function InlineReturnStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        if (!t.isop(";")) {
            tk.unget(t);
            self.expr = parseExpr(tk, owner);
            ExpectOp(";", tk);
        }
    }
    function clone(var owner)
    {
        :InlineReturnStatement cloned;
        cloned.Statement(self.start, owner);
        var expr = self.expr;
        if (expr != null)
            cloned.expr = expr.clone(owner);
        return cloned;
    }
    function optimize()
    {
        var expr = self.expr;
        if (expr != null)
            self.expr = expr.optimize();
        return self;
    }
    function emit(var e)
    {
        var outer = self.owner.getouter();
        __ASSERT__(outer instanceof InlinedBlock);
        var expr = self.expr;
        if (expr != null)
        {
            self.annotate(e);
            outer.emitret(e, expr);
        }
        if (! outer.islaststatement(self)) {
            string retlabel = outer.getendlabel();
            self.annotate(e);
            e.emitgoto(retlabel);
        }
    }
}

function parseReturn(var start, var tk, var owner)
{
    var outer = owner.getouter();
    if (outer instanceof InlineStatement)
        return new InlineReturnStatement(start, tk, owner);
    else
        return new ReturnStatement(start, tk, owner);
}

//*********************************************
//            LabelStatement
//*********************************************

class LabelStatement : Statement
{
    var name;
    var value;
    function LabelStatement(var n, var owner)
    {
        self.Statement(n, owner);
        self.name = n;
        self.value = self.createlabel(n);
    }
    function clone(var owner)
    {
        :LabelStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.name = self.name;
        cloned.value = cloned.createlabel(cloned.name);
        return cloned;
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        e.emitlabel(self.value, "label " + string(self.name));
    }
}

//*********************************************
//            Reflabel
//*********************************************

class Reflabel
{
    var owner;
    var label;

    function Reflabel(var owner, var label)
    {
        self.owner = owner;
        self.label = label;
    }
    function clone(var owner)
    {
        return new Reflabel(owner, self.label);
    }
    function optimize() { return self; }
    function emit_get(var e)
    {
        string value = self.owner.getlabel(self.label.getidentifier());
        if (value == null)
            SyntaxError("No such label", self.label);
        return value;
    }
}

//*********************************************
//            GotoStatement
//*********************************************

class GotoStatement : Statement
{
    var label;

    function GotoStatement(var start, var owner, var label)
    {
        self.Statement(start, owner);
        self.label = label;
    }
    function clone(var owner)
    {
        return new GotoStatement(self.start, owner, self.label);
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        string labelname = self.label;
        string value = self.getlabel(labelname);
        if (value == null)
            SyntaxError("No such label", self.label);
        e.emitgoto(value, "goto " + labelname);
    }
}

function parseGoto(var start, var tk, var owner)
{
    var label = tk.get();
    RequireIdentifier(label);
    ExpectOp(";", tk);
    return new GotoStatement(start, owner, label);
}

//*********************************************
//          ConditionalStatement
//*********************************************

class ConditionalStatement : Statement, Condition
{
    function parseconditionshort(var tk)
    {
        self.set(parseExpr(tk, self));
    }
    function parsecondition(var tk)
    {
        ExpectOp("(", tk);
        self.set(parseExpr(tk, self));
        ExpectOp(")", tk);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : ConditionalStatement
{
    var truebranch;
    var falsebranch;
    function IfStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.truebranch = parseStatement(tk, self);
        var t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement;
            tk.unget(t);
        }
    }
    function clone(var owner)
    {
        :IfStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(owner);
        cloned.truebranch = self.truebranch.clone(owner);
        cloned.falsebranch = self.falsebranch.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        self.truebranch = self.truebranch.optimize();
        self.falsebranch = self.falsebranch.optimize();
        switch (self.getvalue()) {
          case CONDistrue:
            return self.truebranch;
          case CONDisfalse:
            return self.falsebranch;
        }
        return self;
    }
    function emit(var e)
    {
        var truebranch = self.truebranch;
        var falsebranch = self.falsebranch;
        int t_empty = truebranch.isempty();
        int f_empty = falsebranch.isempty();
        string elselabel = "";
        if (! f_empty)
            elselabel = self.genlabel();
        string endlabel = self.genlabel();
        string cond_false = f_empty ? endlabel : elselabel;
        self.annotate(e);
        self.emit_else(e, cond_false);
        truebranch.emit(e);

        if (! f_empty) {
            e.emitgoto(endlabel);
            e.emitlabel(elselabel, "else");
            falsebranch.emit(e);
        }
        e.emitlabel(endlabel, "endif");
    }
}

//*********************************************
//            LoopStatement
//*********************************************

class LoopStatement : Continuable
{
    var body;
    function parsebody(var tk)
    {
        self.body = parseStatement(tk, self);
    }
    function emit_infinite(var e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.emitlabel(continuelabel, "Infinite loop");
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, "Infinite loop end");
    }
}

//*********************************************
//            WhileStatement
//*********************************************

class WhileStatement : LoopStatement, ConditionalStatement
{
    function WhileStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.parsebody(tk);
    }
    function clone(var owner)
    {
        :WhileStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        switch (self.getvalue()) {
          case CONDistrue:
            self.emit_infinite(e);
            break;
          case CONDisfalse:
            if (e.getDebug())
                e.comment("while(false) optimized out");
            break;
          default:
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(continuelabel, "while");
            self.emit_else(e, breaklabel);
            self.body.emit(e);
            e.emitgoto(continuelabel);
            e.emitlabel(breaklabel, "endwhile");
        }
    }
}

//*********************************************
//            DoStatement
//*********************************************

class DoStatement : LoopStatement, ConditionalStatement
{
    function DoStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsebody(tk);
        ExpectKeyword("while", tk);
        self.parsecondition(tk);
    }
    function clone(var owner)
    {
        :DoStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.condexpr = self.condexpr.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.optimize_condition();
        var body = self.body.optimize();
        if (body.isempty() && self.getvalue() == CONDisfalse)
            return new EmptyStatement;
        self.body = body;
        return self;
    }
    function emit(var e)
    {
        var body = self.body;
        int condvalue = self.getvalue();
        switch (condvalue) {
          case CONDistrue:
            self.emit_infinite(e);
            break;
          default:
            string looplabel = self.genlabel();
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(looplabel, "do");

            body.emit(e);
            e.emitlabel(continuelabel, "continue");
            if (condvalue != CONDisfalse)
                self.emit_if(e, looplabel, breaklabel);
            e.emitlabel(breaklabel, "enddo");
        }
    }
}

//*********************************************
//            ContinueStatement
//*********************************************

class ContinueStatement : Statement
{
    function ContinueStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        ExpectOp(";", tk);
    }
    function clone(var owner)
    {
        :ContinueStatement cloned;
        cloned.Statement(self.start, owner);
        return cloned;
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        string label = self.getcontinuelabel(self.start);
        e.emitgoto(label, "continue");
    }
}

//*********************************************
//            BreakStatement
//*********************************************

class BreakStatement : Statement
{
    function BreakStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        ExpectOp(";", tk);
    }
    function clone(var owner)
    {
        :BreakStatement cloned;
        cloned.Statement(self.start, owner);
        return cloned;
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        string label = self.getbreaklabel(self.start);
        e.emitgoto(label, "break");
    }
}

//*********************************************
//            SwitchBaseStatement
//*********************************************

class SwitchBaseStatement : Breakable, Statement
{
    var case_value;
    var case_st;
    var default_st;

    function SwitchBaseStatement(var start, var owner)
    {
        self.Statement(start, owner);
        self.case_value = [];
        self.case_st = [];
        self.default_st = [];
    }
    function cloneswitchto(var cloned, var owner)
    {
        cloned.Statement(self.start, owner);
        cloned.case_value = clone_array(self.case_value, cloned);
        cloned.case_st = transform(self.case_st, [],
                function (var case) { return clone_array(case, cloned); } );
        cloned.default_st = clone_array(self.default_st, cloned);
        return cloned;
    }
    function parse_switchbody(var tk)
    {
        var t = tk.get();
        switch {
          case t.isop("}"):
            // No cases and no default
            break;
          case t.iskeyword("default"):
            // default without cases
            self.parse_default(tk);
            break;
          case t.iskeyword("case"):
            self.parse_cases(tk);
            break;
          default:
            Expected("switch cases", t);
        }
    }
    function parse_cases(var tk)
    {
        var t;
        do {
            push(self.case_value, parseExpr(tk, self));
            t = tk.get();
            if (! t.isop(":"))
                Expected("':' in case", t);
            var st = [];
            while (! ((t = tk.get()).isop("}") || t.iskeyword("case") || t.iskeyword("default"))) {
                tk.unget(t);
                push(st, parseStatement(tk, self));
            }
            push(self.case_st, st);
        } while (t.iskeyword("case"));
        if (t.iskeyword("default"))
            self.parse_default(tk);
    }
    function parse_default(var tk)
    {
        var t = tk.get();
        if (! t.isop(":"))
            Expected("':' in default", t);
        while (! (t = tk.get()).isop("}")) {
            if (t.iskeyword("case"))
                SyntaxError("case after default", t);
            if (t.iskeyword("default"))
                SyntaxError("default after default", t);
            tk.unget(t);
            push(self.default_st, parseStatement(tk, self));
        }
    }
    function optimize_cases()
    {
        optimize_array(self.case_value);
        for (var case in self.case_st)
            optimize_array(case);
        optimize_array(self.default_st);
    }
}

//*********************************************
//            SwitchStatement
//*********************************************

class SwitchStatement : SwitchBaseStatement
{
    var condition;

    function SwitchStatement(var start, var tk, var owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.condition = parseExpr(tk, self);
        var t = tk.get();
        if (! t.isop(")"))
            Expected("')' in switch", t);
        t = tk.get();
        if (! t.isop("{"))
            Expected("'{' in switch", t);
        self.parse_switchbody(tk);
    }
    function clone(var owner)
    {
        var cloned = self.cloneswitchto(new SwitchStatement, owner);
        cloned.condition = self.condition.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.optimize_cases();
        return self;
    }
    function emit(var e)
    {
        // Get case common type
        // If all cases are literal strings of length 1, convert to
        // the code of the first char
        string type = "";
        for (var value in self.case_value) {
            string t = value.checkresult();
            if (t == REGfloat)
                SyntaxError("Invalid type in case", self);
            if (t == REGstring) {
                if (type == "" || type == "char")
                {
                    if (value.isstringliteral() && length(string_from_literal(value)) == 1)
                        t = "char";
                    else
                        type = REGstring;
                }
            }
            if (type == "")
                type = t;
            else if (type != t)
                type = REGvar;
        }
        // Evaluate condition
        var condition = self.condition;
        var condtype = condition.checkresult();

        // This can happen if there isn't any case. Not likely in hand
        // written code but allowing it may simplify code generators.
        if (type == "")
            type = condtype;

        if (e.getDebug())
            e.comment("switch");
        self.annotate(e);
        string defaultlabel = self.genlabel();
        string reg;
        if (type == "char") {
            if ((condition instanceof CallBuiltinExpr) &&
                        condition.builtin.name() == "chr") {
                var args = condition.args;
                var arg = args[0].arg;
                reg = arg.emit_getint(e);
            }
            else {
                string regs;
                if (condtype != REGstring) {
                    string regcond = condition.emit_get(e);
                    regs = self.tempreg(REGstring);
                    e.emitset(regs, regcond);
                }
                else
                    regs = condition.emit_get(e);
                e.emitif_null(regs, defaultlabel);
                reg = self.tempreg(REGint);
                e.emitarg2("length", reg, regs);
                e.emitarg3("ne", reg, "1", defaultlabel);
                e.emitarg2("ord", reg, regs);
            }
        }
        else if (condtype == type)
            reg = condition.emit_get(e);
        else {
            reg = self.tempreg(type);
            string regcond = condition.emit_get(e);
            e.emitset(reg, regcond);
        }

        // Prpeare labels and check values
        self.genbreaklabel();
        string caselabel[];
        string regval;
        if (type != "char")
            self.tempreg(type);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            string casereg;
            if (type == REGint)
                casereg = caseval.emit_getint(e);
            else if (type == "char") {
                int code = ord(string_from_literal(caseval));
                casereg = code;
            }
            else if (type == caseval.checkresult())
                casereg = caseval.emit_get(e);
            else {
                caseval.emit(e, regval);
                casereg = regval;
            }
            caseval.annotate(e);
            e.say(sformat(INDENT + "if %0 == %1 goto %2", reg, casereg, label));
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; ++i) {
            e.emitlabel(caselabel[i], "case");
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, "default");
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), "switch end");
    }
}

//*********************************************
//            SwitchCaseStatement
//*********************************************

class SwitchCaseStatement : SwitchBaseStatement
{

    function SwitchCaseStatement(var start, var tk, var owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.parse_switchbody(tk);
    }
    function clone(var owner)
    {
        return self.cloneswitchto(new SwitchCaseStatement, owner);
    }
    function optimize()
    {
        self.optimize_cases();
        return self;
    }
    function emit(var e)
    {
        // Prpeare labels and check values
        self.genbreaklabel();
        string defaultlabel = self.genlabel();
        string caselabel[];

        if (e.getDebug())
            e.comment("switch-case");
        string auxreg;
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            if (caseval instanceof ConditionFriendlyIf)
                caseval.emit_if(e, label);
            else {
                string reg;
                if (caseval.checkresult() == REGint)
                    reg = caseval.emit_get(e);
                else {
                    reg = caseval.emit_get(e);
                    if (auxreg == null)
                        auxreg = self.tempreg(REGint);
                    e.emitset(auxreg, reg);
                    reg = auxreg;
                }
                e.emitif(reg, label);
            }
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; ++i) {
            e.emitlabel(caselabel[i], "case");
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, "default");
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), "switch end");
    }
}

//*********************************************

function parseSwitch(var start, var tk, var owner)
{
    var t = tk.get();
    if (t.isop("("))
        return new SwitchStatement(start, tk, owner);
    if (t.isop("{"))
        return new SwitchCaseStatement(start, tk, owner);
    Expected("'(' in switch", t);
}

//*********************************************
//            ForStatement
//*********************************************

class ForStatement : LoopStatement, BlockStatement, ConditionalStatement
{
    var initializer;
    var iteration;

    function ForStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        var t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.initializer = parseStatement(tk, self);
        }
        t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.parseconditionshort(tk);
            ExpectOp(";", tk);
        }
        self.iteration = parseListOrEmpty(tk, self, parseExpr, ")");
        self.parsebody(tk);
    }
    function clone(var owner)
    {
        :ForStatement cloned;
        cloned.BlockStatement(self.start, owner);
        if (self.initializer != null)
            cloned.initializer = self.initializer.clone(cloned);
        if (self.condexpr != null)
            cloned.condexpr = self.condexpr.clone(cloned);
        if (self.iteration != null)
            cloned.iteration = clone_array(self.iteration, cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer = initializer.optimize();
        if (self.condexpr != null) {
            self.optimize_condition();
            if (self.getvalue() == CONDisfalse) {
                if (initializer != null)
                    return initializer;
                else
                    return new EmptyStatement;
            }
        }
        optimize_array(self.iteration);
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        var iteration = self.iteration;
        int has_iteration = iteration != null;
        if (self.initializer == null &&
                self.condexpr == null &&
                !(has_iteration)) {
            self.emit_infinite(e);
            return;
        }
        if (e.getDebug())
            e.comment("for loop");
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        string condlabel = has_iteration ?
                string(self.genlabel()) :
                continuelabel;
        if (self.initializer != null)
            self.initializer.emit(e);

        e.emitlabel(condlabel, "for condition");
        if (self.condexpr != null)
            self.emit_else(e, breaklabel);

        self.body.emit(e);
        if (has_iteration) {
            e.emitlabel(continuelabel, "for iteration");
            for (var it in iteration)
                it.emit_void(e);
        }
        e.emitgoto(condlabel);

        e.emitlabel(breaklabel, "for end");
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : LoopStatement, BlockStatement
{
    var deftype;
    var varname;
    var container;

    function ForeachStatement(var start, var tk, var owner, var name, string type)
    {
        self.BlockStatement(start, owner);
        if (type != "")
            self.deftype = type;
        self.varname = name;
        self.container = parseExpr(tk, self);
        ExpectOp(")", tk);
        self.parsebody(tk);
    }
    function clone(var owner)
    {
        :ForeachStatement cloned;
        cloned.BlockStatement(self.start, owner);
        var deftype = self.deftype;
        var varname = self.varname;
        cloned.deftype = deftype;
        cloned.varname = varname;
        cloned.container = self.container.clone(cloned);
        cloned.body = self.body.clone(cloned);
        return cloned;
    }
    function optimize()
    {
        var deftype = self.deftype;
        if (deftype != null)
            self.createvar(self.varname, deftype);
        var container = self.container.optimize();

        // Optimize out iterating on compile time eveluated
        // null values and empty strings.
        if (container.isnull() ||
                (container.isstringliteral() &&
                length(container.getStringValue()) == 0))
            return new EmptyStatement;

        self.container = container;
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string regcont;
        if (self.container.checkresult() == REGstring) {
            string value = self.container.emit_get(e);
            regcont = self.tempreg(REGvar);
            e.emitbox(regcont, value);
        }
        else
            regcont = self.container.emit_get(e);

        var itvar = self.getvar(self.varname);
        if (itvar == null)
            UndefinedVariable(self.varname, self);

        string iterator = self.createreg(REGvar);
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        e.emitif_null(regcont, breaklabel);
        e.emitarg2("iter", iterator, regcont);
        e.emitset(iterator, "0");
        e.emitlabel(continuelabel, "for iteration");
        e.emitunless(iterator, breaklabel);
        e.emitarg2("shift", itvar.getreg(), iterator);
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, "endfor");
    }
}

//*********************************************

function parseFor(var t, var tk, var owner)
{
    ExpectOp("(", tk);
    var aux = tk.get();
    if (aux.isidentifier()) {
        var in1 = tk.get();
        if (in1.isidentifier()) {
            if (in1.iskeyword("in"))
                return new ForeachStatement(t, tk, owner, aux, "");
            else {
                var in2 = tk.get();
                string type = typetoregcheck(aux.getidentifier());
                if (in2.iskeyword("in") && type != "")
                    return new ForeachStatement(t, tk, owner, in1, type);
                tk.unget(in2);
            }
        }
        tk.unget(in1);
    }
    tk.unget(aux);
    return new ForStatement(t, tk, owner);
}

//*********************************************
//            ThrowStatement
//*********************************************

class ThrowStatement : Statement
{
    var excep;

    function ThrowStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.excep = parseExpr(tk, self);
    }
    function clone(var owner)
    {
        :ThrowStatement cloned;
        cloned.Statement(self.start, owner);
        cloned.excep = self.excep.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.excep = self.excep.optimize();
        return self;
    }
    function emit(var e)
    {
        var excep = self.excep;
        string reg = excep.emit_get(e);
        self.annotate(e);
        switch (excep.checkresult()) {
          case REGvar:
            // Nothing to do here
            break;
          case REGstring:
            // Build a Exception with default values and the message provided
            string msg = reg;
            reg = self.tempreg(REGvar);
            e.print(sformat(
<<:
    root_new %0, ['parrot';'Exception']
    %0['message'] = %1
:>>
                , reg, msg));
            break;
          default:
            SyntaxError("Invalid throw argument", self);
        }
        e.emitarg1("throw", reg);
    }
}

//*********************************************
//            TryStatement
//*********************************************

class TryModifierList : ModifierList
{
    var start;
    function TryModifierList(var start, var tk, var owner)
    {
        self.start = start;
        self.ModifierList(tk, owner);
    }
    function clone(var owner)
    {
        :TryModifierList cloned;
        cloned.start = self.start;
        cloned.list = self.clonemodifiers(owner);
        return cloned;
    }
    function allowtailcall()
    {
        return self.pick("allowtailcall") != null;
    }
    function emitmodifiers(var e, string reghandler)
    {
        var modiflist = self.getlist();
        for (var modif in modiflist) {
            string modifname = modif.getname();
            int nargs = modif.numargs();
            switch (modifname) {
              case "min_severity":
              case "max_severity":
                if (nargs != 1)
                    SyntaxError("Wrong modifier args", self);
                var arg = modif.getarg(0);
                e.say(sformat(INDENT + "%0.'%1'(%2)",
                        reghandler, modifname, arg.emit_get(e)));
                break;
              case "handle_types":
              case "handle_types_except":
                string argregs [];
                for (int i = 0; i < nargs; ++i) {
                    var arg = modif.getarg(i);
                    push(argregs, arg.emit_get(e));
                }
                e.say(sformat(INDENT + "%0.'%1'(%2)",
                        reghandler, modifname, join(", ", argregs)));
                break;
              case "allowtailcall":
                break;
              default:
                SyntaxError("Modifier '" + modifname + "' not valid for try",
                        self.start);
            }
        }
    }
}

class TryStatement : BlockStatement
{
    var stry;
    var modifiers;
    var exname;
    var scatch;

    function TryStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        var t = tk.get();
        if (t.isop("["))
            self.modifiers = new TryModifierList(t, tk, self);
        else
            tk.unget(t);

        self.stry = parseStatement(tk, self);
        t = tk.get();
        if (! t.iskeyword("catch"))
            ExpectedOp("catch", t);
        t = tk.get();
        if (! t.isop("("))
            Expected("'(' after 'catch'", t);
        t = tk.get();
        if (! t.isop(")")) {
            RequireIdentifier(t);
            self.exname = t;
            t = tk.get();
            if (! t.isop(")"))
                Expected("')' in 'catch'", t);
        }
        self.scatch = parseStatement(tk, self);
    }
    function clone(var owner)
    {
        :TryStatement cloned;
        cloned.BlockStatement(self.start, owner);
        if (self.modifiers != null)
            cloned.modifiers = self.modifiers.clone(cloned);
        if (self.exname != null)
            cloned.exname = self.exname;
        cloned.stry = self.stry.clone(cloned);
        cloned.scatch = self.scatch.clone(cloned);
        return cloned;
    }
    function allowtailcall()
    {
        if (self.modifiers != null)
            return self.modifiers.allowtailcall();
        else
            return false;
    }
    function optimize()
    {
        if (self.modifiers != null)
            self.modifiers.optimize();
        self.stry = self.stry.optimize();
        if (self.exname != null)
            self.createvar(self.exname, REGvar);
        self.scatch = self.scatch.optimize();
        return self;
    }
    function emit(var e)
    {
        string reghandler = self.tempreg(REGvar);
        string labelhandler = self.genlabel();
        string labelpasthandler = self.genlabel();
        string exreg = self.exname != null ?
            self.getvar(self.exname).getreg() :
            self.tempreg(REGvar);

        int edebug = e.getDebug();
        self.annotate(e);
        if (edebug)
            e.comment("try: create handler");
        e.print(sformat(
<<:
    new %0, 'ExceptionHandler'
    set_label %0, %1
:>>
            , reghandler, labelhandler));

        if (self.modifiers != null)
            self.modifiers.emitmodifiers(e, reghandler);

        e.emitarg1("push_eh", reghandler);
        if (edebug)
            e.comment("try: begin");
        self.stry.emit(e);
        if (edebug)
            e.comment("try: end");
        e.say(INDENT, "pop_eh");

        self.annotate(e);
        e.emitgoto(labelpasthandler);

        if (edebug)
            e.comment("catch");
        e.emitlabel(labelhandler);
        e.say(INDENT, ".get_results(", exreg, ")");
        e.emitarg1("finalize", exreg);
        e.say(INDENT, "pop_eh");
        self.scatch.emit(e);

        if (edebug)
            e.comment("catch end");
        e.emitlabel(labelpasthandler);
    }
}

//*********************************************
//            DeclarationModifierList
//*********************************************

/*
    Only for lexicals for a now. Testing.
*/

class DeclarationModifierList : ModifierList
{
    function DeclarationModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function clone(var owner)
    {
        :DeclarationModifierList cloned;
        cloned.list = self.clonemodifiers(owner);
        return cloned;
    }
    function getlexicalname()
    {
        // Return the lexical name: null if there is not lexical modifier,
        // empty string if it has no arguments.
        var lexical = self.pick("lexical");
        if (lexical != null) {
            int nargs = lexical.numargs();
            switch (nargs) {
              case 0:
                return "";
              case 1:
                var name = lexical.getarg(0);
                if (! name.isstringliteral())
                    SyntaxError("Invalid lexical", self);
                return name.getPirString();
              default:
                SyntaxError("invalid arguments in modifier", lexical);
            }
        }
        return null;
    }
}

//*********************************************
//            DeclareItem
//*********************************************

/*
    Base class for all variable declarations.
*/

class DeclareItem : Statement
{
    var name;
    var regtype;
    var reg;
    var modifiers;
    var flags;

    function DeclareItem(var start, var owner, var name, string regtype, int flags)
    {
        self.Statement(start, owner);
        self.name = name;
        self.regtype = regtype;
        self.flags = flags;
    }
    function parsemodifiers(var start, var tk)
    {
        ExpectOp("[", tk);
        self.modifiers = new DeclarationModifierList(tk, self.owner);
    }
    function optimizemodifiers()
    {
        var vdata = self.createvar(self.name, self.regtype, self.flags);
        self.reg = vdata.getreg();
        var modifiers = self.modifiers;
        if (modifiers != null) {
            modifiers.optimize();
            string lexname = modifiers.getlexicalname();
            if (lexname != null) {
                // If no name specified, use the variable name.
                if (lexname == "")
                    lexname = self.name;
                var vardata = self.getvar(self.name);
                vardata.createlex(lexname);
            }
        }
    }
}

//*********************************************
//            VarBaseStatement
//*********************************************

class VarBaseStatement : DeclareItem
{
    function initvarbase(var start, var owner, var name, int flags[optional])
    {
        self.DeclareItem(start, owner, name, REGvar, flags);
    }
    function clonevarbase(var from, var owner)
    {
        __ASSERT__(from instanceof VarBaseStatement);
        self.DeclareItem(from.start, owner, from.name, REGvar, from.flags);
    }
}

//*********************************************
//            Declare Statements
//*********************************************

class DeclareBase : DeclareItem
{
    var basetype;

    function DeclareBase(var start, var owner, var name, string basetype, string regtype)
    {
        self.DeclareItem(start, owner, name, regtype, 0);
        self.basetype = basetype;
    }
}

//*********************************************

class DeclareSingleStatement : DeclareBase
{
    var init;

    function DeclareSingleStatement(var start, var owner,
            var name, string basetype, var tk)
    {
        self.DeclareBase(start, owner, name, basetype, basetype);
        var t = tk.get();
        if (t.isop(":")) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop("=")) {
            // Simple initializer
            self.init = parseExpr(tk, self);
        }
        else
            tk.unget(t);
    }
    function clonedeclare(var cloned, var owner)
    {
        cloned.DeclareBase(self.start, owner,
            self.name, self.basetype, self.regtype);
        if (self.init != null)
            cloned.init = self.init.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.optimizemodifiers();
        var init = self.init;
        if (init != null)
            self.init = init.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string name = self.name;
        string reg = self.reg;
        string ireg;
        string basetype = self.basetype;
        var init = self.init;
        if (e.getDebug())
            e.comment(name, ": ", reg);

        if (init == null || init.isnull())
            e.emitnull(reg);
        else {
            string itype = init.checkresult();
            if (itype == basetype)
                init.emit_init(e, reg);
            else {
                if (init instanceof IndexExpr) {
                    // Use the declared type for the indexing
                    init.emit(e, reg);
                }
                else if (init.isliteral()) {
                    switch (basetype) {
                      case REGint:
                        ireg = int_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      case REGfloat:
                        ireg = float_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      case REGstring:
                        ireg = string_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      default:
                        InternalError("Wrong type", self);
                    }
                }
                else {
                    switch (itype) {
                      case REGnone:
                        SyntaxError("Invalid initialization from void value", self);
                      default:
                        ireg = init.emit_get(e);
                    }
                    if (basetype == REGstring && itype == REGvar) {
                        string auxlabel = self.genlabel();
                        e.emitnull(reg);
                        e.emitif_null(ireg, auxlabel);
                        e.emitset(reg, ireg);
                        e.emitlabel(auxlabel);
                    }
                    else
                        e.emitset(reg, ireg);
                }
            }
        }
    }
}

//*********************************************

class DeclareArrayStatement : DeclareBase
{
    var size;
    var initarray;
    var arraytype;

    function DeclareArrayStatement(var start, var owner,
            var name, string basetype, string arraytype,
            var tk)
    {
        self.DeclareBase(start, owner, name, basetype, REGvar);
        self.arraytype = arraytype;
        var t = tk.get();
        if (! t.isop("]")) {
            // Fixed length
            tk.unget(t);
            self.size = parseExpr(tk, self);
            ExpectOp("]", tk);
        }
        t = tk.get();
        if (t.isop(":")) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop("=")) {
            t = tk.get();
            if (! t.isop("["))
                Expected("array initializer", t);
            self.initarray = parseListOrEmpty(tk, self, parseExpr, "]");
        }
        else
            tk.unget(t);
    }
    function clonedeclare(var cloned, var owner)
    {
        cloned.DeclareBase(self.start, owner,
            self.name, self.basetype, REGvar);
        cloned.arraytype = self.arraytype;
        if (self.size)
            cloned.size = self.size.clone(cloned);
        if (self.initarray != null)
            cloned.initarray = clone_array(self.initarray, owner);
        return cloned;
    }
    function optimize()
    {
        self.optimizemodifiers();
        if (self.size != null)
            self.size = self.size.optimize();
        optimize_array(self.initarray);
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);

        string container = self.reg;
        var size = self.size;
        var init = self.initarray;
        var basetype = self.basetype;
        var arraytype = self.arraytype;
        __ASSERT__(arraytype != null);
        if (size != null) {
            // Fixed size array
            e.say(sformat(INDENT + "new %0, ['Fixed%1Array'], %2",
                    container, arraytype, size.emit_get(e)));
        }
        else {
            // Variable size array
            e.say(sformat(INDENT + "new %0, ['Resizable%1Array']",
                    container, arraytype));
        }
        if (init != null) {
            string auxitemreg = self.tempreg(basetype);
            int n = elements(init);
            if (size == null) {
                if (n != 0) {
                    // Allocate initializers size
                    e.emitset(container, n);
                }
            }
            int i = 0;
            for (var item in init) {
                string itemreg;
                if (item.isliteral()) {
                    switch (basetype) {
                      case REGint:
                        itemreg = item.getIntegerValue();
                        break;
                      case REGfloat:
                        itemreg = item.getFloatValue();
                        break;
                      case REGstring:
                        if (item.isstringliteral())
                            itemreg = item.getPirString();
                        else
                            itemreg = quoted(item.getStringValue());
                        break;
                      default:
                        __ASSERT__(false);
                    }
                }
                else {
                    item.emit(e, auxitemreg);
                    itemreg = auxitemreg;
                }
                e.say(sformat(INDENT + "%0[%1] = %2", container, i, itemreg));
                ++i;
            }
        }
    }
}

//*********************************************

function parseDeclareHelper(var funsingle, var funarray,
        var start, var tk, var owner)
{
    var next;
    var r = null;
    do {
        var name = tk.get();
        RequireIdentifier(name);
        var t = tk.get();
        var item;
        if (t.isop("["))
            item = funarray(start, owner, tk, name);
        else {
            tk.unget(t);
            item = funsingle(start, owner, name, tk);
        }
        r = addtomulti(r, item);
        next = tk.get();
    } while (next.isop(","));
    RequireOp(";", next);
    return r;
}

//*********************************************

class IntStatement : DeclareSingleStatement
{
    function IntStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGint, tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new IntStatement, owner);
    }
}

class IntArrayStatement : DeclareArrayStatement
{
    function IntArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGint, "Integer", tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new IntArrayStatement, owner);
    }
}


function newIntSingle(var start, var owner, var name, var tk)
{
    return new IntStatement(start, owner, name, tk);
}

function newIntArray(var start, var owner, var tk, var name)
{
    return new IntArrayStatement(start, owner, name, tk);
}

function parseInt(var start, var tk, var owner)
{
    return parseDeclareHelper(newIntSingle, newIntArray, start, tk, owner);
}

//*********************************************

class FloatStatement : DeclareSingleStatement
{
    function FloatStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGfloat, tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new FloatStatement, owner);
    }
}

class FloatArrayStatement : DeclareArrayStatement
{
    function FloatArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGfloat, "Float", tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new FloatArrayStatement, owner);
    }
}


function newFloatSingle(var start, var owner, var name, var tk)
{
    return new FloatStatement(start, owner, name, tk);
}

function newFloatArray(var start, var owner, var tk, var name)
{
    return new FloatArrayStatement(start, owner, name, tk);
}

function parseFloat(var start, var tk, var owner)
{
    return parseDeclareHelper(newFloatSingle, newFloatArray, start, tk, owner);
}

//*********************************************

class StringStatement : DeclareSingleStatement
{
    function StringStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGstring, tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new StringStatement, owner);
    }
}

class StringArrayStatement : DeclareArrayStatement
{
    function StringArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGstring, "String", tk);
    }
    function clone(var owner)
    {
        return self.clonedeclare(new StringArrayStatement, owner);
    }
}


function newStringSingle(var start, var owner, var name, var tk)
{
    return new StringStatement(start, owner, name, tk);
}

function newStringArray(var start, var owner, var tk, var name)
{
    return new StringArrayStatement(start, owner, name, tk);
}

function parseString(var start, var tk, var owner)
{
    return parseDeclareHelper(newStringSingle, newStringArray, start, tk, owner);
}

//*********************************************
//            ConstStatement
//*********************************************

class ConstStatement : Statement
{
    var type;
    var name;
    var data;
    var value;

    function ConstStatement(var name, var tk, var owner, string type)
    {
        self.Statement(name, owner);
        self.type = type;
        self.name = name;
        self.value = parseExpr(tk, self);
        self.data = self.createconst(name, type);
    }
    function optimize()
    {
        var value = self.value;
        value = value.optimize();
        if (! value.hascompilevalue()) {
            SyntaxError("Value for const is not evaluable at compile time",
                self);
        }
        __ASSERT__(value instanceof Literal);
        switch (self.type) {
          case REGint:
            value = value.getLiteralInteger();
            break;
          case REGfloat:
            value = value.getLiteralFloat();
            break;
          case REGstring:
            value = value.getLiteralString();
            break;
          default:
            InternalError("Wrong const", self.start);
        }
        self.data.setvalue(value);
        return self;
    }
    function checkresult()
    {
        InternalError("Direct use of const", self.start);
    }
    function emit(var e)
    {
        if (e.getDebug()) {
            var val = self.data.getvalue();
            string sval;
            switch (self.type) {
              case REGint:    sval = val.getIntegerValue(); break;
              case REGfloat:  sval = val.getFloatValue(); break;
              case REGstring: sval = val.getPirString(); break;
              default: __ASSERT__(false);
            }
            e.comment("Constant '", self.name, "' set to: ", sval);
        }
    }
}

function parseConst(var start, var tk, var owner)
{
    var t = tk.get();
    string type = t.isidentifier() ? typetoregcheck(t.getidentifier()) : "";
    if (type != REGint && type != REGfloat && type != REGstring)
        SyntaxError("Invalid type for const", t);

    var multi = null;
    do {
        var name = tk.get();
        RequireIdentifier(name);
        ExpectOp("=", tk);
        multi = addtomulti(multi, new ConstStatement(name, tk, owner, type));
    } while ((t = tk.get()).isop(","));
    RequireOp(";", t);
    return multi;
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : VarBaseStatement
{
    var init;
    function VarStatement(var start, var tk, var owner, var name, int flags)
    {
        self.initvarbase(start, owner, name, flags);
        var t = tk.get();
        if (t.isop(":")) {
            self.parsemodifiers(t, tk);
            t = tk.get();
        }
        if (t.isop("=")) {
            self.init = parseExpr(tk, self);
            t = tk.get();
        }
        RequireOp(";", t);
    }
    function clone(var owner)
    {
        :VarStatement cloned;
        cloned.clonevarbase(self, owner);
        if (self.init != null)
            cloned.init = self.init.clone(cloned);
        if (self.modifiers != null)
            cloned.modifiers = self.modifiers.clone(cloned);
        return cloned;
    }
    function optimize_init()
    {
        if (self.init != null)
            self.init = self.init.optimize();
        return self;
    }
    function optimize()
    {
        self.optimizemodifiers();
        return self.optimize_init();
    }
    function emit(var e)
    {
        self.annotate(e);
        string name =  self.name;
        string reg = self.reg;
        var init = self.init;
        if (e.getDebug())
            e.comment("var ", name, ": ", reg);
        if (init != null)
            if (init.isnull())
                init = null;
        if (init != null) {
            switch (init.checkresult()) {
              case REGvar:
                init.emit_init(e, reg);
                break;
              case REGstring:
              case REGint:
              case REGfloat:
                string value = init.emit_get(e);
                e.emitbox(reg, value);
                break;
              case REGnone:
                SyntaxError("Can't use void function as initializer", self);
              default:
                SyntaxError("Invalid var initializer", self);
            }
        }
        else
            e.emitnull(reg);
    }
}

class ResizableVarStatement : VarStatement
{
    function ResizableVarStatement(var start, var tk, var owner, var name)
    {
        self.initvarbase(start, owner, name);
        ExpectOp(";", tk);
    }
    function emit(var e)
    {
        self.annotate(e);
        string reg = self.reg;
        if (e.getDebug())
            e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'ResizablePMCArray'", reg));
    }
}

class FixedVarStatement : VarStatement
{
    var exprsize;

    function FixedVarStatement(var start, var tk, var owner, var name)
    {
        self.initvarbase(start, owner, name);
        self.exprsize = parseExpr(tk, self);
        ExpectOp("]", tk);
        ExpectOp(";", tk);
    }
    function optimize()
    {
        self.exprsize = self.exprsize.optimize();
        return self.optimize_init();
    }
    function emit(var e)
    {
        string regsize = self.exprsize.emit_get(e);
        self.annotate(e);
        string reg = self.reg;
        if (e.getDebug())
            e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'FixedPMCArray', %1", reg, regsize));
    }
}

function parseVar(var start, var tk, var owner, int flags[optional])
{
    var name = tk.get();
    RequireIdentifier(name);
    var t = tk.get();
    if (t.isop("[")) {
        t = tk.get();
        if (t.isop("]"))
            return new ResizableVarStatement(start, tk, owner, name);
        else {
            tk.unget(t);
            return new FixedVarStatement(start, tk, owner, name);
        }
    }
    else {
        tk.unget(t);
        return new VarStatement(start, tk, owner, name, flags);
    }
}

function parseVolatile(var start, var tk, var owner)
{
    var t = tk.get();
    if (!t.iskeyword("var"))
        SyntaxError("invalid volatile type", t);
    return parseVar(start, tk, owner, VAR_is_volatile);
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : MultiStatementBase, BlockStatement
{
    var end;
    var labels;

    function CompoundStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        self.labels = {};
        self.statements = [];
        var t;
        while (! (t = tk.get()).isop("}")) {
            tk.unget(t);
            var c = parseStatement(tk, self);
            if (c == null)
                InternalError("Unexpected null statement");
            push(self.statements, c);
        }
        self.end = t;
    }
    function clone(var owner)
    {
        :CompoundStatement cloned;
        cloned.BlockStatement(self.start, owner);
        cloned.labels = {};
        cloned.end = self.end;
        cloned.statements = clone_array(self.statements, cloned);
        return cloned;
    }
    function last()
    {
        var statements = self.statements;
        for (int i = elements(statements) - 1; i >= 0; --i) {
            var st = statements[i];
            if (st != null && ! st.isempty())
                return st;
        }
        return null;
    }
    function getlabel(string name)
    {
        var labels = self.labels;
        string exist = labels[name];
        if (exist == null || exist == "")
            exist = self.owner.getlabel(name);
        return exist;
    }
    function createlabel(var name)
    {
        string s = name;
        var labels = self.labels;
        string exist = labels[s];
        if (exist != null && exist != "")
            SyntaxError("Label already defined", name);
        string value = self.genlabel();
        labels[s] = value;
        return value;
    }
    function getend() { return self.end; }
    function emit(var e)
    {
        int edebug = e.getDebug();
        if (edebug)
            e.comment("{");
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        if (edebug)
            e.comment("}");
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function RegisterStore(string type)
    {
        self.type = type;
        // Registers number 0 are reserved for temporary usage in builtins.
        self.nreg = 1;
        string tempreg[];
        string freereg[];
        self.tempreg = tempreg;
        self.freereg = freereg;
    }
    function createreg()
    {
        var n = self.nreg;
        int i = n;
        string reg = i++;
        n =: i;
        return "$" + string(self.type) + reg;
    }
    function tempreg()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        string reg;
        if (elements(freereg) != 0)
            reg = freereg.pop();
        else
            reg = self.createreg();
        push(tempreg, reg);
        return reg;
    }
    function freetemps()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        int n = elements(tempreg);
        for (int i = n - 1; i >= 0; --i) {
            string s = tempreg[i];
            push(freereg, s);
        }
        tempreg =: 0;
    }
}

//*********************************************
//            FunctionParameter
//*********************************************

class ParameterModifierList : ModifierList
{
    function ParameterModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function clone(var owner)
    {
        :ParameterModifierList cloned;
        cloned.list = self.clonemodifiers(owner);
        return cloned;
    }
    function emitmodifiers(var e, var start, string paramname)
    {
        var named = null;
        var slurpy = null;
        var modarglist = self.getlist();
        for (var mod in modarglist) {
            string modname = mod.getname();
            switch (modname) {
              case "named":
                named = mod;
                break;
              case "slurpy":
                slurpy = mod;
                break;
              default:
                e.print(" :", modname);
            }
        }
        switch {
          case named != null && slurpy != null:
            // Special case for named slurpy: named refers
            // to the slurpy content, not to the param himself.
            // TODO: check that named has no arguments,
            // or use a different way.
            e.print(" :named :slurpy");
            break;
          case named != null:
            string setname;
            switch (named.numargs()) {
              case 0:
                setname = "'" + paramname + "'";
                break;
              case 1:
                var argmod = named.getarg(0);
                if (! argmod.isstringliteral())
                    SyntaxError("Invalid modifier", start);
                setname = argmod.getPirString();
                break;
              default:
                SyntaxError("Invalid modifier", start);
            }
            e.print(" :named(", setname, ")");
            break;
          case slurpy != null:
            e.print(" :slurpy");
            break;
        }
    }
}

class FunctionParameter
{
    var func;
    var name;
    var modifiers;
    var type;
    var want_multi;
    var classtype;
    var defaultexpr;
    function FunctionParameter(var func, var tk)
    {
        // Syntax: [type] name [modifiers] [ = default]

        self.func = func;
        var t = tk.get();
        string type;
        if (t.isop(":")) {
            self.want_multi = true;
            t = tk.get();
            type = typetoregcheck(t.checkkeyword());
            if (type == "") {
                type = REGvar;
                self.classtype = new ClassSpecifierId(tk, func.owner, t);
            }
            t = tk.get();
        }
        else {
            type = typetoregcheck(t.checkkeyword());
            if (type != "")
                t = tk.get();
            else
                type = REGvar;
        }
        RequireIdentifier(t);
        self.type = type;
        self.name = t;

        // Modifiers
        t = tk.get();
        if (t.isop("[")) {
            self.modifiers = new ParameterModifierList(tk, func.owner);
            t = tk.get();
        }
        // Default value
        if (t.isop("="))
            self.defaultexpr = new FunctionParameterDefault(tk, func, self);
        else
            tk.unget(t);
    }
    function clone(var owner)
    {
        :FunctionParameter cloned;
        cloned.func = owner;
        cloned.name = self.name;
        cloned.type = self.type;
        if (self.modifiers != null)
            cloned.modifiers = self.modifiers.clone(owner.owner);
        return cloned;
    }
    function optimize()
    {
        var func = self.func;
        string argname = "__ARG_" + string(func.generateparamnum());
        func.createvarnamed(self.name, self.type, argname);

        if (self.modifiers != null)
            self.modifiers.optimize();
        var def = self.defaultexpr;
        if (def != null) {
            def.optimize();
            def.setoptflag("__opt_flag" + string(self.getvar().getreg()));
        }
        return self;
    }
    function emit(var e)
    {
        var func = self.func;
        string paramname = self.name;
        var param = self.getvar();
        string ptype = typetopirname(param.gettype());
        e.print(INDENT + INDENT + ".param ", ptype, " ", param.getreg());
        var modarg = self.modifiers;
        if (modarg != null)
            modarg.emitmodifiers(e, func.start, paramname);
        var def = self.defaultexpr;
        if (def != null)
            e.print(" :optional\n" + INDENT + INDENT + ".param int ",
                    def.getoptflag(), " :opt_flag");
        e.say("");
    }
    function emitdefault(var e)
    {
        var def = self.defaultexpr;
        if (def != null)
            def.emit(e);
    }
    function get_type()
    {
        return self.type;
    }
    function wantMulti()
    {
        return self.want_multi != null;
    }
    function get_pir_multi_type()
    {
        var classtype = self.classtype;
        if (classtype == null)
            return typetopirname(self.type);
        var clkey = classtype.checknskey(self.func.owner);
        if (clkey == null)
            SyntaxError("class not found", classtype);
        return clkey.getparrotkey();
    }
    function getvar()
    {
        return self.func.getvar(self.name);
    }
}

class FunctionParameterDefault
{
    var owner;
    var param;
    var expr;
    var reg;
    function FunctionParameterDefault(var tk, var owner, var param)
    {
        self.owner = owner;
        self.param = param;
        self.expr = parseExpr(tk, owner);
    }
    function clone(var owner, var param)
    {
        :FunctionParameterDefault cloned;
        cloned.owner = owner;
        cloned.param = param;
        cloned.expr = self.expr.clone(owner);
        return cloned;
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        var paramvar = self.param.getvar();
    }
    function setoptflag(string reg)
    {
        self.reg = reg;
    }
    function getoptflag()
    {
        var reg = self.reg;
        if (reg == null)
            InternalError("Invalid parameter default usage", self.param);
        return string(reg);
    }
    function emit(var e)
    {
        var expr = self.expr;
        if (! expr.isnull()) {
            var param = self.param;
            var pvar = param.getvar();
            string label = self.owner.genlabel();
            string optflag = self.getoptflag();
            e.emitif(optflag, label);
            string reg = pvar.getreg();
            string type = pvar.gettype();
            if (type == expr.checkresult())
                expr.emit_init(e, reg);
            else {
                var defreg = expr.emit_get(e);
                if (type == REGvar)
                    e.emitbox(reg, defreg);
                else
                    e.emitset(reg, defreg);
            }
            e.emitlabel(label);
        }
    }
}

function parseParameter(var tk, var owner)
{
    return new FunctionParameter(owner, tk);
}

class FunctionParameterList
{
    var paramlist;
    function FunctionParameterList(var tk, var owner)
    {
        self.paramlist = parseList(tk, owner, parseParameter, ")");
    }
    function clone(var owner)
    {
        :FunctionParameterList cloned;
        cloned.paramlist = clone_array(self.paramlist, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.paramlist);
    }
    function emit(var e)
    {
        emit_array(e, self.paramlist);
    }
    function emitdefault(var e)
    {
        for_each(self.paramlist, bindlast(bindmethod("emitdefault"), e));
    }
    function wantMulti()
    {
        for (var param in self.paramlist)
            if (param.wantMulti())
                return true;
        return false;
    }
    function addmultisig(var multi_sig)
    {
        transform(self.paramlist, multi_sig, bindmethod("get_pir_multi_type"));
    }
}

//*********************************************
//            FunctionExtern
//*********************************************

class FunctionExtern : CommonBase
{
    var name;
    function FunctionExtern(var start, var owner)
    {
        self.initbase(start, owner);
        self.name = start;
    }
    function emit_get(var e, var owner)
    {
        var path = self.owner.getpath();
        string reg = owner.tempreg(REGvar);
        self.annotate(e);
        path.emit_get_global(e, owner, reg, self.name);
        return reg;
    }
}

//*********************************************
//            FunctionBase
//*********************************************

function emit_subid(string subid)
{
    return ".const 'Sub' " + subid + " = \"" + subid + "\"\n";
}

class FunctionModifierList : ModifierList
{
    function FunctionModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function emit(var e)
    {
        for (var m in self.getlist()) {
            string name = m.getname();

            if (name == "multi") // Is handled elsewere
                continue;
            int nargmods = m.numargs();
            e.print(" :", name);
            if (nargmods > 0) {
                e.print("(");
                for (int iargmod = 0; iargmod < nargmods; ++iargmod) {
                    var argmod = m.getarg(iargmod);
                    if (!argmod.isstringliteral())
                        SyntaxError("Invalid modifier", argmod);
                    e.print(argmod.getPirString());
                    if (iargmod < nargmods - 1)
                        e.print(", ");
                }
                e.print(")");
            }
        }
    }
}

function multi_sig_from_multi_modifier(var owner, var multi)
{
    int nargs = multi.numargs();
    var sig;
    if (nargs) {
        sig = [];
        for (int i = 0; i < nargs; ++i) {
            var arg = multi.getarg(i);
            switch {
              case arg.isstringliteral():
                push(sig, arg.getStringValue());
                break;
              case arg.isidentifier():
                string name = arg.getName();
                switch (name) {
                  case "int": case "string":
                    push(sig, name); break;
                  case "float":
                    push(sig, "num"); break;
                  case "var":
                    push(sig, "pmc"); break;
                  default:
                    SyntaxError("unsupported multi signature", arg);
                }
                break;
              case arg instanceof OpClassExpr:
                var key = arg.get_class_raw_key();
                if (key == null)
                    SyntaxError("class not found", arg);
                __ASSERT__(key instanceof "ResizableStringArray");
                push(sig, getparrotkey(key));
                break;
              default:
                SyntaxError("unsupported multi signature", arg);
            }
        }
    }
    return sig;
}

class FunctionBase : BlockStatement
{
    var name;
    var subid;
    var modifiers;
    var params;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;
    var localfun;
    var lexicals;
    var usedlexicals;
    var usedsubids;
    var outer;

    function FunctionBase(var start, var owner)
    {
        self.BlockStatement(start, owner);
        self.nlabel = 0;
        self.regstI = new RegisterStore(REGint);
        self.regstN = new RegisterStore(REGfloat);
        self.regstS = new RegisterStore(REGstring);
        self.regstP = new RegisterStore(REGvar);
    }
    function clonebase(var from, var owner)
    {
        self.FunctionBase(from.start, owner);
    }

    function getouter() { return self; }
    function getlexicalouter() { return self; }
    function allowtailcall()
    {
        return true;
    }
    function makesubid()
    {
        // Return the subid for this function, creating if it doesn't have one
        var subid = self.subid;
        if (subid == null)
            self.subid = subid = self.generatesubid();
        return subid;
    }
    function usesubid(string id)
    {
        var used = self.usedsubids;
        if (used == null)
            self.usedsubids = used = {};
        used[id] = 1;
    }

    function same_scope_as(var other)
    {
        int r = self === other;
        return r;
    }
    function parse_parameters(var tk)
    {
        var t = tk.get();
        if (! t.isop(")")) {
            tk.unget(t);
            var params = new FunctionParameterList(tk, self);
            self.params = params;
            if (params.wantMulti()) {
                if (! (self instanceof FunctionStatement))
                    SyntaxError("Can't use multi signatures here", self);
                self.setmulti();
            }
        }
    }

    function addlocalfunction(var fn)
    {
        var localfun = self.localfun;
        if (localfun == null)
            self.localfun = [ fn ];
        else
            push(localfun, fn);
    }
    function usenamespace(var ns)
    {
        __ASSERT__(ns != null);
        var usedns = self.usednamespaces;
        if (usedns == null)
            self.usednamespaces = [ ns ];
        else {
            if (find_same(usedns, ns) != null)
                return;
            push(usedns, ns);
        }
    }
    function scopesearch(var key, int flags)
    {
        for (var ns in self.usednamespaces) {
            var found = ns.scopesearch(key, flags);
            if (found != null)
                return found;
        }
        return self.owner.scopesearch(key, flags);
    }

    function optimize()
    {
        var modifiers = self.modifiers;
        if (modifiers != null) {
            var multi = modifiers.pick("multi");
            if (multi != null) {
                __ASSERT__(self instanceof FunctionStatement);
                self.setmulti();
                self.multi_sig = multi_sig_from_multi_modifier(self, multi);
            }
        }
        if (self.params != null)
            self.params.optimize();
        for_each(self.usednamespaces, bindmethod("fixnamespaces"));
        self.body = self.body.optimize();
        return self;
    }

    function setusedlex(string lexname, string regname)
    {
        var lexicals = self.usedlexicals;
        if (lexicals == null)
            self.usedlexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function setlex(string lexname, string regname)
    {
        var lexicals = self.lexicals;
        if (lexicals == null)
            self.lexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function createlex(var vardata)
    {
        // Get the lexname for a variable, creating it on the fly
        // when needed.
        string lexname = vardata.getlex();
        if (lexname == null) {
            lexname = "'__WLEX_" + string(self.generatelexnum()) + "'";
            vardata.createlex(lexname);
        }
        return lexname;
    }

    function createreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in createreg: " + type);
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in tempreg: " + type);
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for_each([ self.regstI, self.regstN, self.regstS, self.regstP ],
            bindmethod("freetemps"));
    }
    function genlabel()
    {
        int n = ++self.nlabel;
        return "__label_" + string(n);
    }
    function getbreaklabel(var pos)
    {
        SyntaxError("break not allowed here", pos);
    }
    function getcontinuelabel(var pos)
    {
        SyntaxError("continue not allowed here", pos);
    }

    function emit_extra_modifiers(var e) { }

    function emit(var e)
    {
        string name = self.name;
        e.say();
        e.print(".sub ");
        if (self.isanonymous())
            e.print("'' :anon");
        else
            e.print("'", name, "'");
        if (self.subid != null)
            e.print(" :subid('", self.subid, "')");

        var outer = self.outer;
        if (outer != null && self.usedlexicals != null) {
            if (outer instanceof InlinedBlock)
                outer = outer.getlexicalouter();
            var outerid = outer.subid;
            if (outerid != null)
                e.print(" :outer('", outerid, "')");
        }

        // Modifiers
        if (self.ismethod())
            e.print(" :method");
        var modifiers = self.modifiers;
        if (modifiers != null)
            modifiers.emit(e);
        else {
            if (name == "main")
                e.print(" :main");
        }
        self.emit_extra_modifiers(e);
        e.say();

        // Emit Parameters
        var params = self.params;
        if (params != null)
            params.emit(e);

        // Emit .const 'Sub' declarations for used subs
        e.print(join("", transform(self.usedsubids, [], emit_subid)));

        // Emit default values for optional params
        if (params != null)
            params.emitdefault(e);

        // Emit lexicals
        var lexicals = self.lexicals;
        var usedlexicals = self.usedlexicals;
        if (lexicals != null || usedlexicals != null) {
            e.annotate(self.start);
            // lexicals declared in this function and its inner scopes
            for (string l in lexicals)
                e.say(sformat(".lex %0, %1", lexicals[l], l));
            // lexicals from outers used inside
            for (string l in usedlexicals) {
                if (substr(l, 0, 1) != "$")
                    e.say(INDENT + ".local pmc " + l);
                e.emitfind_lex(l, usedlexicals[l]);
            }
        }

        int edebug = e.getDebug();
        var body = self.body;
        if (body.isempty()) {
            if (edebug)
                e.comment("Empty body");
        }
        else {
            if (edebug)
                e.comment("Body");
            body.emit(e);
            e.annotate(body.getend());
        }
        e.say("\n.end # ", name, "\n");

        // Local functions
        for_each(self.localfun, bindlast(bindmethod("emit"), e));
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

class FunctionStatement : FunctionBase
{
    var paramnum;
    var lexnum;
    var is_multi;
    var multi_sig;

    function FunctionStatement(var start, var tk, var owner)
    {
        self.FunctionBase(start, owner);
        self.paramnum = 0;
        self.lexnum = 0;
        self.is_multi = new ["Boolean"];
        self.parse(tk);
    }

    function isanonymous() { return false; }
    function generateparamnum()
    {
        // Get a number to assign unique internal names to params.
        return int(++self.paramnum);
    }
    function generatelexnum()
    {
        // Get a number to assign unique internal names to lexicals.
        return int(++self.lexnum);
    }
    function ismethod() { return false; }

    function ismulti()
    {
        return self.is_multi ? true : false;
    }
    function setmulti()
    {
        self.is_multi =: true;
    }
    function default_multi_sig()
    {
        var multi_sig = [];
        if (self.ismethod())
            push(multi_sig, "_");
        if (self.params != null)
            self.params.addmultisig(multi_sig);
        return multi_sig;
    }
    function parse(var tk)
    {
        var name = tk.get();
        self.name = name;
        var t = tk.get();
        if (t.isop("[")) {
            self.modifiers = new FunctionModifierList(tk, self.owner);
            t = tk.get();
        }
        RequireOp("(", t);
        self.parse_parameters(tk);

        var path = self.owner.getpath().createchild(name.getidentifier());
        createPredefConstString(self, "__FUNCTION__", path.fullname());

        t = tk.get();
        if (!t.isop("{"))
            ExpectedOp("{", t);
        self.body = new CompoundStatement(t, tk, self);
        return self;
    }

    function emit_extra_modifiers(var e)
    {
        if (self.is_multi) {
            var multi_sig = self.multi_sig;
            if (multi_sig == null)
                multi_sig = self.default_multi_sig();
            e.print(" :multi(", join(", ", multi_sig), ")");
        }
    }
}

//*********************************************
//            LocalFunctionStatement
//*********************************************

class LocalFunctionStatement : FunctionBase
{
    function LocalFunctionStatement(var start, var tk, var owner)
    {
        self.FunctionBase(start, owner);
        var outer = owner.getouter();
        int notinline = ! (outer instanceof InlineStatement);
        if (notinline)
            self.activate();

        self.parse_parameters(tk);
        var t = tk.get();
        RequireOp("{", t);
        self.body = new CompoundStatement(t, tk, self);
        if (notinline)
            owner.addlocalfunction(self);
    }
    function clone(var owner)
    {
        :LocalFunctionStatement cloned;
        cloned.clonebase(self, owner);
        cloned.activate();
        if (self.params != null)
            cloned.params = self.params.clone(cloned);
        cloned.body = self.body.clone(cloned);
        owner.addlocalfunction(cloned);
        return cloned;
    }
    function activate()
    {
        var outer = self.owner.getouter();
        outer.makesubid();
        self.outer = outer;
        self.name = self.makesubid();
    }

    function isanonymous() { return true; }
    function ismethod() { return false; }
    function needclosure()
    {
        if (self.lexicals != null || self.usedlexicals != null)
            return true;
        return null != find_if(self.localfun, bindmethod("needclosure"));
    }
    function getsubid()
    {
        return self.subid;
    }
    function generateparamnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.generateparamnum();
    }
    function generatelexnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.generatelexnum();
    }
    function checkvarlexical(var name, var vardata)
    {
        /*
            If the var data is a lexical in some outer scope, create a
            local variable and set it as a used lexical.
            Otherwise, return it unchanged.
        */
        if (vardata.isconst())
            return vardata;
        string reg = vardata.getreg();
        //TEMPORARY WORKAROUND
        if (substr(reg, 0, 6) == "WSubId") {
            self.usesubid(reg);
            return vardata;
        }
        var scope = vardata.getscope();
        var ownerscope = scope.getouter();
        if (ownerscope instanceof FunctionBase || ownerscope instanceof InlinedBlock) {
            if (ownerscope instanceof InlinedBlock)
                ownerscope = ownerscope.getlexicalouter();
            var outer = self.outer;
            if (outer instanceof InlinedBlock)
                outer = outer.getlexicalouter();
            if (ownerscope.same_scope_as(outer)) {
                string lexname = scope.makelexical(vardata);
                int flags = vardata.getflags() | VAR_is_lexical;
                string type = vardata.gettype();
                if (type != REGvar)
                    flags = flags | VAR_is_volatile;
                var localvar = self.createvar(name, vardata.gettype(), flags);
                localvar.setlex(lexname);
                self.setusedlex(lexname, localvar.getreg());
                return localvar;
            }
        }
        return vardata;
    }
    function getvar(var name)
    {
        var localvar = self.getlocalvar(name);
        if (localvar == null)
            localvar = self.getusedvar(name);
        if (localvar == null) {
            // Not found in function scope, search external scopes
            // and check lexicals.
            localvar = self.owner.getvar(name);
            if (localvar == null) {
                // Special case for self in methods
                if (name == SELF) {
                    var ownerscope = self.outer;
                    if (ownerscope instanceof InlinedBlock)
                        ownerscope = ownerscope.getlexicalouter();
                    if (ownerscope.ismethod()) {
                        string lexself = ownerscope.makelexicalself();
                        localvar = self.createvar(name, REGvar);
                        string reg = localvar.getreg();
                        self.setusedlex(lexself, reg);
                    }
                }
            }
            else
                localvar = self.checkvarlexical(name, localvar);
        }
        if (localvar != null && !(localvar instanceof VarData))
            InternalError("Incorrect data for variable in LocalFunction");
        return localvar;
    }
}

//*********************************************
//            MethodStatement
//*********************************************

class MethodStatement : FunctionStatement
{
    function MethodStatement(var t, var tk, var owner)
    {
        self.FunctionStatement(t, tk, owner);
    }
    function ismethod() { return true; }
}

//*********************************************
//            InlineStatement
//*********************************************

class InlineParam : CommonBase
{
    var flags;
    var type;
    var name;
    function InlineParam(var tk, var owner)
    {
        int flags = 0;
        var name = tk.get();
        self.initbase(name, owner);
        if (name.getidentifier() == "const") {
            flags = flags | 1;
            name = tk.get();
        }
        string type;
        var t = tk.get();
        if (t.isop(",") || t.isop(")")) {
            type = REGany;
            tk.unget(t);
        }
        else {
            type = typetoregcheck(name.getidentifier());
            name = t;
        }
        self.flags = flags;
        self.type = type;
        self.name = name;
    }
    function isconst()
    {
        return int(self.flags) & 1;
    }
    function getname()
    {
        return self.name;
    }
    function gettype()
    {
        return self.type;
    }
}

class InlineStatement : BlockStatement, VarContainer
{
    var name;
    var rettype;
    var body;
    var params;
    function InlineStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        var name = tk.get();
        ExpectOp("(", tk);
        var t = tk.get();
        if (! t.isop(")")) {
            tk.unget(t);
            self.params = parseList(tk, owner, function(var tk, var owner)
                {
                    return new InlineParam(tk, self);
                },
            ")");
        }
        t = tk.get();
        string type;
        if (t.iskeyword("return")) {
            t = tk.get();
            string nametype = t.getidentifier();
            type = typetoregcheck(nametype);
            if (type == "")
                SyntaxError("Invalid return type", t);
            t = tk.get();
        }
        else
            type = REGnone;
        RequireOp("{", t);
        tk.unget(t);
        self.body = parseStatement(tk, self);

        self.name = name;
        self.rettype = type;
    }
    function getouter() { return self; }
    function getlexicalouter() { return null; }
    function createreg(string type) { return "FAKEREG"; }
}

class InlinedBlock : BlockStatement
{
    var inliner;
    var inlined;
    var usedsubids;
    var params;
    var args;
    var body;
    var endlabel;
    var retreg;
    function InlinedBlock(var inlined, var inliner, var args)
    {
        self.BlockStatement(inliner.start, inlined);
        self.inliner = inliner;
        self.inlined = inlined;
        var params = inlined.params;
        int nparams = params == null ? 0 : elements(params);
        int nargs = args == null ? 0 : args.numargs();
        if (nparams != nargs)
            SyntaxError("Wrong arguments in inline expansion", inliner);
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            var name = param.getname();
            var arg = args.getfreearg(i);
            string type = param.gettype();
            if (type == REGany)
                type = arg.checkresult();
            int isconst = param.isconst();
            if (isconst && arg.hascompilevalue()) {
                var cdata = self.createconst(name, type);
                cdata.setvalue(arg);
            }
            else
                self.createvar(name, type, 0);
        }
        self.params = params;
        self.args = args;
        var body = inlined.body;
        body = body.clone(self);
        body = body.optimize();
        self.body = body;
    }
    function getouter() { return self; }
    function getlexicalouter() { return self.inliner.owner.getouter(); }
    function islaststatement(var st)
    {
        __ASSERT__(st != null);
        var stcheck = self.body;
        while (stcheck != null && (stcheck instanceof CompoundStatement))
            stcheck = stcheck.last();
        return stcheck === st;
    }
    function generateparamnum()
    {
        return self.getlexicalouter().generateparamnum();
    }
    function addlocalfunction(var fn)
    {
        self.inliner.addlocalfunction(fn);
    }
    function setlex(string lexname, string regname)
    {
        self.getlexicalouter().setlex(lexname, regname);
    }
    function createreg(string type)
    {
        return self.inliner.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.inliner.tempreg(type);
    }
    function freetemps()
    {
        self.inliner.owner.freetemps();
    }
    function makesubid()
    {
        self.getlexicalouter().makesubid();
    }
    function usesubid(string id)
    {
        var used = self.usedsubids;
        if (used == null)
            self.usedsubids = used = {};
        used[id] = 1;
    }
    function genlabel()
    {
        return self.inliner.genlabel();
    }

    function getendlabel()
    {
        var endlabel = self.endlabel;
        if (endlabel == null)
           self.endlabel = endlabel = self.genlabel();
        return string(endlabel);
    }
    function getrettype()
    {
        return self.inlined.rettype;
    }
    function checkresult()
    {
        return self.inlined.rettype;
    }
    function getretreg()
    {
        return self.retreg;
    }
    function emitret(var e, var expr)
    {
        string rettype = self.getrettype();
        if (expr != null) {
            var retreg = self.getretreg();
            if (retreg == null)
                expr.emit_void(e);
            else {
                if (expr.isnull())
                    e.emitnull(retreg);
                else {
                    string type = expr.checkresult();
                    if (type == rettype)
                        expr.emit(e, retreg);
                    else {
                        string reg = expr.emit_get(e);
                        self.annotate(e);
                        if (rettype == REGvar)
                            e.emitbox(retreg, reg);
                        else
                            e.emitset(retreg, reg);
                    }
                }
            }
        }
    }
    function emit_it(var e)
    {
        if (e.getDebug())
            e.comment("inlined start");
        var params = self.params;
        var args = self.args;
        int nparams = params == null ? 0 : elements(params);
        for (int i = 0; i < nparams; ++i) {
            var param = params[i];
            var arg = args.getfreearg(i);
            if (param.isconst() && arg.hascompilevalue())
                continue;
            string type = param.gettype();
            string argtype = arg.checkresult();
            string reg = self.getvar(param.getname()).getreg();
            if (type == REGany || argtype == type)
                arg.emit_init(e, reg);
            else {
                string aux = arg.emit_get(e);
                if (type == REGvar)
                    e.emitbox(reg, aux);
                else
                    e.emitset(reg, aux);
            }
        }
        e.print(join("", transform(self.usedsubids, [], emit_subid)));
        self.body.emit(e);
        var endlabel = self.endlabel;
        if (endlabel != null)
            e.emitlabel(endlabel);
    }
    function emit(var e, string result)
    {
        string type = self.getrettype();
        self.retreg = result;
        int edebug = e.getDebug();
        self.emit_it(e);
        if (e.getDebug())
            e.comment("inlined end");
    }
    function emit_void(var e)
    {
        self.emit_it(e);
        if (e.getDebug())
            e.comment("inlined end");
    }
    function emit_get(var e)
    {
        string type = self.checkresult();
        if (type == REGnone)
            SyntaxError("Cannot get a result from a void inline", self);
        string reg = self.createreg(type);
        self.retreg = reg;
        self.emit_it(e);
        if (type == REGvar) {
            // Let the value be garbage collected when no more used
            var aux = self.tempreg(REGvar);
            e.emitset(aux, reg);
            reg = aux;
        }
        if (e.getDebug())
            e.comment("inlined end");
        return reg;
    }
}

class InlineRef : FinalExpr
{
    var inlined;
    function InlineRef(var owner, var start, var sym)
    {
        __ASSERT__(sym instanceof InlineStatement);
        self.Expr(owner, start);
        self.inlined = sym;
    }
    function checkresult() { return REGnone; }
    function misused()
    {
        SyntaxError("inline used by reference", self.start);
    }
    function emit_void(var e)
    {
        self.misused();
    }
    function emit_get(var e)
    {
        self.misused();
    }
    function emit(var e, string result)
    {
        self.misused();
    }
}

class CallInlineExpr : FinalExpr
{
     var block;
     function CallInlineExpr(var owner, var funref, var args)
     {
        self.Expr(owner, funref.start);
        self.block = new InlinedBlock(funref.inlined, owner, args);
     }
     function checkresult() { return self.block.checkresult(); }
     function emit_void(var e)
     {
         self.block.emit_void(e);
     }
     function emit_get(var e)
     {
         return self.block.emit_get(e);
     }
     function emit(var e, string result)
     {
         self.block.emit(e, result);
     }
}

//*********************************************
//            MultiAssignStatement
//*********************************************

class SigParameter
{
    var owner;
    var name;
    var type;
    var modifiers;
    var defaultexpr;
    function SigParameter(var tk, var owner)
    {
        self.owner = owner;
        var name = tk.get();
        if (! name.isidentifier())
            ExpectedIdentifier(name);
        var t = tk.get();
        if (t.isidentifier()) {
            string type = typetoregcheck(name.checkkeyword());
            self.type = type;
            name = t;
            t = tk.get();
        }
        self.name = name;
        if (t.isop("[")) {
            self.modifiers = new ParameterModifierList(tk, owner);
            t = tk.get();
        }
        if (t.isop("="))
            self.defaultexpr = new FunctionParameterDefault(tk, owner, self);
        else
            tk.unget(t);
    }
    function clone(var owner)
    {
        :SigParameter cloned;
        cloned.owner = owner;
        var name = self.name;
        cloned.name = name;
        var type = self.type;
        if (type != null)
            cloned.type = type;
        if (self.modifiers != null)
            cloned.modifiers = self.modifiers.clone(owner);
        if (self.defaultexpr != null)
            cloned.defaultexpr = self.defaultexpr.clone(owner, cloned);
        return cloned;
    }
    function getvar()
    {
        return self.owner.getvar(self.name);
    }
    function optimize()
    {
        var owner = self.owner;
        var type = self.type;
        if (type != null)
            owner.createvar(self.name, type);
        if (self.modifiers != null)
            self.modifiers.optimize();
        var def = self.defaultexpr;
        if (def != null) {
            def.optimize();
            def.setoptflag(owner.createreg(REGint));
        }
        return self;
    }
    function emit(var e)
    {
        var name = self.name;
        var data = self.owner.getvar(name);
        if (data == null)
            UndefinedVariable(name, name);
        var reg = data.getreg();
        e.print(reg);
        var modifiers = self.modifiers;
        if (modifiers != null) {
            modifiers.emitmodifiers(e, name, name);
        }
        var def = self.defaultexpr;
        if (def != null)
            e.print(" :optional, ", def.getoptflag(), " :opt_flag");
    }
    function emitdefault(var e)
    {
        var def = self.defaultexpr;
        if (def != null)
            def.emit(e);
    }
}

function parseSigParameter(var tk, var owner)
{
    return new SigParameter(tk, owner);
}

class SigParameterList
{
    var params;
    function SigParameterList(var tk, var owner)
    {
        self.params = parseList(tk, owner, parseSigParameter, ")");
    }
    function clone(var owner)
    {
        :SigParameterList cloned;
        cloned.params = clone_array(self.params, owner);
        return cloned;
    }
    function optimize()
    {
        optimize_array(self.params);
    }
    function emit(var e)
    {
        e.print("(");
        string sep = "";
        for (var param in self.params) {
            e.print(sep);
            param.emit(e);
            sep = ", ";
        }
        e.print(")");
    }
    function emitdefaults(var e)
    {
        for_each(self.params, bindlast(bindmethod("emitdefault"), e));
    }
}

class MultiAssignStatement : Statement
{
    var params;
    var expr;
    function MultiAssignStatement(var start, var owner, var params, var expr)
    {
        self.Statement(start, owner);
        self.params = params;
        self.expr = expr;
    }
    function clone(var owner)
    {
        return new MultiAssignStatement(self.start, owner,
                self.params.clone(owner),
                self.expr.clone(owner));
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        self.params.optimize();
        return self;
    }
    function emit(var e)
    {
        var expr = self.expr;
        if (! (expr instanceof CallExpr))
            SyntaxError("multi assignment used with non function call", expr);
        var call = expr.emitcall(e);
        expr.prepareargs(e);
        var params = self.params;
        e.print(INDENT);
        params.emit(e);
        e.print(" = ", call);
        expr.emitargs(e);
        e.say();
        params.emitdefaults(e);
    }
}

//*********************************************
//            Class specifier
//*********************************************

const int
    CLASSSPECIFIER_invalid   = 0,
    CLASSSPECIFIER_str       = 1, // Literal name
    CLASSSPECIFIER_parrotkey = 2, // Parrot key
    CLASSSPECIFIER_id        = 3; // Identifier, maybe qualified

class ClassSpecifier : CommonBase
{
    function ClassSpecifier(var owner, var start)
    {
        self.initbase(start, owner);
    }
    function reftype() { return CLASSSPECIFIER_invalid; }

    function annotate(var e)
    {
        e.annotate(self.start);
    }
}

class ClassSpecifierStr : ClassSpecifier
{
    var name;
    function ClassSpecifierStr(var owner, var name)
    {
        self.ClassSpecifier(owner, name);
        self.name = name;
    }
    function reftype() { return CLASSSPECIFIER_str; }

    function emit(var e, var ns)
    {
        string basestr = self.name.getPirString();
        e.print(basestr);
    }
}

class ClassSpecifierParrotKey : ClassSpecifier
{
    var key;
    var hll;
    function ClassSpecifierParrotKey(var tk, var owner, var start)
    {
        self.ClassSpecifier(owner, start);
        var key = [];
        var t = tk.get();
        if (!t.isstring())
            Expected("literal string", t);
        push(key, t.rawstring());
        t = tk.get();
        if (! t.isop("]")) {
            switch (t.checkop()) {
              case ":":
                self.hll = true;
              case ",":
                break;
              default:
                Unexpected("token in class key", t);
            }
            do {
                t = tk.get();
                if (!t.isstring())
                    Expected("literal string", t);
                push(key, t.rawstring());
            } while ((t = tk.get()).isop(","));
            RequireOp("]", t);
        }
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_parrotkey; }
    function hasHLL()
    {
        return int(self.hll != null);
    }

    function checknskey(var from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }
    function emit(var e, var ns)
    {
        e.print(getparrotkey(self.key));
    }
}

class ClassSpecifierId : ClassSpecifier
{
    var key;
    function ClassSpecifierId(var tk, var owner, var id)
    {
        self.ClassSpecifier(owner, id);
        var key = [ string(id) ];
        var t;
        while ((t = tk.get()).isop(".")) {
            t = tk.get();
            push(key, string(t));
        }
        tk.unget(t);
        self.key = key;
    }
    function clone(var owner)
    {
        :ClassSpecifierId cloned;
        cloned.ClassSpecifier(owner, self.start);
        cloned.key = self.key;
        return cloned;
    }
    function reftype() { return CLASSSPECIFIER_id; }

    function last()
    {
        var key = self.key;
        return key[-1];
    }
    function checknskey(var from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }

    function emit(var e, var ns)
    {
        var key = ns.scopesearch(self.key, SEARCH_CLASS);
        if (key == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.print(getparrotkey(self.key));
        }
        else e.print(key.getclasskey());
    }
    function emit_new(var e, var from, string regnew)
    {
        var nskey = self.checknskey(from);
        if (nskey == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.say("new ", regnew, ", ", getparrotkey(self.key));
        }
        else {
            nskey.emit_new(e, from, regnew);
        }
    }
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassBase : CommonBase
{
    var name;
    var classns;
    function ClassBase(var start, var name, var parent)
    {
        self.initbase(start, parent);
        self.name = name;
        var classns = parent.getpath().createchild(name.getidentifier());
        self.classns = classns;
    }
    function getpath()
    {
        return self.classns;
    }
    function getclasskey()
    {
        return self.classns.getparrotkey();
    }
}

class FunctionContainer
{
    var functions;
    function FunctionContainer()
    {
        self.functions = {};
    }
    function addfunction(var newfunc)
    {
        __ASSERT__((newfunc instanceof Builtin) ||
                   (newfunc instanceof FunctionStatement) ||
                   (newfunc instanceof InlineStatement) ||
                   (newfunc instanceof FunctionExtern));
        var functions = self.functions;
        __ASSERT__(newfunc.name instanceof TokenIdentifier);
        string name = newfunc.name;
        var func = functions[name];
        if (func == null)
            functions[name] = newfunc;
        else {
            if (func instanceof FunctionStatement)
                func.setmulti();
            if (newfunc instanceof FunctionStatement)
                newfunc.setmulti();
        }
    }
    function find(string name)
    {
        var functions = self.functions;
        return functions[name];
    }
}

class ClassStatement : ClassBase, VarContainer
{
    var parent;
    var bases;
    var constants;
    var items;
    var members;
    var funcont;

    function ClassStatement(var start, var name, var parent, var tk)
    {
        self.ClassBase(start, name, parent);
        self.VarContainer();
        self.funcont = new FunctionContainer();
        self.parent = parent;
        var items = [];
        self.items = items;
        var members = [];
        self.members = members;

        var t = tk.get();
        if (t.isop(":")) {
            self.bases = parseList(tk, self, parseClassSpecifier);
            t = tk.get();
        }
        RequireOp("{", t);

        createPredefConstString(self, "__CLASS__", self.classns.fullname());

        for (t = tk.get(); !t.isop("}"); t = tk.get()) {
            switch (t.checkkeyword()) {
              case "function":
                :MethodStatement f(t, tk, self);
                self.addmethod(f);
                push(items, f);
                break;
              case "var":
                var name = tk.get();
                if (! name.isidentifier())
                   Expected("member identifier", name);
                push(members, name);
                t = tk.get();
                if (! t.isop(";"))
                    Expected("';' in member declaration", t);
                break;
              case "const":
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              default:
                Unexpected("item in class", t);
            }
        }
    }
    function getlabel(string name)
    {
        return string(null);
    }
    function addmethod(var func)
    {
        __ASSERT__(func instanceof MethodStatement);
        self.funcont.addfunction(func);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function checkclass(string name)
    {
        return self.parent.checkclass(name);
    }
    function scopesearch(var key, int flags)
    {
        return self.parent.scopesearch(key, flags);
    }
    function use_builtin(string name)
    {
        return self.owner.use_builtin(name);
    }
    function optimize()
    {
        optimize_array(self.items);
        return self;
    }
    function emit(var e)
    {
        self.classns.emitnamespace(e);
        emit_array(e, self.items);

        e.say(".sub Winxed_class_init :anon :load :init");

        e.say(INDENT, "newclass $P0, ", self.getclasskey() );
        int n = 1;
        for (var base in self.bases) {
            base.annotate(e);
            string reg = "$P" + n++;
            e.print(INDENT, "get_class ", reg, ", ");
            base.emit(e, self.parent);
            e.say();
            e.say(INDENT, "addparent $P0, ", reg);
        }
        for (var member in self.members) {
            e.annotate(member);
            e.say(INDENT, "addattribute $P0, '", member, "'");
        }

        e.say(".end");
    }
}

class DeclareClassStatement : ClassBase
{
    function DeclareClassStatement(var start, var name, var parent)
    {
        self.ClassBase(start, name, parent);
    }
    function optimize()
    {
        return self;
    }
    function emit(var e)
    {
    }
}

function parseClass(var start, var tk, var parent)
{
    var name = tk.get();
    var t = tk.get();
    var nskey = [];
    var ns;

    for ( ; t.isop("."); t = tk.get()) {
        nskey.push(name);
        name = tk.get();
    }

    if (t.isop(";")) {
        for (ns in nskey)
            parent = parent.declarenamespace(ns, string(ns));
        parent.declareclass(new DeclareClassStatement(start, name, parent));
    }
    else {
        tk.unget(t);
        for (ns in nskey)
            parent = parent.childnamespace(start, ns, null);
        parent.addclass(new ClassStatement(start, name, parent, tk));
    }
}

//*********************************************
//        Namespace classes and functions
//*********************************************

$include_const "libpaths.pasm";
$include_const "iglobals.pasm";

function open_include(string filename, var start)
{
    var interp = getinterp();

    // Search for the file in the parrot include paths
    var libpaths = interp[IGLOBALS_LIB_PATHS];
    var paths = libpaths[PARROT_LIB_PATH_INCLUDE];
    var file;
    for (string path in paths) {
        string filepath = path + filename;
        try {
            file = open(filepath, "r");
            if (file != null && ! file.is_closed())
                break;
        }
        catch () {
        }
    }
    if (file == null || file.is_closed())
        SyntaxError("File not found", start);
    file.encoding("utf8");
    return file;
}

function include_parrot(var start, var tk, var ns)
{
    var tfile = tk.get();
    if (!tfile.isstring())
        Expected("literal string", tfile);
    ExpectOp(";", tk);

    var sfile = start.file;
    int sline = start.line;
    string filename = tfile.rawstring();
    var file = open_include(filename, start);

    // Parse lines like this: .macro_const CONST_NAME value
    // Assume only integer values for a now
    const string MACRO_CONST = ".macro_const";
    for (string line = file.readline(); !file.eof(); line = file.readline()) {
        if (substr(line, 0, length(MACRO_CONST)) == MACRO_CONST) {
            int pos = length(MACRO_CONST);
            string c;
            while ((c = substr(line, pos, 1)) == " " || c == "\t")
                ++pos;
            int pos2 = pos;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                ++pos2;
            if (pos2 == pos)
                continue;
            string name = substr(line, pos, pos2 - pos);
            while ((c = substr(line, pos2, 1)) == " " || c == "\t")
                ++pos2;
            pos = pos2;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                ++pos2;
            if (pos2 == pos)
                continue;
            string value = substr(line, pos, pos2- pos);

            int ivalue;
            if (substr(value, 0, 2) == "0x" || substr(value, 0, 2) == "0X")
                ivalue = substr(value, 2).to_int(16);
            else
                ivalue = value;
            var tokname = new TokenIdentifier(sfile, sline, name);
            var cst = ns.createconst(tokname, REGint, VAR_is_extern);
            cst.setvalue(integerValue(ns, tokname, ivalue));
        }
    }

    file.close();
}

//*********************************************

function include_winxed(var start, var tk, var ns)
{
    if (! (ns instanceof RootNamespace))
        SyntaxError("Must be used at root namespace level", start);
    var tfile = tk.get();
    if (!tfile.isstring())
        Expected("literal string", tfile);
    ExpectOp(";", tk);

    string filename = tfile.rawstring();
    var file = open_include(filename, start);

    :Tokenizer tkinc(file, filename, false);
    ns.parse(tkinc);

    file.close();
}

//*********************************************

function parsensUsing(var start, var tk, var ns)
{
    var t = tk.get();
    if (t.iskeyword("namespace")) {
        usingNamespace(start, tk, ns);
        ExpectOp(";", tk);
        return;
    }
    if (! t.iskeyword("extern")) {
        tk.unget(t);
        var key = parseDotted(tk);
        int nelems = elements(key);
        if (nelems < 1)
            SyntaxError("Unsupported at namespace level", t);
        ExpectOp(";", tk);
        ns.use(key);
        return;
    }
    t = tk.get();
    switch {
      case t.isstring():
        tk.warn("using extern 'file'; is deprecated, use $loadlib instead.",
                t);
        string reqlib = t;
        ns.addlib(reqlib);
        ExpectOp(";", tk);
        break;
      case t.isidentifier():
        tk.unget(t);
        var module = parseDotted(tk);
        var names = parseListOrEmpty(tk, null, parseIdentifier, ";");
        if (names != null)
            ns.addextern(module, names);
        ns.addload(toModuleFilename(module));
        break;
      default:
        Expected("string literal or identifier", t);
    }
}

//*********************************************

class External
{
    var module;
    var names;
    function External(var module, var names)
    {
        self.module = module;
        self.names = names;
    }
    function emit(var e)
    {
        // Import external symbols in the current namespace

        e.say(<<:
.sub 'importextern' :anon :load :init
    .local pmc ex, curns, srcns, symbols
    ex = new ['Exporter']
    curns = get_namespace
    symbols = new ['ResizableStringArray']
:>>
        );

        e.emitget_root_namespace("srcns",
                "['parrot'; '" + string(join("'; '", self.module)) + "']");

        for_each(self.names,
                function (string name)
                {
                    e.say(INDENT + "push symbols, '", name, "'");
                }
        );
        e.say(<<:
    ex.'destination'(curns)
    ex.'import'(srcns :named('source'), curns :named('destination'), symbols :named('globals'))
.end
:>>
        );
    }
}

class NamespacePath
{
    var hll;
    var path;

    function NamespacePath(string name[optional], int is_hll[optional])
    {
        string path[];
        if (is_hll)
            self.hll = name;
        else {
            if (name != null)
                push(path, name);
        }
        self.path = path;
    }
    function createchild(string name)
    {
        :NamespacePath child;
        child.hll = self.hll;
        var path = clone(self.path);
        push(path, name);
        child.path = path;
        return child;
    }
    function samehllas(var fromns)
    {
        var fromkey = fromns.getpath();
        var hll = self.hll;
        var fromhll = fromkey != null ? fromkey.hll : null;
        if (hll == null)
            return fromhll == null;
        else
            return fromhll == null ? false : hll == fromhll;
    }
    function fullname()
    {
        string name = join(".", self.path);
        if (self.hll != null)
            return string(self.hll) + "." + name;
        else
            return name;
    }
    function getparrotkey()
    {
        var path = self.path;
        string r;
        if (elements(path) != 0)
            r = "[ '" + string(join("'; '", path)) + "' ]";
        return r;
    }
    function getparrotrootkey()
    {
        var path = self.path;
        var hll = self.hll;
        string r = "[ '";
        if (hll != null) {
            // HLL namespace is stored in the root namespace
            // using its name in lower case as key.
            r += downcase(hll);
        }
        else
            r += "parrot";
        r += "'";
        if (elements(path) != 0)
            r += "; '" + string(join("'; '", path)) + "'";
        r += " ]";
        return r;
    }
    function emitnamespace(var e)
    {
        var path = self.path;
        e.print(".namespace [ ");
        if (elements(path) != 0)
            e.print("'", join("'; '", path), "' ");
        e.say("]");
    }
    function emit_new(var e, var fromns, string regnew, string reginit[optional])
    {
        if (self.samehllas(fromns))
            e.print(sformat(INDENT + "new %0, %1",
                    regnew, self.getparrotkey()));
        else
            e.print(sformat(INDENT + "root_new %0, %1",
                    regnew, self.getparrotrootkey()));
        if (reginit != null && reginit != "")
            e.print(reginit);
        e.say();
    }
    function emit_get_namespace(var e, var fromns, string result)
    {
        if (self.samehllas(fromns))
            e.emitget_hll_namespace(result, self.getparrotkey());
        else
            e.emitget_root_namespace(result, self.getparrotrootkey());
    }
    function emit_get_class(var e, var fromns, string result)
    {
        if (self.samehllas(fromns))
            e.say(sformat(INDENT + "get_class %0, %1",
                    result, self.getparrotkey()));
        else {
            // There is no get_root_class. This will work for a now:
            // Get the namespace as root global object, and then get
            // its associated class.
            var hll = self.hll;
            var path = clone(self.path);
            string name = path.pop();
            string shll = hll != null ? downcase(hll) : "parrot";
            if (elements(path) != 0)
                e.say(sformat(
                        INDENT + "get_root_global %0, ['%1'; '%2'], '%3'",
                        result, shll, join("'; '", path), name));
            else
                e.say(sformat(
                        INDENT + "get_root_global %0, ['%1'], '%2'",
                        result, shll, name));
            e.say(sformat(INDENT + "get_class %0, %0", result));
        }
    }
    function emit_get_global(var e, var fromns, string result, string name)
    {
        if (self.samehllas(fromns))
            e.emitget_hll_global(result, name, self.getparrotkey());
        else
            e.emitget_root_global(result, name, self.getparrotrootkey());
    }
}

//*********************************************
//            NamespaceBase
//*********************************************

class NamespaceBase : VarContainer
{
    var nspath;
    var externals;
    var namespaces;
    var classes;
    var funcont;
    var items;
    var owner;

    function NamespaceBase(var nspath, var previous)
    {
        self.VarContainer();
        self.nspath = nspath;
        if (previous == null) {
            self.namespaces = [];
            self.usednamespaces = [];
            self.classes = [];
            self.funcont = new FunctionContainer();
            createPredefConstString(self, "__NAMESPACE__", nspath.fullname());
        }
        else {
            self.locals = previous.locals;
            self.namespaces = previous.namespaces;
            self.usednamespaces = previous.usednamespaces;
            self.classes = previous.classes;
            self.funcont = previous.funcont;
        }
        self.items = [];
    }
    function getlabel(string name)
    {
        return string(null);
    }
    function addfunction(var newfunc)
    {
        self.funcont.addfunction(newfunc);
    }
    function fixnamespaces()
    {
        for_each(self.namespaces, bindmethod("fixnamespaces"));
        var usens = method_fun(self, "usenamespace");
        for_each(self.usednamespaces,
                function (var ns) { for_each(ns.usednamespaces, usens); } );
    }
    function getpath()
    {
        return self.nspath;
    }
    function usenamespace(var nsused)
    {
        if (nsused === self)
            return;
        var usednamespaces = self.usednamespaces;
        if (find_same(usednamespaces, nsused) != null)
            return;
        push(usednamespaces, nsused);
    }
    function use(var key)
    {
        var sym = self.scopesearch(key, 0);
        if (sym != null) {
            if (sym instanceof FunctionStatement)
                self.addfunction(sym);
        }
        else {
            string name = key.pop();
            var ns = self.scopesearch(key, SEARCH_NAMESPACE);
            if (ns != null) {
                sym = ns.getvar(name);
                if (sym != null)
                    self.createvarused(name, sym);
            }
        }
    }
    function getusedns(string name)
    {
        return find_if(self.usednamespaces,
            function (var ns) { return ns.name == name; } );
    }
    function getlocalns(string name)
    {
        var ns = find_if(self.namespaces,
            function (var ns) { return ns.name == name; } );
        if (ns != null)
            return ns;
        return self.getusedns(name);
    }

    function addextern(var module, var names)
    {
        :External ext(module, names);
        var externals = self.externals;
        if (externals == null)
            self.externals = externals = [ ext ];
        else
            push(externals, ext);
    }

    function checkclass_base(string name)
    {
        var cl = find_if(self.classes,
                function (var cl) { return cl.name == name; } );
        if (cl != null)
            return cl;
        for (var ns in self.usednamespaces)
            if ((cl = ns.checkclass_base(name)) != null)
                return cl;
        return null;
    }
    function findsymbolbyname(string name)
    {
        var sym = self.checkclass_base(name);
        if (sym != null)
            return sym;
        var funcont = self.funcont;
        if ((sym = funcont.find(name)) != null)
            return sym;
        if ((sym = self.getlocalvar(name)) != null)
            return sym;
        return null;
    }
    function scopesearchlocal(var key, int flags, int offset)
    {
        // Look for a symbol by its key in this namespace
        // and its childs.
        int keylen = elements(key);
        string name;
        var sym;
        var ns;
        switch (keylen - offset) {
          case 0:
            break;
          case 1:
            name = key[keylen - 1];
            switch (flags) {
              case SEARCH_NAMESPACE:
                return self.getlocalns(name);
              case SEARCH_CLASS:
                return self.checkclass_base(name);
              default:
                // The key contains the name, look by name
                if ((sym = self.findsymbolbyname(name)) != null)
                    return sym;
                for (ns in self.usednamespaces)
                    if ((sym = ns.findsymbolbyname(name)) != null)
                        return sym;
            }
            break;
          default:
            // The key is multi: look for a child namespace named
            // as the first key item, and look into it with the
            // remaining.
            name = key[offset];
            ns = self.getlocalns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
            ns = self.getusedns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
        }
        return null;
    }
    function declarenamespace(var start, string name, var modifier[optional])
    {
        var existns = self.getlocalns(name);
        :NamespaceStatement child(self, start, existns, name, modifier);
        push(self.namespaces, child);
        return child;
    }
    function childnamespace(var start, string name, var modifier)
    {
        var child = self.declarenamespace(start, name, modifier);
        push(self.items, child);
        return child;
    }
    function declareclass(var statement)
    {
        push(self.classes, statement);
    }
    function addclass(var statement)
    {
        push(self.classes, statement);
        push(self.items, statement);
    }
    function parsenamespace(var start, var tk)
    {
        var t = tk.get();
        string name = t;
        t = tk.get();

        var parent = self;
        for ( ; t.isop("."); t = tk.get())
        {
            parent = parent.childnamespace(start, name, null);
            name = tk.get();
        }

        var modifier;
        if (t.isop("["))
        {
            modifier = new ModifierList(tk, self);
            t = tk.get();
        }

        RequireOp("{", t);
        var child = parent.childnamespace(start, name, modifier);
        child.parse(tk);
    }
    function parseextern(var tk)
    {
        //Syntax: extern function_name;

        var t = tk.get();
        if (!t.iskeyword("function"))
            SyntaxError("Unsupported extern", t);
        t = tk.get();
        RequireIdentifier(t);
        ExpectOp(";", tk);
        :FunctionExtern funex(t, self);
        self.addfunction(funex);
    }
    function parse(var tk)
    {
        var items = self.items;
        var t;
        for (t = tk.get(); !(t.iseof() || t.isop("}")); t = tk.get())
        {
            switch (t.checkkeyword()) {
              case "namespace":
                self.parsenamespace(t, tk);
                break;
              case "const":
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              case "function":
                :FunctionStatement f(t, tk, self);
                self.addfunction(f);
                push(items, f);
                break;
              case "inline":
                :InlineStatement inl(t, tk, self);
                self.addfunction(inl);
                break;
              case "class":
                parseClass(t, tk, self);
                break;
              case "extern":
                self.parseextern(tk);
                break;
              case "using":
                parsensUsing(t, tk, self);
                break;
              case "$include_const":
                include_parrot(t, tk, self);
                break;
              case "$include":
                include_winxed(t, tk, self);
                break;
              case "$load":
                t = tk.get();
                if (! t.isstring())
                    Expected("string literal", t);
                ExpectOp(";", tk);
                self.addload((new StringLiteral(self, t)).getPirString());
                break;
              case "$loadlib":
                t = tk.get();
                if (! t.isstring())
                    Expected("string literal", t);
                ExpectOp(";", tk);
                self.addlib((new StringLiteral(self, t)).getPirString());
                break;
              default:
                Unexpected("token", t);
            }
        }
        if (t.iseof())
            self.unclosed_ns();
        else
            self.close_ns(t);
    }
    function optimize_base()
    {
        optimize_array(self.items);
    }
    function emit_base(var e)
    {
        var path = self.getpath();

        int activate = true;

        var externals = self.externals;
        if (externals != null) {
            path.emitnamespace(e);
            activate = false;
            emit_array(e, externals);
        }

        for (var item in self.items) {
            if ((item instanceof NamespaceStatement) ||
                    (item instanceof ClassStatement))
                activate = true;
            else
                if (activate) {
                    path.emitnamespace(e);
                    activate = false;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            NamespaceStatement
//*********************************************

class NamespaceStatement : NamespaceBase
{
    var parent;
    var start;
    var name;
    var modifier;
    var hll;

    function NamespaceStatement(var parent, var start, var previous,
            string name, var modifier)
    {
        self.modifier = modifier;
        int is_hll = false;
        if (modifier != null) {
            if (modifier.pick("HLL") != null) {
                self.hll = name;
                is_hll = true;
            }
        }
        var nspath = is_hll ?
            new NamespacePath(name, true) :
            parent.getpath().createchild(name);
        self.NamespaceBase(nspath, previous);

        self.parent = parent;
        self.start = start;
        self.owner = parent;
        self.name = name;
    }
    function dowarnings()
    {
        return self.parent.dowarnings();
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function addlib(string libname)
    {
        self.parent.addlib(libname);
    }
    function addload(string loadname)
    {
        self.parent.addload(loadname);
    }
    function checkclass(string name)
    {
        var cl = self.checkclass_base(name);
        if (cl == null)
            return self.parent.checkclass(name);
        return cl;
    }
    function scopesearch(var key, int flags, int offset[optional])
    {
        var sym = self.scopesearchlocal(key, flags, offset);
        if (sym == null && offset <= 0)
            return self.parent.scopesearch(key, flags, offset);
        return sym;
    }
    function unclosed_ns()
    {
       SyntaxError("unclosed namespace", self.start);
    }
    function close_ns(var t)
    {
        // Do nothing
    }
    function optimize()
    {
        var modifier = self.modifier;
        if (modifier != null)
            self.modifier = modifier.optimize();
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var hll = self.hll;
        if (hll !=  null)
            e.say(sformat(".HLL '%0'", hll));

        self.emit_base(e);

        if (hll !=  null)
            e.say(".HLL 'parrot'");
    }
}

//*********************************************
//            RootNamespace
//*********************************************

class RootNamespace : NamespaceBase
{
    var unit;
    var bultins_used;
    var libs;
    var loads;
    var subidgen;

    function RootNamespace(var unit)
    {
        self.NamespaceBase(new NamespacePath(), null);
        self.unit = unit;
        self.bultins_used = {};
        self.subidgen = 0;
    }
    function use_builtin(string name)
    {
        var bultins_used = self.bultins_used;
        bultins_used[name] = true;
    }

    function generatesubid()
    {
        int idgen = ++self.subidgen;
        return "WSubId_" + string(idgen);
    }

    function addlib(string libname)
    {
        var libs = self.libs;
        if (libs == null)
            self.libs = libs = {};
        libs[libname] = 1;
    }
    function addload(string name)
    {
        var loads = self.loads;
        if (loads == null)
            self.loads = loads = {};
        loads[name] = 1;
    }
    function checkclass(string name)
    {
        return self.checkclass_base(name);
    }
    function scopesearch(var key, int flags, int offset[optional])
    {
        return self.scopesearchlocal(key, flags, offset);
    }
    function unclosed_ns()
    {
        // Do nothing
    }
    function close_ns(var t)
    {
         SyntaxError("Cannot close root namespace", t);
    }
    function dowarnings()
    {
        return self.unit.dowarnings();
    }
    function optimize()
    {
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var bultins_used = self.bultins_used;

        // chomp uses a library function, load the libray if chomp is used
        if (bultins_used["chomp"] != null)
            self.addload("\"String/Utils.pbc\"");

        // Load trans opcodes if some of its corresponding builtins are used
        for (string trfun in split(" ",
                    "acos asin atan cos exp ln sin tan pow sinh cosh tanh"))
            if (bultins_used[trfun] != null) {
                self.addlib("'trans_ops'");
                break;
            }

        var libs = self.libs;
        if (libs != null)
            e.say(join("\n", transform(libs, [], addprefix(".loadlib "))));

        var loads = self.loads;
        if (loads != null) {
            e.say(sformat(
<<:
.sub initial_load_bytecode :anon :load :init
%0
.end
:>>
                , join("\n", transform(loads, [],
                       addprefix(INDENT + "load_bytecode ")))));
        }
        if (libs != null || loads != null)
            e.comment("end libs");

        self.emit_base(e);
    }
    function emitinclude(var e)
    {
        var locals = self.locals;
        for (string localname in locals) {
            var data = locals[localname];
            if (!(data instanceof VarData) ||
                    data.gettype() != REGint ||
                    data.getflags() & VAR_is_extern)
                continue;
            var value = data.getvalue();
            e.say(".macro_const ", localname, " ", value.getIntegerValue());
        }
    }
}

//*********************************************
//           Compiler classes
//*********************************************

class Builtin
{
    var name;
    var variants;
    function Builtin(string name, var variant)
    {
        self.name = new TokenIdentifier("__builtins__", 0, name);
        self.variants = [ variant ];
    }
    function getname()
    {
        return self.name;
    }
    function addvariant(var variant)
    {
        push(self.variants, variant);
    }
}

const string EVAL_NAME = "__eval__";

class BuiltinBuilder
{
    var entries;
    function BuiltinBuilder()
    {
        self.entries = {};
    }
    function add(var builtin)
    {
        var entries = self.entries;
        string name = builtin.name;
        if (entries[name] != null)
            entries[name].addvariant(builtin);
        else
            entries[name] = new Builtin(name, builtin);
    }
    function put(var ns)
    {
        var entries = self.entries;
        for (string s in entries)
            ns.addfunction(entries[s]);
    }
}

class WinxedCompileUnit
{
    var rootns;
    var warnings;
    var sourcefile;

    function WinxedCompileUnit(string sourcefile, int nowarn, int debug)
    {
        self.sourcefile = sourcefile;
        self.warnings = ! nowarn;
        :RootNamespace rootns(self);

        // Store predefined constants in the root namespace.

        createPredefConstInt(rootns, "false", 0);
        createPredefConstInt(rootns, "true", 1);

        // Tricky way of setting __STAGE__: stage 1 is built with
        // stage 0 and stage 2 is built with stage 1. Increment
        // the current stage and we are done.
        createPredefConstString(rootns, "__STAGE__",
                string(int(__STAGE__) + 1));

        createPredefConstInt(rootns, "__DEBUG__", debug);

        // Propagate value for exception type.
        createPredefConstInt(rootns, "__WINXED_ERROR__", __WINXED_ERROR__);

        // Builtins
        var builtins_ns = rootns.childnamespace(new TokenEof("__builtins__"),
                "Winxed_Builtins", null);
        :BuiltinBuilder builder();
        getbuiltins(builder);
        builder.put(builtins_ns);

        rootns.usenamespace(builtins_ns);

        self.rootns = rootns;
    }
    function dowarnings()
    {
        return int(self.warnings);
    }
    function parse(var tk)
    {
        self.rootns.parse(tk);
        self.rootns.fixnamespaces();
    }
    function optimize()
    {
        self.rootns = self.rootns.optimize();
    }
    function emit(var e)
    {
        e.comment("THIS IS A GENERATED FILE! DO NOT EDIT!");
        e.comment("Compiled with ", string(getVersionString()));
        string sourcefile = self.sourcefile;
        if (sourcefile != null && sourcefile != "")
            e.comment("Source file: ", sourcefile);
        e.comment("Begin generated code");
        e.say("");

        self.rootns.emit(e);

        e.comment("End generated code");
    }
    function emitinclude(var e)
    {
        e.comment("DO NOT EDIT THIS FILE");
        e.comment("Generated automatically from Winxed sources");

        self.rootns.emitinclude(e);

        e.comment("End");
    }
}

//*********************************************

class WinxedHLL
{
    function version()
    {
        return getVersion();
    }
    function version_string()
    {
        return getVersionString();
    }
    function __private_compile_tail(var winxed, var target, var output,
            string filename,
            int debug, int noan, int nowarn)
    {
        if (target == "parse")
            return winxed;
        var handleout;
        if (output == null) {
            handleout  = new ["StringHandle"];
            handleout.open(EVAL_NAME, "w");
        }
        else
            handleout = output;
        :Emit emit(handleout, nowarn);
        if (debug)
            emit.setDebug();
        if (noan)
            emit.disable_annotations();
        winxed.emit(emit);
        emit.close();
        if (output != null)
            return output;
        else {
            handleout.close();
            string pircode = handleout.readall();
            var object;
            switch (target) {
              case "pir":
                object = new ["String"];
                object =: pircode;
                break;
              case "pbc":
              case "":
                var pircomp = compreg("PIR");
                object = pircomp.compile(pircode);
                break;
              default:
                die("Invalid target: " + string(target));
            }
            return object;
        }
    }
    function __private_geninclude(var winxed, var output)
    {
        var handleout;
        if (output == null) {
            handleout = new ["StringHandle"];
            handleout.open(EVAL_NAME, "w");
        }
        else
            handleout = output;
        :Emit emit(handleout, true);
        winxed.emitinclude(emit);
        emit.close();
        if (output != null)
            return output;
        else {
            handleout.close();
            return handleout.readall();
        }
    }
    function compile(string code,
            string target[named,optional],
            var output[named,optional],
            int debug[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        if (target == null)
            target = "";
        var handlein = new ["StringHandle"];
        handlein.open(EVAL_NAME, "w");
        handlein.puts(code);
        handlein.close();
        handlein.open(EVAL_NAME, "r");
        :Tokenizer tk(handlein, EVAL_NAME, nowarn);
        :WinxedCompileUnit winxed("", nowarn, debug);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        if (target == "include")
            return self.__private_geninclude(winxed, output);
        else
            return self.__private_compile_tail(winxed, target, output,
                    EVAL_NAME, debug, noan, nowarn);
    }
    function compile_from_file(string filename,
            string target[named,optional],
            var output[named,optional],
            int debug[named,optional],
            int noan[named,optional],
            int nowarn[named,optional] )
    {
        // output is supposed to be used with pir target for a now,.
        if (target == null)
            target = "";
        var handlein = open(filename, "r");
        handlein.encoding("utf8");
        :Tokenizer tk(handlein, filename, nowarn);
        :WinxedCompileUnit winxed(filename, nowarn, debug);
        winxed.parse(tk);
        handlein.close();
        winxed.optimize();
        if (target == "include")
            return self.__private_geninclude(winxed, output);
        else
            return self.__private_compile_tail(winxed, target, output,
                    filename, debug, noan, nowarn);
    }
}

//*********************************************
//            Initialization
//*********************************************

function initializer [init,load]()
{
    :WinxedHLL comp;
    compreg("winxed", comp);
}

//*********************************************

} // namespace Compiler
} // namespace Winxed

// End
