#! winxed

/***********************************************************************
                   Winxed stage 1 compiler
***********************************************************************/

//*********************************************
//          Character test functions
//*********************************************

function isspace(string c)
{
    return c == " " || c == "\n" || c == "\t" || c == "\r";
}

function isdigit(string c)
{
    return indexof("0123456789", c) > -1;
}

function hexdigit(string c)
{
    int i = indexof("0123456789abcdef0123456789ABCDEF", c);
    if (i >= 16) i = i - 16;
    return i;
}

function isidentstart(string c)
{
    return indexof(
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "_",
        c) > -1;
}

function isident(string c)
{
    return indexof(
        "abcdefghijklmnopqrstuvwxyz" +
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ" + "_$" +
        "0123456789",
        c) > -1;
}

function sformat(string format, var args[slurpy])
{
    var builder = new ["StringBuilder"];
    builder.append_format(format, args:[flat]);
    return string(builder);
}

function quoted(string str)
{
    return "\"" + str + "\"";
}

// Algorithms

function for_each(var src, var func)
{
    for (var item in src)
        func(item);
}

function transform(var src, var dest, var func)
{
    for (var item in src)
        push(dest, func(item));
    return dest;
}

function find_same(var src, var value)
{
    for (var item in src)
        if (item === value)
            return item;
    return null;
}

//*********************************************
//        Error handling exceptions
//*********************************************

const string
    ERR_INTERNAL = "internal",
    ERR_TOKEN    = "tokenizer",
    ERR_PARSER   = "parser";

class WinxedCompilerError
{
    // Payload for compiler exceptions.
    var type;     // internal, tokenizer, parser
    var filename;
    var line;
    var message;

    function WinxedCompilerError(
            string type,
            string message,
            string filename[optional],
            int line[optional])
    {
        self.type = type;
        self.message = message;
        self.filename = filename;
        self.line = line;
    }
}

function Warn(string msg, var pos [optional])
{
    var stderr = getstderr();
    stderr.print("WARNING: ");
    stderr.print(msg);
    if (pos != null) {
        stderr.print(" near ");
        stderr.print(pos.show());
    }
    stderr.print("\n");
}

function InternalError(string msg, var pos [optional], int has_pos [opt_flag])
{
    if (has_pos) {
        pos = pos.getstart();
        string desc = pos.show();
        msg = msg + " near " + desc;
    }
    var payload = has_pos ?
        new WinxedCompilerError(ERR_INTERNAL, msg,
                pos.filename(), pos.linenum()) :
        new WinxedCompilerError(ERR_INTERNAL, msg);
    throw Error(msg, 2, __WINXED_ERROR__, payload);
}

function SyntaxError(string msg, var pos)
{
    if (pos != null)
        pos = pos.getstart();
    int line = pos != null ? pos.linenum() : -1;
    string file = pos != null ? pos.filename() : "UNKNOWN";
    string desc = " near " + string(pos.viewable());
    throw Error(msg + " in " + file + " line " + string(line) + desc,
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_PARSER, msg + desc,
                   file, line));
}

function NoLeftSide(var pos)
{
    SyntaxError("Not a left-side expression", pos);
}

function Expected(string msg, var t)
{
    SyntaxError("Expected " + msg, t);
}

function Unexpected(string msg, var t)
{
    SyntaxError("Unexpected " + msg, t);
}

function ExpectedIdentifier(var t)
{
    SyntaxError("Expected identifier", t);
}

function ExpectedOp(string msg, var t)
{
    SyntaxError("Expected '" + msg + "'", t);
}

function RequireOp(string name, var t)
{
    if (! t.isop(name))
        ExpectedOp(name, t);
}

function RequireKeyword(string name, var t)
{
    if (! t.iskeyword(name))
        ExpectedOp(name, t);
}

function RequireIdentifier(var t)
{
    if (! t.isidentifier())
        ExpectedIdentifier(t);
}

function ExpectOp(string name, var tk)
{
    var t = tk.get();
    RequireOp(name, t);
}

function ExpectKeyword(string name, var tk)
{
    var t = tk.get();
    RequireKeyword(name, t);
}

function UndefinedVariable(string name, var t)
{
    SyntaxError("Variable '" + name + "' is not defined", t);
}

function Redeclared(var t)
{
     SyntaxError("Redeclared '" + string(t.getidentifier()) + "'", t);
}

//*********************************************
//                Token
//*********************************************

class Token
{
    var file;
    var line;
    function Token(string file, int line)
    {
        self.file = file;
        self.line = line;
    }
    function getstart() { return self; }

    function iseof()          { return false; }
    function iscomment()      { return false; }
    function isidentifier()   { return false; }
    function isint()          { return false; }
    function isstring()       { return false; }

    function getintvalue()
    {
        InternalError("Not a literal int", self);
    }
    function rawstring()
    {
        InternalError("Not a literal string", self);
    }
    function getidentifier()
    {
        ExpectedIdentifier(self);
    }
    function iskeyword(string name) { return false; }
    function checkkeyword()         { return false; }
    function isop(string name)      { return false; }
    function checkop() { return ""; }
    function viewable() { return "(unknown)"; }
    function filename() { return self.file; }
    function linenum() { return self.line; }
    function show()
    {
        string r = self.viewable();
        return r + " at " + string(self.file) + " line " + string(self.line);
    }
}

class TokenEof : Token
{
    function TokenEof(string file)
    {
        self.Token(file, 0);
    }
    function iseof() { return true; }
    function viewable() { return "(End of file)"; }
}

class TokenWithVal : Token
{
    var str;
    function TokenWithVal(string file, int line, string str)
    {
        self.Token(file, line);
        self.str = str;
    }
    function get_string[vtable]() { return self.str; }
    function viewable()
    {
        return self.str;
    }
}

class TokenComment : Token
{
    function TokenComment(string file, int line)
    {
        self.Token(file, line);
    }
    function iscomment() { return true; }
    function viewable() { return "(comment)"; }
}

class TokenOp : TokenWithVal
{
    function TokenOp(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isop(string name)
    {
        return self.str == name;
    }
    function checkop()
    {
        return string(self.str);
    }
}

class TokenIdentifier : TokenWithVal
{
    function TokenIdentifier(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isidentifier() { return true; }
    function getidentifier()
    {
        return self.str;
    }
    function checkkeyword()
    {
        return string(self.str);
    }
    function iskeyword(string name)
    {
        return self.str == name;
    }
}

class TokenString : TokenWithVal
{
    function isstring() { return true; }
    function rawstring()
    {
        return self.str;
    }
}

class TokenQuoted : TokenString
{
    function TokenQuoted(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function get_string[vtable]()
    {
        return string(quoted(self.str));
    }
    function viewable()
    {
        return string(quoted(self.str));
    }
    function getasquoted()
    {
        return self.str;
    }
    function getPirString()
    {
        string str = self.str;
        string strunesc;
        try {
            strunesc = unescape(str);
        }
        catch () {
            SyntaxError("Invalid escape sequence in literal string", self);
        }
        int need_encoding = false;
        for (int code in strunesc) {
            if (code > 127) {
                need_encoding = true;
                break;
            }
        }
        str = quoted(escape(strunesc));
        string encoding = need_encoding ? "utf8:" : "";
        return encoding + str;
    }
}

class TokenInteger : TokenWithVal
{
    function TokenInteger(string file, int line, string str)
    {
        self.TokenWithVal(file, line, str);
    }
    function isint() { return true; }
    function getintvalue()
    {
        return int(self.str);
    }
}

//*********************************************
//       Tokenizer auxiliar functions
//*********************************************

function TokenError(string msg, var tk, int line)
{
    throw Error(msg + " in " + string(tk.filename) + " line " + string(line),
            2, __WINXED_ERROR__,
            new WinxedCompilerError(ERR_TOKEN, msg, tk.filename, line));
}

function UnterminatedString(var tk, int line)
{
    TokenError("Unterminated string", tk, line);
}

function UnterminatedHeredoc(var tk, int line)
{
    TokenError("Unterminated heredoc", tk, line);
}

function UnclosedComment(var tk, int line)
{
    TokenError("Unclosed comment", tk, line);
}

function getquoted(var tk, string start, int line)
{
    string s = "";
    string c;
    for (c = tk.getchar(); c != "\""; c = tk.getchar()) {
        switch (c) {
          case "":
          case "\n":
            UnterminatedString(tk, line);
          case "\\":
            // Quick fix for escaped double quotes.
            string c2 = tk.getchar();
            if (c2 == "" || c2 == "\n")
                UnterminatedString(tk, line);
            s = s + c + c2;
            break;
          default:
            s = s + c;
        }
    }
    return new TokenQuoted(tk.filename, line, s);
}

function getheredoc(var tk, string start, int linenum)
{
    string mark = "";
    string c;
    for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
        switch (c) {
          case "":
            UnterminatedHeredoc(tk, linenum);
          case "\r":
            break; // Quick fix for windows line-ending text files
          case "\"":
          case "\\":
            // Encode the mark the same way as the heredoc content
            // to simplify its detection
            mark = mark + "\\" + c;
            break;
          default:
            mark = mark + c;
        }
    }
    mark = mark + ":>>";

    string content = "";
    string line;
    do {
        line = "";
        for (c = tk.getchar(); c != "\n"; c = tk.getchar()) {
            switch (c) {
              case "":
                UnterminatedHeredoc(tk, linenum);
              case "\r":
                break; // Quick fix for windows line-ending text files
              case "\"":
              case "\\":
                line = line + "\\" + c;
                break;
              default:
                line = line + c;
            }
        }
        if (line != mark)
            content = content + line + "\\n";
    } while (line != mark);
    return new TokenQuoted(tk.filename, linenum, content);
}

function getident(var tk, string start, int line)
{
    string s = start;
    string c;
    for (c = tk.getchar(); isident(c); c = tk.getchar())
        s = s + c;
    tk.ungetchar(c);
    return new TokenIdentifier(tk.filename, line, s);
}

function getnumber(var tk, string start, int line)
{
    var filename = tk.filename;
    string c = tk.getchar();
    if (start == "0" && (c == "x" || c == "X")) {
        int hexval = 0, h;
        for (c = tk.getchar(); (h = hexdigit(c)) >= 0; c = tk.getchar())
            hexval = hexval * 16 + h;
        tk.ungetchar(c);
        return new TokenInteger(filename, line, hexval);
    }
    string s = start;
    for ( ; isdigit(c); c = tk.getchar())
        s = s + c;
    if (c == "." || c == "e" || c == "E")
        TokenError("float literals not allowed in stage 1", tk, line);
    tk.ungetchar(c);
    return new TokenInteger(filename, line, s);
}

function getlinecomment(var tk, string start, int line)
{
    string c;
    do
        c = tk.getchar();
    while (c != "" && c != "\n");
    return new TokenComment(tk.filename, line);
}

function getcomment(var tk, string start, int line)
{
    string c = tk.getchar();
    do {
        while (c != "" && c != "*")
            c = tk.getchar();
        if (c == "")
            UnclosedComment(tk, line);
        c = tk.getchar();
        if (c == "")
            UnclosedComment(tk, line);
    } while (c != "/");
    return new TokenComment(tk.filename, line);
}

function getop(var tk, string start, int line)
{
    string s = start;
    return new TokenOp(tk.filename, line, s);
}

//*********************************************
//              Tokenizer
//*********************************************

class Tokenizer
{
    var warnings;
    var h;
    var pending;
    var select;
    var stacked;
    var filename;
    var line;
    function Tokenizer(var handle, string filename, int nowarn)
    {
        self.warnings = new ["Boolean"](! nowarn);
        self.h = handle;
        self.pending = "";
        self.stacked = [];
        self.filename = filename;
        self.line = 1;
        var select = {
            "$": { "": getident, "{": getop },
            "\"": getquoted,
            "=": {
                "=": { "": getop, "=": getop },
                ":": getop
            },
            "+": { "+": getop, "=": getop },
            "-": { "-": getop, "=": getop },
            "|": { "|": getop },
            "&": { "&": getop },
            "<": {
                "<": { "": getop, ":": getheredoc },
                "=": getop
            },
            ">": {
                ">": { "": getop, ">": getop },
                "=": getop
            },
            "!": {
                "=": { "": getop, "=": getop }
            },
            "/": { "/": getlinecomment, "*": getcomment },
            "#": getlinecomment
        };
        self.select = select;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function getchar()
    {
        string c = self.pending;
        if (c != "")
            self.pending = "";
        else {
            var h = self.h;
            c = h.read(1);
            if (c == "\n")
                self.line = self.line + 1;
        }
        return c;
    }
    function ungetchar(string c)
    {
        self.pending = c;
    }
    function get_token()
    {
        if (self.stacked)
            return self.stacked.pop();

        string c = self.getchar();
        while (isspace(c))
                c = self.getchar();
        int line = self.line;
        if (c == "")
            return new TokenEof(self.filename);
        if (isidentstart(c))
            return getident(self, c, line);
        if (isdigit(c))
            return getnumber(self, c, line);

        string op = c;
        var select = self.select;
        var current = select[c];

        while (current != null && (current instanceof "Hash")) {
            c = self.getchar();
            select = current;
            current = select[c];
            if (current == null) {
                self.ungetchar(c);
                current = select[""];
            }
            else
                op = op + c;
        }
        return current != null ?
            current(self, op, line) :
            getop(self, op, line);
    }
    function get(int withcomments [optional])
    {
        var t = self.get_token();
        while (!t.iseof() && !withcomments && t.iscomment())
           t = self.get_token();
        return t;
    }
    function unget(var t)
    {
        push(self.stacked, t);
    }
}

//*********************************************
//          PIR generation values
//*********************************************

// Register types
const string
    REGint =     "I",
    REGfloat =   "N",
    REGstring =  "S",
    REGvar =     "P",
// Pseudotypes for builtins
    REGarglist = "*",
    REGany     = "?",
    REGs_v     = "p", // string or var
    REGraw1    = "!", // raw mode one arg
    REGnone    = "v"; // void return

// Register reserved for temporal and dicardable results
const string DISCARD_IREG = "$I0";
const string DISCARD_NREG = "$N0";
const string DISCARD_SREG = "$S0";
const string DISCARD_PREG = "$P0";

function typetoregcheck(string type)
{
    switch (type) {
    case "int":    return REGint;
    case "float":  return REGfloat;
    case "string": return REGstring;
    case "var":    return REGvar;
    default:       return "";
    }
}

function typetopirname(string regtype)
{
    switch (regtype) {
    case REGint:    return "int";
    case REGfloat:  return "num";
    case REGstring: return "string";
    case REGvar:    return "pmc";
    default:        InternalError("Invalid reg type");
    }
}

//*********************************************
//            Emit
//*********************************************

const string INDENT =      "    ";
const string INDENTLABEL = "  ";

class Emit
{
    var handle;
    var file;
    var line;
    var pendingf;
    var pendingl;
    var debug;
    var noan;
    var warnings;

    function Emit(var handle, int nowarn)
    {
        self.handle = handle;
        self.file = "";
        self.line = 0;
        self.pendingf = false;
        self.pendingl = false;
        self.warnings = new ["Boolean"](! nowarn);
    }
    function setDebug()
    {
        self.debug = true;
    }
    function getDebug()
    {
        return self.debug != null;
    }
    function disable_annotations()
    {
        self.noan = true;
    }
    function close()
    {
        self.handle = null;
    }
    function warn(string msg, var pos [optional])
    {
        if (self.warnings)
            Warn(msg, pos);
    }
    function updateannot()
    {
        if (self.pendingf) {
            self.handle.print(join("", [
                ".annotate 'file', '",
                self.file,
                "'\n" ]
            ));
            self.pendingf = false;
        }
        if (self.pendingl) {
            self.handle.print(join("", [
                ".annotate 'line', ",
                self.line,
                "\n" ]
            ));
            self.pendingl = false;
        }
    }
    function vprint(var args)
    {
        for (var s in args)
            self.handle.print(s);
    }
    function print(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
    }
    function say(var args [slurpy])
    {
        self.updateannot();
        self.vprint(args);
        self.handle.print("\n");
    }
    function annotate(var t)
    {
        if (self.noan == null)
        {
            string file = self.file;
            int line = self.line;
            string tfile = t.file;
            int tline = t.line;
            if (file != tfile) {
                self.file = tfile;
                self.pendingf = true;
                line = 0;
            }
            if (line != tline) {
                self.line = tline;
                self.pendingl = true;
            }
        }
    }
    function comment(var args [slurpy])
    {
        self.updateannot();
        self.handle.print("# " + join("", args) + "\n");
    }
    function emitlabel(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENTLABEL);
        handle.print(label);
        handle.print(":");
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }
    function emitgoto(string label, string comment [optional])
    {
        var handle = self.handle;
        handle.print(INDENT + "goto ");
        handle.print(label);
        if (comment != null)
            handle.print(" # " + comment);
        handle.print("\n");
    }

    function emitarg1(string op, string arg1)
    {
        self.say(INDENT, op, " ", arg1);
    }
    function emitarg2(string op, string arg1, string arg2)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2);
    }
    function emitarg3(string op, string arg1, string arg2, string arg3)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", arg3);
    }
    function emitcompare(string op, string arg1, string arg2, string label)
    {
        self.say(INDENT, op, " ", arg1, ", ", arg2, ", ", label);
    }
    function emitif(string value, string label)
    {
        self.say(INDENT + "if ", value, " goto ", label);
    }
    function emitunless(string value, string label)
    {
        self.say(INDENT + "unless ", value, " goto ", label);
    }
    function emitif_null(string value, string label)
    {
        self.say(INDENT + "if_null ", value, ", ", label);
    }
    function emitunless_null(string value, string label)
    {
        self.say(INDENT + "unless_null ", value, ", ", label);
    }
    function emitnull(string dst)
    {
        self.say(INDENT + "null ", dst);
    }

    function emitinc(string arg)
    {
        self.say(INDENT + "inc ", arg);
    }
    function emitdec(string arg)
    {
        self.say(INDENT + "dec ", arg);
    }
    function emitset(string dst, string src)
    {
        self.say(INDENT + "set ", dst, ", ", src);
    }
    function emitassign(string dst, string src)
    {
        self.say(INDENT + "assign ", dst, ", ", src);
    }
    function emitbox(string dst, string src)
    {
        self.say(INDENT + "box ", dst, ", ", src);
    }
    function emitunbox(string dst, string src)
    {
        self.say(INDENT + "unbox ", dst, ", ", src);
    }
    function emitbinop(string op, string res, string dst, string src)
    {
        self.say(INDENT, op, " ", res, ", ", dst, ", ", src);
    }
    function emitaddto(string dst, string src)
    {
        self.say(INDENT + "add ", dst, ", ", src);
    }
    function emitsubto(string dst, string src)
    {
        self.say(INDENT + "sub ", dst, ", ", src);
    }
    function emitadd(string dst, string src1, string src2)
    {
        self.say(INDENT + "add ", dst, ", ", src1, ", ", src2);
    }
    function emitsub(string dst, string src1, string src2)
    {
        self.say(INDENT + "sub ", dst, ", ", src1, ", ", src2);
    }
    function emitmul(string dst, string src1, string src2)
    {
        self.say(INDENT + "mul ", dst, ", ", src1, ", ", src2);
    }
    function emitdiv(string dst, string src1, string src2)
    {
        self.say(INDENT + "div ", dst, ", ", src1, ", ", src2);
    }
    function emitconcat1(string dst, string src)
    {
        self.say(INDENT + "concat ", dst, ", ", dst, ", ", src);
    }
    function emitconcat(string dst, string src1, string src2)
    {
        self.say(INDENT + "concat ", dst, ", ", src1, ", ", src2);
    }
    function emitprint(string arg)
    {
        self.say(INDENT + "print ", arg);
    }
    function emitsay(string arg)
    {
        self.say(INDENT + "say ", arg);
    }
    function emitget_hll_namespace(string reg, string key)
    {
        self.say(INDENT + "get_hll_namespace ", reg, ", " + key);
    }
    function emitget_root_namespace(string reg, string key)
    {
        self.say(INDENT + "get_root_namespace ", reg, ", " + key);
    }
    function emitget_hll_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_hll_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitget_root_global(string reg, string name, string key[optional])
    {
        self.print(INDENT + "get_root_global ", reg);
        if (key != null)
            self.print(", ", key);
        self.say(", '", name, "'");
    }
    function emitfind_lex(string reg, string name)
    {
        self.say(INDENT + "find_lex ", reg, ", ", name);
    }
    function emitstore_lex(string name, string reg)
    {
        self.say(INDENT + "store_lex ", name, ", ", reg);
    }
}

//*********************************************
//         Helper functions and constants
//*********************************************

// Scope search flags
const int
    SEARCH_NAMESPACE = 1,
    SEARCH_CLASS     = 2;

// Var flags
const int
    VAR_is_volatile = 1,      // volatile qualifier
    VAR_is_lexical  = 2,      // lexicalized local variable
    VAR_is_extern   = 4;      // externaly defined constant, do not export

const string
    NULL = "null",
    SELF = "self";


function integerValue(var owner, var start, int value)
{
    return new IntegerLiteral(owner, start, value);
}

function stringQuotedValue(var owner, var start, string value)
{
    var t = new TokenQuoted(start.file, start.line, value);
    return new StringLiteral(owner, t);
}

function floatresult(string r1, string r2)
/*
    Check if the passed types can give a float result in arithmetic
    operations.
*/
{
    int result = (r1 == REGfloat && (r2 == REGfloat || r2 == REGint)) ||
           (r2 == REGfloat && (r1 == REGfloat || r1 == REGint));
    return result;
}

// Predefined constants

// Fake filename and line number for the tokens.
const string PREDEFCONST_FILENAME = "__predefconst__";
const int PREDEFCONST_LINENUM = 0;

function createPredefConstInt(var scope, string name, int value)
{
    var tid = new TokenIdentifier(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGint, VAR_is_extern);
    cst.setvalue(integerValue(scope, tid, value));
}

function createPredefConstString(var scope, string name, string value)
{
    var tid = new TokenIdentifier(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM,
        name);
    var cst = scope.createconst(tid, REGstring, VAR_is_extern);
    cst.setvalue(new StringLiteral(scope,
        new TokenQuoted(PREDEFCONST_FILENAME, PREDEFCONST_LINENUM, value)));
}

//*********************************************
//             Builtins
//*********************************************

const int
    BULTIN_arglist = -1,
    BULTIN_raw1    = -2;

// Helpers for compile time evaluation

function string_from_literal(var arg)
{
    string value;
    switch {
      case arg.isintegerliteral():
        value = arg.getIntegerValue();
        break;
      case arg.isstringliteral():
        value = arg.getStringValue();
        break;
      default:
        InternalError("wrong call to string_from_literal", arg);
    }
    return value;
}

function int_from_literal(var arg)
{
    int value;
    switch {
      case arg.isintegerliteral():
        value = arg.getIntegerValue();
        break;
      case arg.isstringliteral():
        value = arg.getStringValue();
        break;
      default:
        InternalError("wrong call to int_from_literal", arg);
    }
    return value;
}

// Invokable object generated from a string body
class Builtin_frombody
{
    const string resultmark = "%0";
    var body;
    var typeresult;
    function Builtin_frombody(string typeresult, string bodystr)
    {
        // Minimal sanity check
        int pos = indexof(bodystr, resultmark);
        if (typeresult == REGnone && pos != -1)
            InternalError("void builtin with " + resultmark);
        if (typeresult != REGnone && pos == -1)
            InternalError("non void builtin without " + resultmark);
        switch (typeresult) {
          case REGint: case REGfloat: case REGstring:
          case REGvar: case REGnone:
            break;
          default:
            InternalError("Invalid result type in builtin");
        }

        // Predecorate output
        int l = length(bodystr) - 1;
        if (substr(bodystr, l, 1) == "\n")
            bodystr = substr(bodystr, 0, l);
        bodystr = INDENT + join("\n" + INDENT, split("\n", bodystr));
        self.body = bodystr;
        self.typeresult = typeresult;
    }
    function invoke [vtable](var e, var owner, var start, string result, var args)
    {
        string typeresult = self.typeresult;

        if (typeresult == REGnone) {
            if (result != null && result != "")
                SyntaxError("using return value from void builtin", start);
        }
        else {
            if (result == null || result == "")
                InternalError("Bad result in non void builtin");
        }

        e.annotate(start);
        e.say(sformat(self.body, result, args:[flat]));
    }
}

class BuiltinBase
{
    var name;
    var body;
    var typeresult;
    var type0;
    var type1;
    var type2;
    var type3;
    var nparams;

    function BuiltinBase(string name, var body,
        string typeresult,
        string type0,
        string type1,
        string type2,
        string type3)
    {
        self.name = name;
        if (body instanceof "String")
            self.body = new Builtin_frombody(typeresult, body);
        else
            self.body = body;
        self.typeresult = typeresult;
        int n = 0;
        if (type0 != null) {
            self.type0 = type0;
            switch (type0) {
              case REGarglist:
                n = BULTIN_arglist;
                break;
              case REGraw1:
                n = BULTIN_raw1;
                if (type1 != null)
                    InternalError("Invalid builtin '" + name + "'");
                break;
              default:
                n = 1;
                if (type1 != null) {
                    self.type1 = type1;
                    n = n + 1;
                }
                if (type2 != null) {
                    self.type2 = type2;
                    n = n + 1;
                }
                if (type3 != null) {
                    self.type3 = type3;
                    n = n + 1;
                }
            }
        }
        self.nparams = n;
    }
    function iscompileevaluable() { return false; }
    function name()
    {
        string name = self.name;
        return name;
    }
    function result()
    {
        return self.typeresult;
    }
    function params() { return self.nparams; }
    function paramtype(int i)
    {
        string type;
        switch (i) {
        case 0: type = self.type0; break;
        case 1: type = self.type1; break;
        case 2: type = self.type2; break;
        case 3: type = self.type3; break;
        default:
            InternalError("Invalid builtin arg");
        }
        return type;
    }
    function expand(var e, var owner, var start, string result, var args)
    {
        string name = self.name;

        // Special case for a now.
        if (name != "__ASSERT__")
            e.comment("builtin ", name);

        string typeresult = self.typeresult;
        if (typeresult != REGnone && result == "")
            result = owner.tempreg(typeresult);
        var fun = self.body;
        fun(e, owner, start, result, args);
    }
}

class BuiltinFunction : BuiltinBase
{
    function BuiltinFunction(string name, var body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
    }
}

class BuiltinFunctionEval : BuiltinBase
{
    var evalfun;
    function BuiltinFunctionEval(string name, var evalfun, var body,
        string typeresult,
        string type0[optional],
        string type1[optional],
        string type2[optional],
        string type3[optional])
    {
        self.BuiltinBase(name, body, typeresult, type0, type1, type2, type3);
        self.evalfun = evalfun;
    }
    function iscompileevaluable() { return true; }
}

class Builtin_typecast
{
    var type;
    function Builtin_typecast(string type)
    {
        self.type = type;
    }
    function invoke [vtable](var e, var owner, var start, string result, var args)
    {
        string type = self.type;
        if (elements(args) != 1)
            InternalError("Invalid Builtin_typecast.invoke call");
        var rawarg = args[0];
        string argtype = rawarg.checkresult();
        switch {
          case argtype == type:
          case rawarg instanceof IndexExpr:
            rawarg.emit(e, result);
            break;
          default:
            string arg = rawarg.emit_get(e);
            e.annotate(start);
            // Special case
            if (arg == NULL)
                e.emitnull(result);
            else
                e.emitset(result, arg);
        }
    }
}

function builtineval_stringcast(var owner, var start, var args)
{
    var arg = args[0].arg;
    return stringQuotedValue(owner, start, string_from_literal(arg));
}

function builtineval_intcast(var owner, var start, var args)
{
    var arg = args[0].arg;
    int value = int_from_literal(arg);
    return integerValue(owner, start, value);
}

function Builtin_say(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    int n = elements(args) - 1;
    if (n >= 0) {
        for (int i = 0; i < n; i = i + 1)
            e.emitprint(args[i]);
        e.emitsay(args[n]);
    }
    else
        e.emitsay("''");
}

function emit_printP0(string arg)
{
    return INDENT + "print $P0, " + arg;
}

function Builtin_cry(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    e.say(sformat(
<<:
    getstderr $P0
%0
    print $P0, "\n"
:>>
        , join("\n", transform(args, [], emit_printP0))));
}

function Builtin_print(var e, var owner, var start, string result, var args)
{
    e.annotate(start);
    for (string arg in args)
        e.emitprint(arg);
}

function Builtin_ASSERT(var e, var owner, var start, string result, var args)
{
    __ASSERT__(elements(args) == 1); // Best place to use it

    if (e.getDebug()) {
        e.annotate(start);
        string label = owner.genlabel();
        var arg = args[0];
        var reg = arg.emit_getint(e);
        e.emitif(reg, label);
        e.print(sformat(
<<:
    getstderr $P0
    print $P0, "Assertion failed at '%0' line "
    print $P0, %1
    print $P0, "\n"
    exit 1
:>>
            , start.filename(), start.linenum()));
        e.emitlabel(label);
    }
}

function builtineval_length(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = string_from_literal(arg);
    return integerValue(owner, start, length(s));
}

function builtineval_bytelength(var owner, var start, var args)
{
    var arg = args[0].arg;
    string s = string_from_literal(arg);
    return integerValue(owner, start, bytelength(s));
}

function builtineval_ord(var owner, var start, var args)
{
    int nargs = elements(args);
    var arg = args[0].arg;
    string s = string_from_literal(arg);
    int pos = 0;
    if (nargs > 1) {
        var argpos = args[1].arg;
        pos = int_from_literal(argpos);
    }
    return integerValue(owner, start, ord(s, pos));
}

function builtineval_chr(var owner, var start, var args)
{
    var arg = args[0].arg;
    return stringQuotedValue(owner, start, chr(int_from_literal(arg)));
}

function builtineval_substr(var owner, var start, var args)
{
    int nargs = elements(args);
    var argstr = args[0].arg;
    var argpos = args[1].arg;
    string str = string_from_literal(argstr);
    int pos = int_from_literal(argpos);
    string result;
    if (nargs > 2) {
        var arglen = args[2].arg;
        int len = int_from_literal(arglen);
        result = substr(str, pos, len);
    }
    else
        result = substr(str, pos);
    return stringQuotedValue(owner, start, result);
}

function getbuiltins(var builder)
{
    builder.add(new BuiltinFunctionEval("int",
        builtineval_intcast,
        new Builtin_typecast(REGint),
        REGint, REGraw1
    ));
    builder.add(new BuiltinFunction("float",
        new Builtin_typecast(REGfloat),
        REGfloat, REGraw1
    ));
    builder.add(new BuiltinFunctionEval("string",
        builtineval_stringcast,
        new Builtin_typecast(REGstring),
        REGstring, REGraw1
    ));
    builder.add(new BuiltinFunction("exit",
        "exit %1",
        REGnone, REGint
    ));
    builder.add(new BuiltinFunction("time",
        "time %0",
        REGint
    ));
    builder.add(new BuiltinFunction("floattime",
        "time %0",
        REGfloat
    ));
    builder.add(new BuiltinFunction("spawnw",
        "spawnw %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunction("getstdin",
        "getstdin %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("getstdout",
        "getstdout %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("getstderr",
        "getstderr %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("open",
<<:
root_new %0, ["parrot";"FileHandle"]
%0."open"(%1)
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("open",
<<:
root_new %0, ["parrot";"FileHandle"]
%0."open"(%1,%2)
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
:>>
        , REGvar, REGstring, REGint
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
%0["type"] = %3
:>>
        , REGvar, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction("Error",
<<:
root_new %0, ["parrot";"Exception"]
%0["message"] = %1
%0["severity"] = %2
%0["type"] = %3
%0["payload"] = %4
:>>
        , REGvar, REGstring, REGint, REGint, REGvar
    ));
    builder.add(new BuiltinFunction("elements",
        "elements %0, %1",
        REGint, REGvar
    ));
    builder.add(new BuiltinFunctionEval("length",
        builtineval_length,
        "length %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("bytelength",
        builtineval_bytelength,
        "bytelength %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("chr",
        builtineval_chr,
<<:
chr $S0, %1
find_encoding $I0, "utf8"
trans_encoding %0, $S0, $I0
:>>
        , REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("ord",
        builtineval_ord,
        "ord %0, %1",
        REGint, REGstring
    ));
    builder.add(new BuiltinFunctionEval("ord",
        builtineval_ord,
        "ord %0, %1, %2",
        REGint, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("substr",
        builtineval_substr,
        "substr %0, %1, %2",
        REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunctionEval("substr",
        builtineval_substr,
        "substr %0, %1, %2, %3",
        REGstring, REGstring, REGint, REGint
    ));
    builder.add(new BuiltinFunction("replace",
        "replace %0, %1, %2, %3, %4",
        REGstring, REGstring, REGint, REGint, REGstring
    ));
    builder.add(new BuiltinFunction("indexof",
        "index %0, %1, %2",
        REGint, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("indexof",
        "index %0, %1, %2, %3",
        REGint, REGstring, REGstring, REGint
    ));
    builder.add(new BuiltinFunction("join",
        "join %0, %1, %2",
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("escape",
        "escape %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("unescape",
<<:
$P0 = new ["String"]
$P0 = %1
%0 = $P0."unescape"("utf8")
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("unescape",
<<:
$P0 = new ["String"]
$P0 = %1
%0 = $P0."unescape"(%2)
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("trans_encoding",
<<:
find_encoding $I0, %2
trans_encoding %0, %1, $I0
:>>
        , REGstring, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("encoding_name",
<<:
encoding $I0, %1
encodingname %0, $I0
:>>
        , REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("upcase",
        "upcase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("downcase",
        "downcase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("titlecase",
        "titlecase %0, %1",
        REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("split",
        "split %0, %1, %2",
        REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("push",
        "push %1, %2",
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction("unshift",
        "unshift %1, %2",
        REGnone, REGvar, REGany
    ));
    builder.add(new BuiltinFunction("sqrt",
        "sqrt %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("pow",
        "pow %0, %1, %2",
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("exp",
        "exp %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("ln",
        "ln %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("sin",
        "sin %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("cos",
        "cos %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("tan",
        "tan %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("asin",
        "asin %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("acos",
        "acos %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("atan",
        "atan %0, %1",
        REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("atan",
        "atan %0, %1, %2",
        REGfloat, REGfloat, REGfloat
    ));
    builder.add(new BuiltinFunction("getinterp",
        "getinterp %0",
        REGvar
    ));
    builder.add(new BuiltinFunction("get_class",
        "get_class %0, %1",
        REGvar, REGs_v
    ));
    builder.add(new BuiltinFunction("typeof",
        "typeof %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("find_method",
        "find_method %0, %1, %2",
        REGvar, REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("clone",
        "clone %0, %1",
        REGvar, REGvar
    ));
    builder.add(new BuiltinFunction("compreg",
        "compreg %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("compreg",
        "compreg %1, %2",
        REGnone, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("load_language",
<<:
load_language %1
compreg %0, %1
:>>
        , REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("load_language",
<<:
load_language %1
compreg %0, %2
:>>
        , REGvar, REGstring, REGstring
    ));
    builder.add(new BuiltinFunction("loadlib",
        "loadlib %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("load_bytecode",
        "load_bytecode %1",
        REGnone, REGstring
    ));
    builder.add(new BuiltinFunction("load_packfile",
        "load_bytecode %0, %1",
        REGvar, REGstring
    ));
    builder.add(new BuiltinFunction("sprintf",
        "sprintf %0, %1, %2",
        REGstring, REGstring, REGvar
    ));
    builder.add(new BuiltinFunction("print",
        Builtin_print,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("say",
        Builtin_say,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("cry",
        Builtin_cry,
        REGnone, REGarglist
    ));
    builder.add(new BuiltinFunction("__ASSERT__",
        Builtin_ASSERT,
        REGnone, REGraw1
    ));
}

//*********************************************
//               Auxiliar functions
//*********************************************

function optimize_array(var arr)
{
    int n = arr != null ? elements(arr) : 0;
    for (int i = 0; i < n; i = i + 1)
        arr[i] = arr[i].optimize();
}

function emit_array(var e, var arr)
{
    for (var item in arr)
        item.emit(e);
}

function parseDotted(var tk)
{
    var list = [];
    var t = tk.get();
    if (t.isidentifier()) {
        push(list, t);
        while ((t = tk.get()).isop(".")) {
            t = tk.get();
            push(list, t);
        }
    }
    tk.unget(t);
    return list;
}

function parseList(var tk, var owner, var fn, string oper_end[optional])
/*
  Parse a comma separated list of items.
  Calls the passed fn to parse each item.
*/
{
    var list = [];
    var t;
    do {
        var value = fn(tk, owner);
        push(list, value);
    } while ((t = tk.get()).isop(","));
    if (oper_end == null)
        tk.unget(t);
    else
        if (! t.isop(oper_end))
            SyntaxError("Unfinished argument list", t);
    return list;
}

function parseListOrEmpty(var tk, var owner, var fn, string oper_end)
/*
  Parse a comma separated list of items.
  Calls the passed fn to parse each item.
  Return null if empty.
*/
{
    var t = tk.get();
    if (t.isop(oper_end))
        return null;
    tk.unget(t);
    var list = [];
    do {
        var value = fn(tk, owner);
        push(list, value);
    } while ((t = tk.get()).isop(","));
    if (! t.isop(oper_end))
        SyntaxError("Unfinished argument list", t);
    return list;
}

// Helper to parse identifier lists using parseList
function parseIdentifier(var tk, var unused)
{
    var t = tk.get();
    if (!t.isidentifier())
        ExpectedIdentifier(t);
    return t;
}

function toIdentifierList(var tlist)
{
    string list[];
    for (var t in tlist)
        push(list, t.getidentifier());
    return list;
}

function toModuleFilename(var tlist)
{
    return "\"" + join("/", toIdentifierList(tlist)) + ".pbc\"";
}

//*********************************************
//               CommonBase
//*********************************************

class CommonBase
{
    var start;
    var owner;

    function initbase(var start, var owner)
    {
        __ASSERT__(start instanceof Token);
        __ASSERT__((owner instanceof Statement) ||
                   (owner instanceof ClassStatement) ||
                   (owner instanceof NamespaceBase));
        self.start = start;
        self.owner = owner;
    }
    function getstart()
    {
        return self.start;
    }
    function viewable()
    {
        if (self.start != null)
            return self.start.viewable();
        else
            return "";
    }
    function annotate(var e)
    {
        e.annotate(self.start);
    }
    function getpath()
    {
        return self.owner.getpath();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function usesubid(string id)
    {
        self.owner.usesubid(id);
    }
    function addlocalfunction(var fn)
    {
        return self.owner.addlocalfunction(fn);
    }
    function scopesearch(var key, int flags)
    {
        return self.owner.scopesearch(key, flags);
    }
    function dowarnings()
    {
        return self.owner.dowarnings();
    }
}

//*********************************************
//             CollectValues
// Emit an get registers for a collection of
// values avoiding redundant setting of null
// registers.
//*********************************************

class CollectValues
{
    var owner;
    var e;
    var pnull;
    function CollectValues(var owner, var e)
    {
        self.owner = owner;
        self.e = e;
    }
    function add(var value)
    {
        __ASSERT__(value instanceof Expr);
        var e = self.e;
        string valuereg;
        if (value.isnull()) {
            var pnull = self.pnull;
            if (pnull == null) {
                string regnull = self.owner.tempreg(REGvar);
                e.emitnull(regnull);
                self.pnull = pnull = regnull;
            }
            valuereg = pnull;
        }
        else
            valuereg = value.emit_get(e);
        return valuereg;
    }
}

//*********************************************
//          SimpleArgList
//*********************************************

// A list of arguments without modifiers.

class SimpleArgList
{
    var args;

    function SimpleArgList(var tk, var owner, string oper_end)
    {
        self.args = parseList(tk, owner, parseExpr, oper_end);
    }

    function numargs()
    {
        return elements(self.args);
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }

    function optimizeargs()
    {
        optimize_array(self.args);
    }
    function getargvalues(var e)
    {
        var argreg = [];
        for (var a in self.args)
            push(argreg, a.emit_get(e));
        return argreg;
    }
    function emitargs(var e)
    {
        e.print(join(", ", self.getargvalues(e)));
    }
}

//*********************************************
//            Modifiers
//*********************************************

class Modifier
{
    var name;
    var args;

    function getname() { return self.name; }
    function numargs()
    {
        var args = self.args;
        int nargs = args == null ? 0 : args.numargs();
        return nargs;
    }
    function getarg(int argnum)
    {
        var args = self.args;
        if (argnum >= args.numargs())
            InternalError("Wrong modifier arg number");
        return args.getarg(argnum);
    }
    function Modifier(string name, var args)
    {
        self.name = name;
        if (args != null)
            self.args = args;
    }
    function optimize()
    {
        if (self.args != null)
            self.args.optimizeargs();
        return self;
    }
}

function parseModifier(var tk, var owner)
{
    var t = tk.get();
    string name = t.getidentifier();
    t = tk.get();
    var args;
    if (t.isop("("))
        args = new SimpleArgList(tk, owner, ")");
    else
        tk.unget(t);
    return new Modifier(name, args);
}


class ModifierList
{
    var list;

    function ModifierList(var tk, var owner)
    {
        self.list = parseList(tk, owner, parseModifier, "]");
    }
    function optimize()
    {
        optimize_array(self.list);
    }
    function getlist() { return self.list; }
    function pick(string name)
    {
        for (var mod in self.list) {
            if (mod.getname() == name)
                return mod;
        }
        return null;
    }
}

//*********************************************
//       Auxiliary classes and functions
//*********************************************

function getparrotkey(var path)
{
    string r;
    if (elements(path) != 0)
        r = "[ '" + string(join("'; '", path)) + "' ]";
    return r;
}

function parseUsing(var t, var tk, var owner)
{
    var taux = tk.get();
    switch {
      case taux.iskeyword("extern"):
        return new ExternStatement(t, tk, owner);
      case taux.iskeyword("namespace"):
        return new UsingNamespaceStatement(taux, tk, owner);
      default:
        tk.unget(taux);
        return new UsingStatement(t, tk, owner);
    }
}

function parseSig(var start, var tk, var owner)
{
    var params = new SigParameterList(tk, owner);
    var t = tk.get();
    if (! t.isop("="))
        Expected("'='", t);
    var expr = parseExpr(tk, owner);
    return new MultiAssignStatement(start, owner, params, expr);
}

function parseClassSpecifier(var tk, var owner)
{
    var t = tk.get();
    if (t.isstring())
        return new ClassSpecifierStr(owner, t);
    if (t.isop("["))
        return new ClassSpecifierParrotKey(tk, owner, t);
    if (t.isidentifier())
        return new ClassSpecifierId(tk, owner, t);
    SyntaxError("Invalid class", t);
}

function parseStatement(var tk, var owner)
{
    var t = tk.get();
    var t2;
    if (t.isop(";"))
        return new EmptyStatement;
    if (t.isop("{"))
        return new CompoundStatement(t, tk, owner);
    if (t.isop(":")) {
        var open = tk.get();
        switch {
          case open.isop("("):
            return parseSig(t, tk, owner);
          case open.isidentifier():
            // EXPERIMENTAL
            var cl = new ClassSpecifierId(tk, owner, open);
            var tname = tk.get();
            RequireIdentifier(tname);

            // Violating encapsulation for fun and profit!
            var varst = new VarStatement;
            varst.initvarbase(tname, owner, tname, 0);
            var newexpr = new NewQualifiedExpr;
            newexpr.Expr(varst, tname);
            newexpr.nskey = cl;
            t = tk.get();
            if (t.isop("(")) {
                newexpr.parseinitializer(tk);
                t = tk.get();
            }
            RequireOp(";", t);
            varst.init = newexpr;

            return varst;
          default:
            Unexpected("':'", t);
        }
    }

    switch (t.checkkeyword()) {
      case "using":
        return parseUsing(t, tk, owner);
      case "const":
        return parseConst(t, tk, owner);
        break;
      case "volatile":
        return parseVolatile(t, tk, owner);
        break;
      case "var":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseVar(t, tk, owner);
        break;
      case "string":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseString(t, tk, owner);
        break;
      case "int":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseInt(t, tk, owner);
        break;
      case "float":
        t2 = tk.get();
        tk.unget(t2);
        if (! t2.isop("("))
            return parseFloat(t, tk, owner);
        break;
      case "return":
        return new ReturnStatement(t, tk, owner);
      case "if":
        return new IfStatement(t, tk, owner);
      case "while":
        return new WhileStatement(t, tk, owner);
      case "do":
        return new DoStatement(t, tk, owner);
      case "continue":
        return new ContinueStatement(t, tk, owner);
      case "break":
        return new BreakStatement(t, tk, owner);
      case "switch":
        return parseSwitch(t, tk, owner);
      case "for":
        return parseFor(t, tk, owner);
      case "throw":
        return new ThrowStatement(t, tk, owner);
      case "try":
        return new TryStatement(t, tk, owner);
    }

    tk.unget(t);
    return new ExprStatement(t, tk, owner);
}

//*********************************************
//            Statement
//*********************************************

class Statement : CommonBase
{
    function Statement(var start, var owner)
    {
        self.initbase(start, owner);
    }
    function isempty() { return false; }
    function createreg(string type)
    {
        return self.owner.createreg(type);
    }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function freetemps()
    {
        self.owner.freetemps();
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function createconst(var name, string type, int flags [optional])
    {
        return self.owner.createconst(name, type, flags);
    }
    function createvar(var name, string type, int flags[optional])
    {
        return self.owner.createvar(name, type, flags);
    }
    function createvarused(var name, var data)
    {
        return self.owner.createvarused(name, data);
    }
    function createvarnamed(var name, string type, string pirname)
    {
        return self.owner.createvarnamed(name, type, pirname);
    }
    function getvar(var name)
    {
        return self.owner.getvar(name);
    }
    function checkclass(string name)
    {
        return self.owner.checkclass(name);
    }
    function usenamespace(var ns)
    {
        self.owner.usenamespace(ns);
    }

    function getouter()
    {
        // Returns the nearest outer scope. In this base case,
        // just propagate it. Deriveds that are appropiate
        // scopes will override.
        return self.owner.getouter();
    }
    function getcontinuelabel(var pos)
    {
        return self.owner.getcontinuelabel(pos);
    }
    function getbreaklabel(var pos)
    {
        return self.owner.getbreaklabel(pos);
    }
    function optimize()
    {
        InternalError("**checking**", self.start);
        // Return unchanged by default
        return self;
    }
}

class EmptyStatement : Statement
{
    function isempty() { return true; }
    function annotate(var e)
    {
        InternalError("Attempt to annotate empty statement");
    }
    function optimize() { return self; }
    function emit(var e)
    {
        // Do nothing
    }
}

class MultiStatementBase
{
    var statements;

    function optimize()
    {
        var statements = self.statements;
        int n = elements(statements);
        int empty = true;
        for (int i = 0; i < n; i = i + 1) {
            var st = statements[i].optimize();
            if (empty && ! st.isempty())
                empty = false;
            statements[i] = st;
        }
        return empty ? new EmptyStatement : self;
    }
}

class MultiStatement : MultiStatementBase
{
    function MultiStatement(var st1, var st2)
    {
        var statements = [st1, st2];
        self.statements = statements;
    }
    function isempty() { return false; }
    function push(var statement)
    {
        push(self.statements, statement);
        return self;
    }
    function emit(var e)
    {
        emit_array(e, self.statements);
    }
}

function addtomulti(var multi, var newst)
{
    switch {
      case multi == null:
        return newst;
      case multi instanceof MultiStatement:
        return multi.push(newst);
      default:
        return new MultiStatement(multi, newst);
    }
}

//*********************************************
//            ExternStatement
//*********************************************

class ExternStatement : Statement
{
    var path;
    function ExternStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(";", tk);
        self.path = toIdentifierList(path);
        return self;
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        e.say(INDENT, "load_bytecode '", join("/", self.path), ".pbc'");
    }
}

//*********************************************
//            UsingStatement
//*********************************************

class UsingStatement : Statement
{
    var path;
    var subid;

    function UsingStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var path = parseDotted(tk);
        if (elements(path) == 0)
            ExpectedIdentifier(tk.get());
        ExpectOp(";", tk);
        self.path = path;
    }
    function optimize()
    {
        var path = self.path;
        var name = path[-1];

        var symbol = self.scopesearch(path, 0);
        switch {
          case symbol == null:
            if (elements(path) != 0) {
                var p = clone(path);
                p.pop();
                var ns = self.scopesearch(p, SEARCH_NAMESPACE);
                if (ns != null) {
                    symbol = ns.getvar(name);
                    if (symbol != null) {
                        self.createvarused(name, symbol);
                        return new EmptyStatement;
                    }
                }
            }
            break;
          case symbol instanceof FunctionStatement:
            string subid = symbol.makesubid();
            self.createvarnamed(name, REGvar, subid);
            self.subid = subid;
            self.usesubid(subid);
            return self;
        }
        self.createvar(name, REGvar);
        return self;
    }
    function emit(var e)
    {
        var path = self.path;
        string name = path[-1];
        var vdata = self.getvar(name);
        if (self.subid == null) {
            self.annotate(e);
            string key;
            if (elements(path) > 1) {
                path.pop();
                key = getparrotkey(path);
            }
            e.emitget_hll_global(vdata.getreg(), name, key);
        }
    }
}

//*********************************************
//            UsingNamespaceStatement
//*********************************************

// Common part of using namespace from different kinds of scopes.
function usingNamespace(var start, var tk, var owner)
{
    var nskey = parseDotted(tk);
    if (elements(nskey) == 0)
        Expected("namespace identifier", start);
    var nssym = owner.scopesearch(nskey, SEARCH_NAMESPACE);
    if (nssym == null)
        SyntaxError("unknow namespace", start);
    owner.usenamespace(nssym);
}

class UsingNamespaceStatement : Statement
{
    function UsingNamespaceStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        usingNamespace(start, tk, owner);
        ExpectOp(";", tk);
    }
    function optimize()
    {
        return self;
    }
    function emit(var e)
    {
    }
}

//*********************************************
//            ExprStatement
//*********************************************

class ExprStatement : Statement
{
    var expr;
    function ExprStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var expr = [];
        var t;
        do {
            var newexpr = parseExpr(tk, self);
            expr.push(newexpr);
        } while((t = tk.get()).isop(","));
        RequireOp(";", t);
        self.expr = expr;
    }
    function optimize()
    {
        optimize_array(self.expr);
        return self;
    }
    function emit(var e)
    {
        for (var item in self.expr)
            item.emit_void(e);
    }
}

//*********************************************
//            VarContainer
//*********************************************

class VarData
{
    var type;
    var reg;
    var scope;
    var flags;
    var lexname;

    function VarData(string type, var reg, var scope, int flags)
    {
        // Sanity check
        __ASSERT__(type == REGint || type == REGfloat || type == REGstring ||
                type == REGvar);

        self.type = type;
        self.reg = reg;
        self.scope = scope;
        self.flags = flags;
    }
    function setlex(string name)
    {
        self.lexname = name;
    }
    function createlex(string lexname)
    {
        // Set the lexname and make the variable a lexical
        // in its outer.
        self.setlex(lexname);
        self.getscope().getouter().setlex(lexname, self.reg);
    }
    function gettype() { return self.type; }
    function getreg() { return self.reg; }
    function getscope() { return self.scope; }
    function getvalue() { return self.value; }
    function isconst() { return false; }
    function getlex()
    {
        var lexname = self.lexname;
        return lexname != null ? string(lexname) : null;
    }
    function getflags() { return self.flags; }
    function issubid()
    {
        var reg = self.reg;
        return reg != null && substr(reg, 0, 7) == "WSubId_";
    }
}

class ConstantInternalFail
{
    var name;
    function ConstantInternalFail(var name)
    {
        self.name = name;
    }
    function get_string[vtable]()
    {
        InternalError("Attempt to use unexpanded constant!!!", self.name);
    }
}

class VarData_const : VarData
{
    var value;

    function VarData_const(string type, var name, var scope, int flags)
    {
        self.VarData(type, new ConstantInternalFail(name), scope, flags);
    }
    function isconst() { return true; }
    function setvalue(var value)
    {
        if (self.value != null)
            InternalError("Attempt change value of constant!!!");
        self.value = value;
    }
}


class VarContainer
{
    var locals;
    var usednamespaces;

    function VarContainer()
    {
        self.locals = {};
    }
    function createvar(var name, string type, int flags[optional])
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name.getidentifier();
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        string reg = self.createreg(type);
        var data = new VarData(type, reg, self, flags);
        locals[sname] = data;
        return data;
    }
    function createvarused(var name, var data)
    {
        var locals = self.locals;
        string sname = name;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        locals[sname] = data;
    }
    function createvarnamed(var name, string type, string pirname)
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name.getidentifier();
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        locals[sname] = new VarData(type, pirname, self, 0);
    }
    function createconst(var name, string type, int flags[optional])
    {
        __ASSERT__(name instanceof TokenIdentifier);
        string sname = name.getidentifier();
        var locals = self.locals;
        var exist = locals[sname];
        if (exist != null)
            Redeclared(name);
        var data = new VarData_const(type, name, self, flags);
        locals[sname] = data;
        return data;
    }
    function getlocalvar(var name)
    {
        var locals = self.locals;
        return locals[string(name)];
    }
    function getusedvar(var name)
    {
        var sym;
        for (var ns in self.usednamespaces) {
            if ((sym = ns.getlocalvar(name)) != null)
                return sym;
        }
        return null;
    }
    function getvar(var name)
    {
        var sym;
        if ((sym = self.getlocalvar(name)) != null)
            return sym;
        if ((sym = self.getusedvar(name)) != null)
            return sym;
        var owner = self.owner;
        if (owner != null)
            return owner.getvar(name);
        return null;
    }
    function makelexical(var vardesc)
    {
        var lexowner = self.getouter();
        string lexname = lexowner.createlex(vardesc);
        return lexname;
    }
    function makelexicalself()
    {
        const string lexname = "'__WLEX_self'";
        self.setlex(lexname, SELF);
        return lexname;
    }
}

//*********************************************
//            BlockStatement
//*********************************************

// A BlockStatement is a Statement that can have local variables.

class BlockStatement : VarContainer, Statement
{
    function BlockStatement(var start, var owner)
    {
        self.Statement(start, owner);
        self.VarContainer();
    }
}

//*********************************************
//            Expr
//*********************************************

class Expr : CommonBase
{
    function Expr(var owner, var start)
    {
        self.initbase(start, owner);
    }
    function issimple() { return false; }
    function isliteral() { return false; }
    function isintegerliteral() { return false; }
    function isintegerzero() { return false; }
    function isstringliteral() { return false; }
    function isidentifier() { return false; }
    function isnull() { return false; }
    function hascompilevalue() { return false; }
    function isnegable() { return false; }
    function tempreg(string type)
    {
        return self.owner.tempreg(type);
    }
    function genlabel()
    {
        return self.owner.genlabel();
    }
    function optimize()
    {
        // By default return same expression unchanged
        return self;
    }
    function emit_init(var e, string result)
    {
        // By default does the same as plane emit, some expressions
        // can override it for optimization.
        self.emit(e, result);
    }
    function emit_get(var e)
    {
        string reg = self.tempreg(self.checkresult());
        self.emit(e, reg);
        return reg;
    }
    function emit_void(var e)
    {
        string type = self.checkresult();
        string reg;
        switch (type) {
          case REGint:    reg = DISCARD_IREG; break;
          case REGfloat:  reg = DISCARD_NREG; break;
          case REGstring: reg = DISCARD_SREG; break;
          case REGvar:    reg = DISCARD_PREG; break;
          default:
            InternalError("Unexcpected emit_void with type '" + type + "'", self.start);
        }
        self.emit(e, reg);
    }
    function emit_get_nonull(var e)
    {
        // Must be overriden by any possible null
        return self.emit_get(e);
    }
    function emit_getint(var e)
    {
        string reg = self.emit_get_nonull(e);
        if (self.checkresult() != REGint) {
            string aux = self.tempreg(REGint);
            self.annotate(e);
            e.emitset(aux, reg);
            reg = aux;
        }
        return reg;
    }
    function emit_getvar(var e)
    {
        string type = self.checkresult();
        string reg = self.emit_get(e);
        if (type != REGvar) {
            string auxreg = reg;
            reg = self.tempreg(REGvar);
            e.emitbox(reg, auxreg);
        }
        return reg;
    }
    function emit_assign_get(var e, var expr)
    {
        NoLeftSide(self);
    }
}

class SimpleExpr : Expr
{
    function issimple() { return true; }
}


class FinalExpr : Expr
// An expr crated during optimize, never parsed
{
    function optimize()
    {
        InternalError("misuse of " + string(typeof(self)), self);
    }
}

//**********************************************************************

class FunctionExpr : Expr
{
    var fn;
    function FunctionExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        if (!t.isop("("))
            Expected("anonymous function", t);
        self.fn = new LocalFunctionStatement(start, tk, owner);
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.fn = self.fn.optimize();
        self.usesubid(self.fn.getsubid());
        return self;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        var fn = self.fn;
        string subid = fn.getsubid();
        if (fn.needclosure())
            e.emitarg2("newclosure", result, subid);
        else
            e.emitset(result, subid);
    }
    function emit_void(var e)
    {
    }
}

//*********************************************

// Condition class, contains and works with expressions used in
// conditional operators and statements.

const int CONDisruntime = 0, CONDistrue = 1, CONDisfalse = 2;

class Condition
{
    var condexpr;
    function set(var expr)
    {
        self.condexpr = expr;
        return self;
    }
    function optimize_condition()
    {
        self.condexpr = self.condexpr.optimize();
    }
    function optimize()
    {
        self.condexpr = self.condexpr.optimize();
        return self;
    }
    function getvalue()
    {
        var condexpr = self.condexpr;
        if (condexpr.isintegerliteral())
            return condexpr.isintegerzero() ? CONDisfalse : CONDistrue;
        return CONDisruntime;
    }
    function emit_if(var e, string labeltrue, string labelfalse)
    {
        var condexpr = self.condexpr;

        if ((condexpr instanceof ComparatorBaseExpr) ||
                (condexpr instanceof CheckerExpr))
            condexpr.emit_if(e, labeltrue);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGstring:
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGint:
              case REGfloat:
                e.emitif(reg, labeltrue);
                break;
              default:
                InternalError("Invalid if condition");
            }
        }
    }
    function emit_else(var e, string labelfalse)
    {
        var condexpr = self.condexpr;

        if ((condexpr instanceof ComparatorBaseExpr) ||
                (condexpr instanceof CheckerExpr))
            condexpr.emit_else(e, labelfalse);
        else {
            string reg = condexpr.emit_get(e);
            switch (condexpr.checkresult()) {
              case REGstring:
              case REGvar:
                e.emitif_null(reg, labelfalse);
              case REGint:
              case REGfloat:
                e.emitunless(reg, labelfalse);
                break;
              default:
                InternalError("Invalid if condition");
            }
        }
    }
}

//*********************************************

class Literal : SimpleExpr
{
    function isliteral() { return true; }
    function hascompilevalue() { return true; }
    function emit_void(var e) { }
}

//*********************************************

class IntegerLiteral : Literal
{
    var intval;
    function IntegerLiteral(var owner, var start, int value)
    {
        self.Expr(owner, start);
        self.intval = value;
    }
    function isintegerliteral() { return true; }
    function isintegerzero()
    {
        return int(self.intval) == 0;
    }
    function checkresult() { return REGint; }
    function getIntegerValue()
    {
        return int(self.intval);
    }
    function emit(var e, string result)
    {
        int value = self.getIntegerValue();
        if (value == 0)
            e.emitnull(result);
        else
            e.emitset(result, value);
    }
    function emit_get(var e)
    {
        return self.getIntegerValue();
    }
    function emit_getint(var e)
    {
        // Just a shortcut
        return self.getIntegerValue();
    }
}

//*********************************************

class StringLiteral : Literal
{
    var strval;
    function StringLiteral(var owner, var start)
    {
        self.Expr(owner, start);
        self.strval = start;
    }
    function isstringliteral() { return true; }
    function checkresult() { return REGstring; }
    function getPirString()
    {
        var strtok = self.strval;
        string str = strtok.getPirString();
        return str;
    }
    function getStringValue()
    {
        var strtok = self.strval;
        string str = strtok.str;
        if (strtok instanceof TokenQuoted)
            str = unescape(str);
        return str;
    }
    function emit(var e, string result)
    {
        e.emitset(result, self.getPirString());
    }
    function emit_get(var e)
    {
        return self.getPirString();
    }
}

//*********************************************

function concat_literal(var lexpr, var rexpr)
{
    __ASSERT__(lexpr.isstringliteral());
    __ASSERT__(rexpr.isstringliteral());

    var etok = lexpr.strval;
    var rtok = rexpr.strval;
    var t = new TokenQuoted(etok.file, etok.line,
            string(etok.getasquoted()) + string(rtok.getasquoted()));
    return new StringLiteral(lexpr.owner, t);
}

//*********************************************

class FunctionId : FinalExpr
{
    var subid;
    function FunctionId(var owner, var name, string id)
    {
        self.Expr(owner, name);
        self.subid = id;
    }
    function checkresult() { return REGvar; }
    function emit_get(var e)
    {
        return self.subid;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        e.emitset(result, self.subid);
    }
}

class IdentifierExpr : SimpleExpr
{
    var name;
    function isidentifier() { return true; }
    function IdentifierExpr(var owner, var name)
    {
        __ASSERT__(name instanceof TokenIdentifier);
        self.Expr(owner, name);
        self.name = name;
    }
    function isnull()
    {
        var name = self.name;
        if (self.owner.getvar(name) != null)
            return false;
        return name.iskeyword(NULL);
    }
    function emit_get_nonull(var e)
    {
        if (self.isnull())
            SyntaxError("Invalid 'null' usage", self);
        return self.emit_get(e);
    }
    function checkresult()
    {
        var name = self.name;
        var desc = self.owner.getvar(name);
        if (desc != null)
            return desc.gettype();
        else {
            switch (name) {
              case SELF:
              case NULL:
                return REGvar;
              default:
                return "";
            }
        }
    }
    function getName()
    {
        string s = self.name;
        return s;
    }
    function checkVar()
    {
        return self.owner.getvar(string(self.name));
    }
    function checkIdentifier()
    {
        var name = self.name;
        if (name == null)
            InternalError("Bad thing");
        var desc = self.owner.getvar(name);
        string s;
        if (desc == null) {
            switch (name) {
              case SELF:
              case NULL:
                s = name; break;
              default:
                s = "";
            }
        }
        else
            s = desc.getreg();
        return s;
    }
    function getIdentifier()
    {
        var value = self.checkIdentifier();
        if (value == "")
            UndefinedVariable(self.name, self);
        return value;
    }
    function optimize()
    {
        var name = self.name;
        var owner = self.owner;
        var desc = owner.getvar(name);
        if (desc != null) {
            __ASSERT__(desc instanceof VarData);
            if (desc.isconst())
                return desc.getvalue();
            int flags = desc.getflags();
            if (flags & VAR_is_volatile) {
                if (flags & VAR_is_lexical)
                    return new LexicalVolatileExpr(self, desc);
            }
            else {
                // const Sub previous definition may be in a code path
                // not taken. Better allow redundant definitions than
                // leave undefined depending on runtime conditions.
                // TODO: improve this.
                var reg = desc.getreg();
                if (reg != null && substr(reg, 0, 7) == "WSubId_")
                    return new FunctionId(owner, name, reg);
            }
        }
        else {
            var sym = self.scopesearch([name], 0);
            switch {
              case sym == null:
                break;
              case sym instanceof FunctionStatement:
                string id = sym.makesubid();
                self.usesubid(id);
                owner.createvarnamed(name, REGvar, id);
                return new FunctionId(owner, name, id);
                break;
            }
        }
        return self;
    }
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(var e) { }
    function emit_get(var e)
    {
        string reg;
        reg = self.getIdentifier();
        var desc = self.owner.getvar(self.name);
        int flags = desc == null ? 0 : desc.getflags();
        if (flags & VAR_is_volatile) {
            if (flags & VAR_is_lexical) {
                string lexname = desc.getlex();
                if (lexname != null)
                    self.annotate(e);
                    e.emitfind_lex(reg, lexname);
            }
        }
        return reg;
    }
    function emit_assign_get(var e, var expr)
    {
        self.annotate(e);
        if (self.isnull())
            SyntaxError("Cannot assign to null", self);
        string typeleft = self.checkresult();
        string lreg = self.getIdentifier();
        if (expr.isnull()) {
            switch (typeleft) {
              case REGstring:
              case REGvar:
                e.emitnull(lreg);
                break;
              default:
                SyntaxError("Can't assign null to that type", self);
            }
        }
        else if (expr instanceof IndexExpr)
            expr.emit(e, lreg);
        else {
            string typeright = expr.checkresult();
            if (typeright == REGnone)
                SyntaxError("Can't assign from void expression", self);
            if (typeleft == typeright) {
                expr.emit(e, lreg);
            }
            else {
                string rreg = expr.emit_get(e);
                self.annotate(e);
                if (typeleft == REGvar && typeright != REGvar)
                    e.emitbox(lreg, rreg);
                else
                    e.emitset(lreg, rreg);
            }
        }
        return lreg;
    }
}

//*********************************************

class LexicalVolatileExpr : FinalExpr
{
    var desc;
    function LexicalVolatileExpr(var idexpr, var desc)
    {
        self.Expr(idexpr.owner, idexpr.start);
        self.desc = desc;
    }
    function checkresult()
    {
        return self.desc.gettype();
    }
    function emit_get(var e)
    {
        var desc = self.desc;
        string lexname = desc.getlex();
        string reg = self.owner.tempreg(desc.gettype());
        e.emitfind_lex(reg, lexname);
        return reg;
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_assign_get(var e, var expr)
    {
        var owner = self.owner;
        var desc = self.desc;
        string typelex = desc.gettype();
        string lreg;
        switch {
          case expr.isnull():
            lreg = owner.tempreg(typelex);
            e.emitnull(lreg);
            break;
          case expr instanceof IndexExpr:
            lreg = owner.tempreg(typelex);
            expr.emit(e, lreg);
            break;
          default:
            if (typelex == REGvar)
                lreg = expr.emit_getvar(e);
            else if (typelex == expr.checkresult())
                lreg = expr.emit_get(e);
            else {
                lreg = owner.tempreg(typelex);
                expr.emit(e, lreg);
            }
        }

        e.emitstore_lex(desc.getlex(), lreg);
        return lreg;
    }
    function emit_store(var e, string reg)
    {
        e.emitstore_lex(self.desc.getlex(), reg);
    }
}

//*********************************************

class OpExpr : Expr
{
    function initop(var owner, var start)
    {
        self.Expr(owner, start);
    }
}

//*********************************************

class OpNamespaceExpr : OpExpr
{
    var key;
    function OpNamespaceExpr(var tk, var owner, var start)
    {
        self.initop(owner, start);
        self.key = parseDotted(tk);
        if (elements(self.key) == 0)
            Expected("namespace identifier", start);
    }
    function checkresult() { return REGvar; }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var sym = owner.scopesearch(self.key, SEARCH_NAMESPACE);
        if (sym == null)
            SyntaxError("unknown namespace", self);
        var path = sym.getpath();
        path.emit_get_namespace(e, owner, result);
    }
}

//*********************************************

class OpClassExpr : OpExpr
{
    var clspec;

    function OpClassExpr(var tk, var owner, var start)
    {
        self.initop(owner, start);
        self.clspec = parseClassSpecifier(tk, owner);
    }
    function checkresult() { return REGvar; }
    function get_class_raw_key()
    {
        var owner = self.owner;
        var clspec = self.clspec;
        var clkey;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifierParrotKey:
            clkey = clspec.checknskey(owner);
            return clkey != null ? clkey.path : null;
          case clspec instanceof ClassSpecifier:
            SyntaxError(string(typeof(clspec)) + " not supported yet here",
                    clspec.start);
        }
        InternalError("Unexpected class key", clspec.start);
    }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var clspec = self.clspec;
        // TODO: cover more class specifiers
        switch {
          case clspec instanceof ClassSpecifierId:
            var clkey = clspec.checknskey(owner);
            if (clkey != null) {
                clkey.emit_get_class(e, owner, result);
                return;
            }
            break;
        }

        e.print(INDENT + "get_class ", result, ", ");
        clspec.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpUnaryExpr : OpExpr
{
    var subexpr;
    function OpUnaryExpr(var owner, var start, var subexpr)
    {
        self.initop(owner, start);
        self.subexpr = subexpr;
    }
    function optimizearg()
    {
        self.subexpr = self.subexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpBinaryExpr : OpExpr
{
    var lexpr;
    var rexpr;
    function initbinary(var owner, var start, var lexpr, var rexpr)
    {
        self.initop(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
    }
    function set(var owner, var t, var lexpr, var rexpr)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        return self;
    }
    function setfrom(var from)
    {
        return self.set(from.owner, from.start, from.lexpr, from.rexpr);
    }
    function optimizearg()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
    function emit_intleft(var e)
    {
        return self.lexpr.emit_getint(e);
    }
    function emit_intright(var e)
    {
        return self.rexpr.emit_getint(e);
    }
}

//*********************************************

class OpBinaryIntExpr : OpBinaryExpr
{
    function checkresult()
    {
        return REGint;
    }
    function optimize()
    {
        self.optimizearg();
        return self;
    }
}

//*********************************************

class OpDelExBase : OpUnaryExpr
{
    function checkresult()
    {
        return REGint;
    }
}


class OpDeleteExpr : OpDelExBase
{
    function OpDeleteExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function optimize()
    {
        self.optimizearg();
        var expr = self.subexpr;
        if ((!(expr instanceof IndexExpr)) || expr.checkresult() == REGstring)
            SyntaxError("delete with invalid operator", self);
        return self;
    }
    function emit_void(var e)
    {
        var expr = self.subexpr;
        expr.emit_prep(e);
        self.annotate(e);
        e.print(INDENT + "delete ");
        expr.emit_aux(e);
        e.say();
    }
    function emit(var e, string result)
    {
        self.emit_void(e);
        e.emitset(result, "1");
    }
}

class OpExistsExpr : OpDelExBase
{
    function OpExistsExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit(var e, string result)
    {
        var expr = self.subexpr;
        if (expr instanceof IndexExpr && expr.checkresult() != REGstring) {
            expr.emit_prep(e);
            self.annotate(e);
            e.print(INDENT + "exists ", result, ", ");
            expr.emit_aux(e);
            e.say();
        }
        else
            SyntaxError("exists with invalid operator", self);
    }
}

//*********************************************

class OpUnaryMinusExpr : OpUnaryExpr
{
    function OpUnaryMinusExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        var subexpr = self.subexpr;
        self.optimizearg();
        if (subexpr.isintegerliteral()) {
            int i = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, -i);
        }
        return self;
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitarg2("neg", result, reg);
    }
}

//*********************************************

class OpNotExpr : OpUnaryExpr
{
    function OpNotExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function isnegable() { return true; }
    function checkresult()
    {
        return REGint;
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function optimize()
    {
        self.optimizearg();
        var subexpr = self.subexpr;
        if (subexpr.isintegerliteral()) {
            int n = subexpr.getIntegerValue();
            return integerValue(self.owner, subexpr.start, ! n);
        }
        if (subexpr.isnegable())
            return subexpr.negated();
        return self;
    }
    function negated()
    {
        return self.subexpr;
    }
    function emit(var e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_get(e);
        self.annotate(e);
        switch (subexpr.checkresult()) {
          case REGint:
            e.emitarg2("not", result, reg);
            break;
          case REGvar:
            e.emitarg2("isfalse", result, reg);
            break;
          default:
            e.emitarg2("isfalse", result, reg);
        }
    }
}

//*********************************************

class OpBinNotExpr : OpUnaryExpr
{
    function OpBinNotExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function checkresult()
    {
        return REGint;
    }
    function set(var owner, var t, var subexpr)
    {
        self.OpUnaryExpr(owner, t, subexpr);
        return self;
    }
    function emit(var e, string result)
    {
        var subexpr = self.subexpr;
        string reg = subexpr.emit_getint(e);
        self.annotate(e);
        e.emitarg3("bxor", result, reg, -1);
    }
}

//*********************************************

class OpIncDec : OpUnaryExpr
{
    function checkresult()
    {
        return self.subexpr.checkresult();
    }
    function iflexical(var e, string reg)
    {
        var expr = self.subexpr;
        if (expr instanceof LexicalVolatileExpr)
            expr.emit_store(e, reg);
    }
}

//*********************************************

class OpPreIncDec : OpIncDec
{
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        e.emitset(result, reg);
    }
    function emit_void(var e)
    {
        self.emit_get(e);
    }
}

class OpPreIncExpr : OpPreIncDec
{
    function OpPreIncExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

class OpPreDecExpr : OpPreIncDec
{
    function OpPreDecExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
}

//*********************************************

class OpPostIncExpr : OpIncDec
{
    function OpPostIncExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2("clone", aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2("clone", result, reg);
        else
            e.emitset(result, reg);
        e.emitinc(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitinc(reg);
        self.iflexical(e, reg);
    }
}

class OpPostDecExpr : OpIncDec
{
    function OpPostDecExpr(var owner, var start, var subexpr)
    {
        self.OpUnaryExpr(owner, start, subexpr);
    }
    function emit(var e, string result)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        if (self.checkresult() == REGvar) {
            string aux = self.tempreg(REGvar);
            e.emitarg2("clone", aux, reg);
            e.emitset(result, aux);
        }
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return reg;
    }
    function emit_get(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        string result = self.tempreg(self.checkresult());
        if (self.checkresult() == REGvar)
            e.emitarg2("clone", result, reg);
        else
            e.emitset(result, reg);
        e.emitdec(reg);
        self.iflexical(e, reg);
        return result;
    }
    function emit_void(var e)
    {
        string reg = self.subexpr.emit_get(e);
        self.annotate(e);
        e.emitdec(reg);
        self.iflexical(e, reg);
    }
}

//*********************************************

class OpBaseAssignExpr : Expr
{
    var lexpr;
    var rexpr;
    function set(var owner, var start, var lexpr, var rexpr)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.rexpr = rexpr;
        return self;
    }
    function checkresult()
    {
        return self.lexpr.checkresult();
    }
    function optimize_base()
    {
        self.lexpr = self.lexpr.optimize();
        self.rexpr = self.rexpr.optimize();
        return self;
    }
    function optimize()
    {
        return self.optimize_base();
    }
    function checkleft()
    {
        var lexpr = self.lexpr;
        if (lexpr.isnull() || lexpr.isliteral())
            NoLeftSide(lexpr);
    }
    function emit(var e, string result)
    {
        string reg = self.emit_get(e);
        self.annotate(e);
        e.emitset(result, reg);
    }
    function emit_void(var e)
    {
        self.emit_get(e);
    }
}

//*********************************************

class OpAssignExpr : OpBaseAssignExpr
{
    function emit_get(var e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        return lexpr.emit_assign_get(e, self.rexpr);
    }
    function emit_void(var e)
    {
        self.annotate(e);
        var lexpr = self.lexpr;
        lexpr.emit_assign_get(e, self.rexpr);
    }
}

//*********************************************

class OpAssignToExpr : OpBaseAssignExpr
{
    function emit(var e, string result)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
        e.emitassign(result, reg);
    }
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        if (lexpr.checkresult() != REGvar)
            SyntaxError("Wrong dest type in =:", lexpr);
        string reg = lexpr.emit_get(e);
        string reg2 = self.rexpr.emit_get(e);
        self.annotate(e);
        e.emitassign(reg, reg2);
        return reg;
    }
    function emit_void(var e)
    {
        self.annotate(e);
        string reg = self.emit_get(e);
    }
}

//*********************************************

class OpAddToExpr : OpBaseAssignExpr
{
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);

        string reg2 = rexpr.emit_get(e);
        string aux;
        self.annotate(e);
        switch (ltype) {
          case REGstring:
            if (rtype != REGstring) {
                aux = self.tempreg(REGstring);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitconcat1(reg, reg2);
            break;
          case REGint:
          case REGfloat:
            if (ltype != rtype) {
                aux = self.tempreg(ltype);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitaddto(reg, reg2);
            break;
          default:
            e.emitaddto(reg, reg2);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

class OpSubToExpr : OpBaseAssignExpr
{
    function emit_get(var e)
    {
        self.checkleft();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string reg = lexpr.emit_get(e);
        string reg2 = rexpr.emit_get(e);
        string aux;
        self.annotate(e);
        switch (ltype) {
          case REGstring:
            SyntaxError("-= can't be applied to string", self);
          case REGint:
          case REGfloat:
            if (ltype != rtype) {
                aux = self.tempreg(ltype);
                e.emitset(aux, reg2);
                reg2 = aux;
            }
            e.emitsubto(reg, reg2);
            break;
          default:
            e.emitsubto(reg, reg2);
        }
        if (lexpr instanceof LexicalVolatileExpr)
            lexpr.emit_store(e, reg);
        return reg;
    }
}

//*********************************************

const int
    COMPARATOR_DEFAULT = 0,
    COMPARATOR_IF      = 1,
    COMPARATOR_ELSE    = 2;

class ComparatorBaseExpr : OpBinaryExpr
{
    function checkresult() { return REGint; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isintegerliteral() && rexpr.isintegerliteral()) {
            int li = lexpr.getIntegerValue();
            int ri = rexpr.getIntegerValue();
            return integerValue(self.owner, self.start, self.int_op(li, ri));
        }
        return self;
    }
    function emit_comparator(var e, string result, int doifelse[optional])
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        string regl = self.lexpr.emit_get(e);
        string regr = self.rexpr.emit_get(e);
        self.annotate(e);
        string aux;
        switch {
          case rl == REGint && rr == REGfloat:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rl == REGfloat && rr == REGint:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGint && rl == REGvar:
            aux = self.tempreg(REGint);
            e.emitset( aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGint:
            aux = self.tempreg(REGint);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGfloat && rl == REGvar:
            aux = self.tempreg(REGfloat);
            e.emitset( aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGfloat:
            aux = self.tempreg(REGfloat);
            e.emitset(aux, regr);
            regr = aux;
            break;
          case rr == REGstring && rl == REGvar:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regl);
            regl = aux;
            break;
          case rr == REGvar && rl == REGstring:
            aux = self.tempreg(REGstring);
            e.emitset(aux, regr);
            regr = aux;
            break;
        }

        switch (doifelse) {
          case COMPARATOR_DEFAULT:
            self.emitop(e, result, regl, regr);
            break;
          case COMPARATOR_IF:
            self.emitop_if(e, result, regl, regr);
            break;
          case COMPARATOR_ELSE:
            self.emitop_else(e, result, regl, regr);
            break;
        }
    }
    function emit(var e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emit_if(var e, string labeltrue)
    {
        self.emit_comparator(e, labeltrue, COMPARATOR_IF);
    }
    function emit_else(var e, string labelfalse)
    {
        self.emit_comparator(e, labelfalse, COMPARATOR_ELSE);
    }
}

//*********************************************

class Negable
{
    var positive;

    function Negable(int positive)
    {
        self.positive = new ["Boolean"](positive);
    }
    function isnegable() { return true; }
    function negated()
    {
        int positive = ! self.positive;
        self.positive = positive;
        return self;
    }
}

//*********************************************

// Null checkers, created during optimize of Equal and NotEqual
// to simplify its emit functions.

class CheckerExpr : Expr, Negable
{
    var expr;

    function CheckerExpr(var base, var expr, int positive)
    {
        self.Expr(base.owner, base.start);
        self.Negable(positive);
        self.expr = expr;
    }
    function isnegable() { return true; }
    function checkresult() { return REGint; }
}

class NullCheckerExpr : CheckerExpr
{
    function NullCheckerExpr(var base, var expr, int checknull)
    {
        self.CheckerExpr(base, expr, checknull);
    }
    function emit(var e, string result)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        e.emitarg2("isnull", result, reg);
        if (! self.positive)
            e.emitarg1("not", result);
    }
    function emit_if(var e, string labelif)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitif_null(reg, labelif);
        else
            e.emitunless_null(reg, labelif);
    }
    function emit_else(var e, string labelelse)
    {
        string reg = self.expr.emit_get(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless_null(reg, labelelse);
        else
            e.emitif_null(reg, labelelse);
    }
}

class ZeroCheckerExpr : CheckerExpr
{
    function ZeroCheckerExpr(var base, var expr, int positive)
    {
        self.CheckerExpr(base, expr, positive);
    }
    function emit(var e, string result)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitarg3("iseq", result, reg, 0);
        else
            e.emitarg3("isne", result, reg, 0);
    }
    function emit_if(var e, string labelif)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitunless(reg, labelif);
        else
            e.emitif(reg, labelif);
    }
    function emit_else(var e, string labelelse)
    {
        var expr = self.expr;
        string reg = expr.emit_getint(e);
        self.annotate(e);
        if (self.positive)
            e.emitif(reg, labelelse);
        else
            e.emitunless(reg, labelelse);
    }
}

//*********************************************

class OpEqualExpr : ComparatorBaseExpr, Negable
{
    function OpEqualExpr(var owner, var start, var lexpr, var rexpr, int positive)
    {
        self.set(owner, start, lexpr, rexpr);
        self.Negable(positive);
    }
    function isnegable() { return true; }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        int lnull = lexpr.isnull();
        int rnull = rexpr.isnull();
        if (lnull) {
            if (rnull)
                return integerValue(self.owner, self.start, self.positive);
            else
                return new NullCheckerExpr(self, rexpr, self.positive);
        }
        if (rnull)
            return new NullCheckerExpr(self, lexpr, self.positive);
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == rtype) {
                switch (ltype) {
                  case REGint:
                    int li = lexpr.getIntegerValue();
                    int ri = rexpr.getIntegerValue();
                    int vi = self.positive ? li == ri : li != ri;
                    return integerValue(self.owner, self.start, vi);
                  case REGstring:
                    string ls = (lexpr.strval).str;
                    string rs = (rexpr.strval).str;
                    int vs = self.positive ? ls == rs : ls != rs;
                    return integerValue(self.owner, self.start, vs);
                }
            }
        }
        if (rexpr.isintegerzero())
            return new ZeroCheckerExpr(self, lexpr, self.positive);
        if (lexpr.isintegerzero())
            return new ZeroCheckerExpr(self, rexpr, self.positive);
        return self;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        self.annotate(e);
        e.emitbinop(self.positive ? "iseq" : "isne", result, regl, regr);
    }
    function emit(var e, string result)
    {
        self.annotate(e);
        self.emit_comparator(e, result);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? "eq" : "ne", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        e.emitcompare(self.positive ? "ne" : "eq", regl, regr, labelelse);
    }
}


//**********************************************************************

class OpSameExpr : ComparatorBaseExpr, Negable
{
    var positive;
    function OpSameExpr(var owner, var t, var lexpr, var rexpr, int positive)
    {
        self.initbinary(owner, t, lexpr, rexpr);
        self.Negable(positive);
    }
    function isnegable() { return true; }
    function int_op(int left, int right)
    {
        return self.positive ? (left == right) : (left != right);
    }
    function emitop(var e, string result, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "issame" : "isntsame";
        e.emitbinop(op, result, regl, regr);
    }
    function emit(var e, string result)
    {
        self.emit_comparator(e, result);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "eq_addr" : "ne_addr";
        e.emitcompare(op, regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        self.annotate(e);
        int positive = self.positive;
        string op = positive ? "ne_addr" : "eq_addr";
        e.emitcompare(op, regl, regr, labelelse);
    }
}

//*********************************************

class OpLessExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left < right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("islt", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("lt", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("ge", regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessEqualExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left > right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isgt", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("gt", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("le", regl, regr, labelelse);
    }
}

//*********************************************

class OpLessEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return (new OpGreaterExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left <= right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isle", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("le", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("gt", regl, regr, labelelse);
    }
}

//*********************************************

class OpGreaterEqualExpr : ComparatorBaseExpr
{
    function isnegable() { return true; }
    function negated()
    {
        return (new OpLessExpr).setfrom(self);
    }
    function int_op(int left, int right)
    {
        return left >= right;
    }
    function emitop(var e, string result, string regl, string regr)
    {
        e.emitbinop("isge", result, regl, regr);
    }
    function emitop_if(var e, string labeltrue, string regl, string regr)
    {
        e.emitcompare("ge", regl, regr, labeltrue);
    }
    function emitop_else(var e, string labelelse, string regl, string regr)
    {
        e.emitcompare("lt", regl, regr, labelelse);
    }
}

//*********************************************

class OpBaseBoolExpr : OpBinaryExpr
{
    function checkresult()
    {
        return self.lexpr.checkresult() == REGint && self.rexpr.checkresult() == REGint ?
            REGint : REGvar;
    }
}

//*********************************************

class OpBoolAndExpr : OpBaseBoolExpr
{
    function OpBoolAndExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln != 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("and", result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitunless(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(var e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("and", DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitunless(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
}

//*********************************************

class OpBoolOrExpr : OpBaseBoolExpr
{
    function OpBoolOrExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function optimize()
    {
        self.optimizearg();
        if (self.lexpr.isintegerliteral() ) {
            int ln = self.lexpr.getIntegerValue();
            return ln == 0 ?
                self.rexpr :
                integerValue(self.owner, self.start, ln);
        }
        return self;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("or", result, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            if (type == REGvar && lexpr.checkresult() != REGvar) {
                string lres = lexpr.emit_get(e);
                e.emitbox(result, lres);
            }
            else
                lexpr.emit(e, result);
            e.emitif(result, done);
            if (type == REGvar && rexpr.checkresult() != REGvar) {
                string rres = rexpr.emit_get(e);
                e.emitbox(result, rres);
            }
            else
                rexpr.emit(e, result);
            e.emitlabel(done);
        }
    }
    function emit_void(var e)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string type = self.checkresult();
        if (type == REGint && lexpr.issimple() && rexpr.issimple()) {
            string lreg = self.emit_intleft(e);
            string rreg = self.emit_intright(e);
            e.emitbinop("or", DISCARD_IREG, lreg, rreg);
        }
        else {
            string done = self.genlabel();
            string result = lexpr.emit_get(e);
            e.emitif(result, done);
            rexpr.emit_void(e);
            e.emitlabel(done);
        }
    }
}

//*********************************************

class OpBaseBinExpr : OpBinaryIntExpr
{
}

//*********************************************

class OpBinAndExpr : OpBaseBinExpr
{
    function OpBinAndExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("band", result, lreg, rreg);
    }
}

//*********************************************

class OpBinOrExpr : OpBaseBinExpr
{
    function OpBinOrExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("bor", result, lreg, rreg);
    }
}

//*********************************************

class OpBinXorExpr : OpBaseBinExpr
{
    function OpBinXorExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("bxor", result, lreg, rreg);
    }
}

//*********************************************

class OpAddExpr : OpBinaryExpr
{
    function OpAddExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        if (lexpr.isliteral() && rexpr.isliteral()) {
            if (ltype == REGstring && rtype == REGstring)
                return concat_literal(lexpr, rexpr);
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln + rn);
            }
        }
        return self;
    }
    function checkresult()
    {
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        if (rl == REGint && rr == REGstring)
            return REGstring;
        if (rl == REGstring && rr == REGint)
            return REGstring;
        if (floatresult(rl, rr))
            return REGfloat;
        return REGint;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string restype = self.checkresult();
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();

        string rleft = lexpr.emit_get(e);
        string rright = rexpr.emit_get(e);
        if (restype == REGstring) {
            if (ltype != REGstring || rtype != REGstring) {
                string aux = self.tempreg(REGstring);
                if (ltype != REGstring) {
                    e.emitset(aux, rleft);
                    rleft = aux;
                }
                else {
                    e.emitset(aux, rright);
                    rright = aux;
                }
            }
            e.emitconcat(result, rleft, rright);
        }
        else {
            if (restype == REGint && (ltype != REGint || rtype != REGint)) {
                string l;
                if (ltype == REGint) l = rleft;
                else {
                    l = self.tempreg(REGint);
                    e.emitset(l, rleft);
                }
                string r;
                if (rtype == REGint) r = rright;
                else {
                    r = self.tempreg(REGint);
                    e.emitset(r, rright);
                }
                e.emitadd(result, l, r);
            }
            else
                e.emitadd(result, rleft, rright);
        }
    }
}

//*********************************************

class OpSubExpr : OpBinaryExpr
{
    function OpSubExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function optimize()
    {
        self.optimizearg();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        if (lexpr.isliteral() && rexpr.isliteral()) {
            string ltype = lexpr.checkresult();
            string rtype = rexpr.checkresult();
            if (ltype == REGint && rtype == REGint) {
                int ln = lexpr.getIntegerValue();
                int rn = rexpr.getIntegerValue();
                return integerValue(self.owner, self.start, ln - rn);
            }
        }
        return self;
    }
    function checkresult()
    {
        string ltype = self.lexpr.checkresult();
        string rtype = self.rexpr.checkresult();
        switch {
          case ltype == rtype:
            return ltype;
          case ltype == REGvar || rtype == REGvar:
            return REGvar;
          case ltype == REGint && rtype == REGfloat:
            return REGfloat;
          case ltype == REGfloat && rtype == REGint:
            return REGfloat;
          default:
            return REGint;
        }
    }
    function emit(var e, string result)
    {
        string type = self.checkresult();
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg = lexpr.emit_get(e);
        string rreg = rexpr.emit_get(e);
        string aux;
        if (ltype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, lreg);
            else
                e.emitset(aux, lreg);
            lreg = aux;
        }
        if (rtype != type) {
            aux = self.tempreg(type);
            if (type == REGvar)
                e.emitbox(aux, rreg);
            else
                e.emitset(aux, rreg);
            rreg = aux;
        }
        e.emitsub(result, lreg, rreg);
    }
}

//*********************************************

class OpMulExpr : OpBinaryExpr
{
    function OpMulExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function checkresult()
    {
        var lexpr = self.lexpr;
        string rl = self.lexpr.checkresult();
        string rr = self.rexpr.checkresult();
        if (rl == rr)
            return rl;
        return REGfloat;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var rexpr = self.rexpr;
        string ltype = lexpr.checkresult();
        string rtype = rexpr.checkresult();
        string lreg, rreg;
        if (ltype == rtype && (ltype == REGint || ltype == REGfloat || ltype == REGvar)) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            e.emitmul(result, lreg, rreg);
            return;
        }

        // Quick fix for some float mul
        // TODO: rewrite this mess
        if (ltype == REGfloat) {
            lreg = lexpr.emit_get(e);
            rreg = rexpr.emit_get(e);
            string rval;
            switch (rtype) {
              case REGint:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
                rval = rreg;
                break;
              case REGfloat:
                rval = rreg;
                break;
              default:
                rval = self.tempreg(REGfloat);
                e.emitset(rval, rreg);
            }
            self.annotate(e);
            e.emitmul(result, lreg, rval);
            return;
        }

        int nleft, nright;
        if ((!lexpr.issimple()) || lexpr.isidentifier()) {
            lreg = self.tempreg(self.checkresult());
            lexpr.emit(e, lreg);
        }
        else {
            nleft = lexpr.getIntegerValue();
            lreg = nleft;
        }
        if ((!rexpr.issimple()) || rexpr.isidentifier()) {
            rreg = self.tempreg(self.checkresult());
            rexpr.emit(e, rreg);
        }
        else {
            switch (rtype) {
              case REGstring:
                rreg = self.tempreg(self.checkresult());
                rexpr.emit(e, rreg);
                break;
              case REGfloat:
                rreg = rexpr.emit_get(e);
                break;
              case REGint:
              default:
                nright = rexpr.getIntegerValue();
                rreg = nright;
                break;
            }
        }
        self.annotate(e);
        e.emitmul(result, lreg, rreg);
    }
}

//*********************************************

class OpDivExpr : OpBinaryExpr
{
    function OpDivExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function checkresult()
    {
        return REGfloat;
    }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        var aux;
        var lreg = lexpr.emit_get(e);
        if (lexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, lreg);
            lreg = aux;
        }
        var rexpr = self.rexpr;
        var rreg = rexpr.emit_get(e);
        if (rexpr.checkresult() != REGfloat) {
            aux = self.tempreg(REGfloat);
            e.emitset(aux, rreg);
            rreg = aux;
        }
        self.annotate(e);
        e.emitdiv(result, lreg, rreg);
    }
}

//*********************************************

class OpModExpr : OpBinaryIntExpr
{
    function OpModExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("mod", result, lreg, rreg);
    }
}

//*********************************************

class OpShiftleftExpr : OpBinaryIntExpr
{
    function OpShiftleftExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("shl", result, lreg, rreg);
    }
}

//*********************************************

class OpShiftrightExpr : OpBinaryIntExpr
{
    function OpShiftrightExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("shr", result, lreg, rreg);
    }
}

//*********************************************

class OpShiftlrightExpr : OpBinaryIntExpr
{
    function OpShiftlrightExpr(var owner, var start, var lexpr, var rexpr)
    {
        self.set(owner, start, lexpr, rexpr);
    }
    function emit(var e, string result)
    {
        string lreg = self.emit_intleft(e);
        string rreg = self.emit_intright(e);
        self.annotate(e);
        e.emitbinop("lsr", result, lreg, rreg);
    }
}

//*********************************************

class ArgumentModifierList : ModifierList
{
    function ArgumentModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function emitmodifiers(var e)
    {
        int isflat = false, isnamed = false;
        string setname = "";
        for (var modif in self.getlist()) {
            switch (modif.getname()) {
              case "flat":
                isflat = true;
                break;
              case "named":
                isnamed = true;
                switch (modif.numargs()) {
                  case 0:
                    break;
                  case 1:
                    var argmod = modif.getarg(0);
                    if (! argmod.isstringliteral())
                        SyntaxError("Invalid modifier", self);
                    setname = argmod.getPirString();
                    break;
                  default:
                    SyntaxError("Invalid modifier", self);
                }
            }
        }
        switch {
          case isflat && isnamed:
            e.print(" :flat :named");
            break;
          case isflat:
            e.print(" :flat");
            break;
          case isnamed:
            e.print(" :named");
            if (setname != "")
                e.print("(", setname, ")");
            break;
        }
    }
}

class Argument
{
    var arg;
    var modifiers;
    function Argument(var arg, var modifiers)
    {
        self.arg = arg;
        self.modifiers = modifiers;
    }
    function optimize()
    {
        self.arg = self.arg.optimize();
        return self;
    }
    function hascompilevalue()
    {
        return self.arg.hascompilevalue();
    }
}

function parseArgument(var tk, var owner)
{
    var modifier = null;
    var expr = parseExpr(tk, owner);
    var t = tk.get();
    if (t.isop(":")) {
        t = tk.get();
        if (t.isop("[")) {
            modifier = new ArgumentModifierList(tk, owner);
        }
        else
            Expected("modifier list", t);
    }
    else
        tk.unget(t);
    return new Argument(expr, modifier);
}

class ArgumentList
{
    var owner;
    var start;
    var args;
    var argregs;

    function ArgumentList(var owner, var start, var tk, string delimiter)
    {
        self.owner = owner;
        self.start = start;
        self.args = parseListOrEmpty(tk, owner, parseArgument, delimiter);
    }
    function numargs()
    {
        var args = self.args;
        return args == null ? 0 : elements(args);
    }
    function getrawargs()
    {
        return self.args;
    }
    function getarg(int i)
    {
        var args = self.args;
        return args[i];
    }
    function getfreearg(int i)
    {
        var args = self.args;
        return args[i].arg;
    }
    function optimize()
    {
        optimize_array(self.args);
        return self;
    }
    function getargvalues(var e)
    {
        var argregs = self.argregs;
        if (argregs == null) {
            string argregs[];
            var collect = new CollectValues(self.owner, e);
            for (var argitem in self.args) {
                string reg = collect.add(argitem.arg);
                push(argregs, reg);
            }
            self.argregs = argregs;
        }
        return argregs;
    }
    function emitargs(var e)
    {
        var args = self.args;
        var argreg = self.getargvalues(e);

        string sep = "";
        int n = self.numargs();
        for (int i = 0; i < n; i = i + 1) {
            e.print(sep, argreg[i]);
            var modifiers = args[i].modifiers;
            if (modifiers != null)
                modifiers.emitmodifiers(e);
            sep = ", ";
        }
    }
}

function arglist_hascompilevalue(var arglist)
{
    for (var arg in arglist)
        if (! arg.hascompilevalue())
            return false;
    return true;
}

//*********************************************

class CallBuiltinExpr : FinalExpr
{
    var builtin;
    var args;

    function CallBuiltinExpr(var owner, var start, var builtin, var args)
    {
        self.Expr(owner, start);
        self.builtin = builtin;
        self.args = args;
    }
    function checkresult()
    {
        return self.builtin.result();
    }
    function emit_void(var e)
    {
        self.emit(e, "");
    }
    function emit_get(var e)
    {
        string type = self.checkresult();
        switch (type)
        {
          case REGint: case REGfloat: case REGstring: case REGvar:
            break;
          case REGnone:
            SyntaxError("Can't use result of a void builtin", self);
          default:
            InternalError("Unexpected result type '" + type + "'", self);
        }
        string reg = self.tempreg(type);
        self.emit(e, reg);
        return reg;
    }
    function emit(var e, string result)
    {
        var owner = self.owner;
        var start = self.start;
        var builtin = self.builtin;
        var args = self.args;
        string argreg[];
        var arg;
        switch (builtin.params()) {
          case BULTIN_arglist:
            var collectarglist = new CollectValues(owner, e);
            for (arg in args)
                push(argreg, collectarglist.add(arg.arg));
            break;
          case BULTIN_raw1:
            var rawargs = [];
            for (arg in args)
                push(rawargs, arg.arg);
            builtin.expand(e, owner, start, result, rawargs);
            return;
          default:
            int n = elements(args);
            var collectdefault = new CollectValues(owner, e);
            for (int i = 0; i < n; i = i + 1) {
                arg = args[i].arg;
                string argtype = arg.checkresult();
                string paramtype = builtin.paramtype(i);
                string argr;
                if (arg.isnull()) {
                    switch (paramtype) {
                      case REGint:
                      case REGfloat:
                      case REGstring:
                        argr = self.tempreg(paramtype);
                        e.emitnull(argr);
                        break;
                      default:
                        argr = collectdefault.add(arg);
                    }
                }
                else {
                    if (argtype == paramtype || paramtype == REGany ||
                            (paramtype == REGs_v &&
                             (argtype == REGstring || argtype == REGvar)))
                        argr = arg.emit_get(e);
                    else {
                        if (paramtype == REGs_v)
                            paramtype = REGvar;
                        string aux = arg.emit_get(e);
                        switch (paramtype) {
                          case REGvar:
                            switch (argtype) {
                              case REGint:
                              case REGfloat:
                              case REGstring:
                                argr = self.tempreg(paramtype);
                                e.emitbox(argr, aux);
                                break;
                              default:
                                argr = aux;
                            }
                            break;
                          case REGint:
                          case REGfloat:
                          case REGstring:
                            argr = self.tempreg(paramtype);
                            e.emitset(argr, aux);
                            break;
                          default:
                            argr = aux;
                        }
                    }
                }
                push(argreg, argr);
            }
        }
        builtin.expand(e, owner, start, result, argreg);
    }
}

//*********************************************

function gencallbuiltin(var owner, var start, var builtin, var args)
{
    var name = builtin.getname();
    string callname = name.getidentifier();
    owner.use_builtin(callname);
    int nargs = args == null ? 0 : args.numargs();
    var rawargs = nargs == 0 ? [] : args.getrawargs();

    var variants = builtin.variants;
    var variant;
    for (var v in variants) {
        int vargs = v.nparams;
        if (vargs == nargs ||
                vargs == BULTIN_arglist ||
                (vargs == BULTIN_raw1 && nargs == 1))
            variant = v;
    }
    if (variant == null)
        SyntaxError("Wrong arguments for builtin", start);

    // Check for compile time evaluation.
    if (variant.iscompileevaluable()) {
        if (arglist_hascompilevalue(rawargs)) {
            var evalfun = variant.evalfun;
            try {
                return evalfun(owner.owner, owner.start, rawargs);
            }
            catch (ex) {
                SyntaxError("Compile time evaluation of builtin " + callname +
                        " failed: '" + string(ex["message"]) + "'", start);
            }
        }
    }

    return new CallBuiltinExpr(owner, start, variant, rawargs);
}

class CallExpr : Expr
{
    var funref;
    var args;

    function CallExpr(var tk, var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.funref = subexpr;
        var t = tk.get();
        if (! t.isop(")")) {
            tk.unget(t);
            self.args = new ArgumentList(owner, start, tk, ")");
        }
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        var funref = self.funref.optimize();
        self.funref = funref;
        var args = self.args;
        if (args != null)
            self.args = args = args.optimize();
        var owner = self.owner;

        if (funref instanceof MemberExpr) {
            var sym = funref.search_nonmember();
            var start = self.start;
            switch {
              case sym == null:
                return new CallMemberExpr(self, funref, args);
              case sym instanceof FunctionStatement:
                string subid = sym.makesubid();
                self.usesubid(subid);
                return new CallSubid(self, funref, args, subid);
                break;
              case sym instanceof Builtin:
                return gencallbuiltin(owner, funref.start, sym, args);
                break;
              default:
                InternalError("unexpected type found in scope", start);
            }
        }
        if (funref instanceof MemberRefExpr)
            return new CallMemberRefExpr(self, funref, args);

        // Check for bultins
        if (funref.isidentifier()) {
            if (funref.checkIdentifier() == "") {
                var sym = self.scopesearch([ funref.getName() ], 0);
                if (sym != null && sym instanceof Builtin)
                    return gencallbuiltin(owner, funref.start, sym, args);
            }
        }

        return self;
    }
    function emitcall(var e)
    {
        var funref = self.funref;
        string call;

        if (funref.isidentifier()/* && funref.subid == null*/) {
            call = funref.checkIdentifier();
            if (call == "") {
                var sym = self.scopesearch([ funref.getName() ], 0);
                switch {
                  case sym == null:
                    call = join("", [ "'", funref.getName(), "'" ] );
                    break;
                  case sym instanceof Builtin:
                    InternalError("Builtin unexpected here", self);
                  default:
                    call = join("", [ "'", funref.getName(), "'" ] );
                }
            }
        }
        else
            call = funref.emit_get(e);
        return call;
    }
    function prepareargs(var e)
    {
        var args = self.args;
        if (args != null)
            args.getargvalues(e);
    }
    function emitargs(var e)
    {
        e.print("(");
        var args = self.args;
        if (args != null)
            args.emitargs(e);
        e.say(")");
    }
    function emit(var e, string result)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);

        self.annotate(e);
        e.print(INDENT, result, " = ");
        e.print(call);
        self.emitargs(e);
    }
    function emit_void(var e)
    {
        string call = self.emitcall(e);
        self.prepareargs(e);
        self.annotate(e);
        e.print(INDENT);
        e.print(call);
        self.emitargs(e);
    }
}

//*********************************************

// CallExpr variants. Always created from CallExpr, never directly.

class CallSubid : CallExpr
{
    var subid;
    function CallSubid(var callst, var funref, var args, string subid)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
        self.subid = subid;
    }
    function emitcall(var e)
    {
        return self.subid;
    }
}

// Method call by name.
class CallMemberExpr : CallExpr
{
    function CallMemberExpr(var callst, var funref, var args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(var e)
    {
        var funref = self.funref;

        var first = funref.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first.isidentifier()) {
            string check = first.checkIdentifier();
            if (check == null || check == "") {
                // The other usages are covered in other conditions,
                // here we have a qualified symbol not found in scope,
                // assume is function in a namespace not declared here.
                string key[];
                funref.buildkey(key);
                string fun = key.pop();
                var reg = self.tempreg(REGvar);
                self.annotate(e);
                e.emitget_hll_global(reg, fun, getparrotkey(key));
                return reg;
            }
        }
        return join("", [ funref.emit_left_get(e),
                ".'", funref.get_member(), "'" ] );
    }
}

// Method call by reference.
// The reference is a expression, its result must be a var containing a
// invokable or a string with the method name.
class CallMemberRefExpr : CallExpr
{
    function CallMemberRefExpr(var callst, var funref, var args)
    {
        self.Expr(callst.owner, callst.start);
        self.funref = funref;
        self.args = args;
    }
    function emitcall(var e)
    {
        var funref = self.funref;
        var right = funref.right;
        var type = right.checkresult();
        if (type != REGvar && type != REGstring)
            SyntaxError("Invalid expression type in '.*'", funref);
        // We want a well defined order of evaluation here, so use variables
        // to store intermediate results.
        string lreg = funref.emit_left_get(e);
        string rreg = right.emit_get(e);
        return lreg + "." + rreg;
    }
}

//*********************************************

class MemberExprBase : Expr
{
    var left;
    function MemberExprBase(var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.left = subexpr;
    }
    function emit_left_get(var e)
    {
        return self.left.emit_getvar(e);
    }
}

class MemberExpr : MemberExprBase
{
    var right;

    function MemberExpr(var owner, var start, var subexpr, var right)
    {
        self.MemberExprBase(owner, start, subexpr);
        self.right = right;
    }
    function checkresult() { return REGvar; }
    function search_nonmember()
    {
        // Check if the first element of the member expression
        // is an identfier. In that case, if it's not in scope
        // look for a function in accessible namespaces.
        var sym;
        var first = self.left;
        while (first instanceof MemberExpr)
            first = first.left;
        if (first instanceof IdentifierExpr) {
            var idfirst = first.checkIdentifier();
            if (idfirst == null || idfirst == "") {
                var key = [ ];
                self.buildkey(key);
                return self.scopesearch(key, 0);
            }
        }
        return null;
    }
    function optimize()
    {
        self.left = self.left.optimize();
        return self;
    }
    function buildkey(var key)
    {
        var left = self.left;
        if (left instanceof IdentifierExpr)
            push(key, left.getName());
        else
            left.buildkey(key);
        push(key, self.right.getidentifier());
    }
    function get_member()
    {
        return self.right;
    }
    function __emit_get_left(var e)
    {
        var left = self.left;
        if (left.checkresult() != REGvar)
            SyntaxError("non-var at left of '.'", self);
        return left.emit_get_nonull(e);
    }
    function emit_get(var e)
    {
        string result = self.tempreg(REGvar);
        self.emit(e, result);
        return result;
    }
    function emit(var e, string result)
    {
        string obj = self.__emit_get_left(e);
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, "getattribute ", result, ", ", obj, ", '", ident, "'");
    }
    function emit_assign_get(var e, var expr)
    {
        string obj = self.__emit_get_left(e);
        string value = self.tempreg(REGvar);
        if (expr.isnull())
            e.emitnull(value);
        else {
            string rreg = expr.emit_get(e);
            if (expr.checkresult() != REGvar)
                e.emitbox(value, rreg);
            else
                value = rreg;
        }
        string ident = self.right.getidentifier();
        self.annotate(e);
        e.say(INDENT, "setattribute ", obj, ", '", ident, "', ", value);
        return value;
    }
}

// Member dereference via a var or string expresion.
// When used for method calls is handled by CallMemberRefExpr.
// For attribute access only string is allowed.
class MemberRefExpr : MemberExprBase
{
    var right;
    function MemberRefExpr(var owner, var start, var left, var right)
    {
        self.MemberExprBase(owner, start, left);
        self.right = right;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        self.left = self.left.optimize();
        self.right = self.right.optimize();
        return self;
    }
    function emit(var e, string result)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        self.annotate(e);
        e.say(INDENT, "getattribute ", result, ", ", lreg, ", ", rreg);
    }
    function emit_assign_get(var e, var expr)
    {
        var left = self.left;
        var right = self.right;
        if (right.checkresult() != REGstring)
            Expected("string expression", right);
        string lreg = left.emit_get_nonull(e);
        string rreg = right.emit_get(e);
        string vreg;
        switch (expr.checkresult()) {
          case REGvar:
            vreg = expr.emit_get(e);
            // Special case
            if (vreg == NULL) {
                vreg = self.tempreg(REGvar);
                e.emitnull(vreg);
            }
            break;
          default:
            vreg = self.tempreg(REGvar);
            string aux = expr.emit_get(e);
            e.emitbox(vreg, aux);
        }

        self.annotate(e);
        e.say(INDENT, "setattribute ",  lreg, ", ", rreg, ", ", vreg);
        return vreg;
    }
}

//*********************************************

class StringIndexExpr : Expr
{
    var left;
    var arg;
    function StringIndexExpr(var owner, var start, var left, var arg)
    {
        self.Expr(owner, start);
        self.left = left;
        self.arg = arg;
    }
    function checkresult()
    {
       return REGstring;
    }
    function emit(var e, string result)
    {
        string lreg = self.left.emit_get(e);
        string rreg = self.arg.emit_getint(e);
        self.annotate(e);
        e.say(sformat(INDENT + "substr %0, %1, %2, 1",
                result, lreg, rreg));
    }
}

//*********************************************

class IndexExpr : Expr
{
    var left;
    var regleft;
    var args;
    var argregs;

    function IndexExpr(var tk, var owner, var start, var subexpr)
    {
        self.Expr(owner, start);
        self.left = subexpr;
        self.args = new SimpleArgList(tk, owner, "]");
    }
    function checkresult()
    {
       return REGvar;
    }
    function optimize()
    {
        var left = self.left.optimize();
        self.left = left;
        var args = self.args;
        args.optimizeargs();

        if (left.checkresult() == REGstring) {
            if (args.numargs() != 1)
               SyntaxError("Bad string index", self);
            var arg = args.getarg(0);
            return new StringIndexExpr(self.owner, self.start, left, arg);
        }

        return self;
    }
    function emit_prep(var e)
    {
        if (self.regleft != null || self.argregs != null)
            InternalError("wrong call to IndexExpr.emit_args", self.start);
        var left = self.left;
        self.regleft = left.isidentifier() ?
            left.getIdentifier() :
            left.emit_get(e);
        self.argregs = self.args.getargvalues(e);
    }
    function emit_aux(var e)
    {
        var regleft = self.regleft;
        var argregs = self.argregs;
        if (regleft == null || argregs == null)
            InternalError("wrong call to IndexExpr.emit_aux", self.start);
        e.print(self.regleft, "[");
        e.print(join("; ", argregs));
        e.print("]");
    }
    function emit(var e, string result)
    {
        self.emit_prep(e);
        self.annotate(e);
        e.print(INDENT, result, " = ");
        self.emit_aux(e);
        e.say("");
    }
    function emit_getint(var e)
    {
        string result = self.tempreg(REGint);
        self.emit(e, result);
        return result;
    }
    function emit_assign_get(var e, var expr)
    {
        self.emit_prep(e);
        string rreg;
        if (expr.isnull()) {
            rreg = self.tempreg(REGvar);
            e.emitnull(rreg);
        }
        else
            rreg = expr.emit_get(e);
        self.annotate(e);
        e.print(INDENT);
        self.emit_aux(e);
        e.say(" = ", rreg);
        return rreg;
    }
}

//*********************************************

class ArrayExpr : Expr
{
    var values;

    function ArrayExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.values = parseListOrEmpty(tk, owner, parseExpr, "]");
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.values);
        return self;
    }
    function emit(var e, string result)
    {
        string value = self.emit_get(e);
        e.emitset(result, value);
    }
    function emit_void(var e)
    {
        // No need to create the container, but the
        // initializers may have secondary effects,
        // so they should be evaluated.
        self.emit_init(e, "");
    }
    function emit_get(var e)
    {
        string container = self.tempreg(REGvar);
        self.emit_init(e, container);
        return container;
    }
    function emit_init(var e, string container)
    {
        self.annotate(e);
        var values = self.values;
        int size = values == null ? 0 : elements(values);
        if (container != "") {
            e.say(INDENT, "root_new ", container, ", ['parrot';'ResizablePMCArray']");
            if (size > 0)
                e.emitassign(container, size);
        }
        var collect = new CollectValues(self.owner, e);
        int i = 0;
        for (var value in values) {
            string valuereg = collect.add(value);
            if (container != "") {
                self.annotate(e);
                e.say(sformat(INDENT + "%0[%1] = %2", container, i, valuereg));
                i = i + 1;
            }
        }
    }
}

//*********************************************

class HashExpr : Expr
{
    var keys;
    var values;

    function HashExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        var t = tk.get();
        var keys = [];
        var values = [];
        if (!t.isop("}")) {
            tk.unget(t);
            do {
                var key = parseExpr(tk, owner);
                ExpectOp(":", tk);
                var value = parseExpr(tk, owner);
                push(keys, key);
                push(values, value);

            } while ((t = tk.get()).isop(","));
            if (! t.isop("}"))
                Expected("',' or '}'", t);
        }
        self.keys = keys;
        self.values = values;
    }
    function checkresult() { return REGvar; }
    function optimize()
    {
        optimize_array(self.keys);
        optimize_array(self.values);
        return self;
    }
    function emit(var e, string result)
    {
        self.annotate(e);

        // In void context there is no need to create the container,
        // but the keys and values may have secondary effects,
        // so they should ve evaluated.
        if (result != "")
            e.say(INDENT, "root_new ", result, ", ['parrot';'Hash']");

        var keys = self.keys;
        var values = self.values;
        var collectvalues = new CollectValues(self.owner, e);
        int n = keys;
        for (int i = 0; i < n; i = i + 1) {
            var key = keys[i];
            string keyreg;
            if (key.isidentifier() && key.checkIdentifier() == "") {
                string id = key.getName();
                keyreg = self.tempreg(REGvar);
                e.emitget_hll_global(keyreg, id);
            }
            else
                keyreg = key.emit_get(e);

            string valuereg = collectvalues.add(values[i]);
            if (result != "")
                e.say(INDENT, result, "[", keyreg, "] = ", valuereg);
        }
    }
    function emit_void(var e)
    {
        self.emit(e, "");
    }
    function emit_get(var e)
    {
        string container = self.tempreg(REGvar);
        self.emit(e, container);
        return container;
    }
}

//**********************************************************************

class NewBaseExpr : Expr
{
    var initializer;
    // The value of initializer is:
    // * null if no arguments          -> no parenthesis
    // * empty array if zero arguments -> parenthesized empty list
    // * non empty array otherwise     -> parenthesized non empty list

    function checkresult() { return REGvar; }
    function parseinitializer(var tk)
    {
        // Called with the tokenizer pointing right after the
        // opening parenthesis
        self.initializer = new ArgumentList(self.owner, self.start, tk, ")");
    }
    function numargs()
    {
        var initializer = self.initializer;
        return initializer == null ? -1 : int(initializer.numargs());
    }
    function optimize_initializer()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer.optimize();
    }
    function optimize()
    {
        self.optimize_initializer();
        return self;
    }
    function emit_constructor(var e, string regnew, string constructor)
    {
        var initializer = self.initializer;
        if (initializer != null)
            initializer.getargvalues(e);
        e.print(INDENT, regnew, ".'", constructor, "'(");
        if (initializer != null)
            initializer.emitargs(e);
        e.say(")");
    }
}

//**********************************************************************

class NewIndexedExpr : NewBaseExpr
{
    var nskey;

    function NewIndexedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierParrotKey(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop("("))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(var e, string result)
    {
        string reginit;
        switch (self.numargs()) {
          case -1:
          case 0:
            break;
          case 1:
            var initval = self.initializer.getfreearg(0);
            reginit = initval.emit_get(e);
            break;
          default:
            SyntaxError("Multiple init arguments not allowed here", self);
        }
        var nskey = self.nskey;

        e.print(INDENT + "new ", result, ", ");
        nskey.emit(e, null);
        if (reginit != null)
            e.print(", ", reginit);
        e.say();
    }
}

//**********************************************************************

class NewQualifiedExpr : NewBaseExpr
{
    var nskey;

    function NewQualifiedExpr(var tk, var owner, var start)
    {
        self.Expr(owner, start);
        self.owner = owner;
        var nskey = new ClassSpecifierId(tk, owner, start);
        self.nskey = nskey;
        var t = tk.get();
        if (t.isop("("))
            self.parseinitializer(tk);
        else
            tk.unget(t);
    }
    function emit(var e, string result)
    {
        int numinits = self.numargs();
        string regnew = result;
        if (numinits > 0)
            regnew = self.tempreg(REGvar);
        var nskey = self.nskey;

        if (regnew == "")
            regnew = self.tempreg(REGvar);

        nskey.emit_new(e, self, regnew);

        if (numinits >= 0) {
            string constructor = nskey.last();
            self.emit_constructor(e, regnew, constructor);
            e.emitset(result, regnew);
        }
    }
}

//**********************************************************************

function parseNew(var tk, var owner, var start)
{
    var t = tk.get();

    switch {
      case t.isop("["):
        // Class specifier is a key
        return new NewIndexedExpr(tk, owner, start);
      case t.isidentifier():
        // Identifier, maybe qualified
        return new NewQualifiedExpr(tk, owner, t);
      default:
        Expected("Identifier of class key", t);
    }
}

//**********************************************************************

class OpInstanceOfExpr : Expr
{
    var lexpr;
    var checked;

    function OpInstanceOfExpr(var owner, var start, var lexpr, var tk)
    {
        self.Expr(owner, start);
        self.lexpr = lexpr;
        self.checked = parseClassSpecifier(tk, owner);
    }
    function optimize()
    {
        self.lexpr = self.lexpr.optimize();
        return self;
    }
    function checkresult() { return REGint; }
    function emit(var e, string result)
    {
        var lexpr = self.lexpr;
        string ltype = lexpr.checkresult();
        if (ltype != REGvar)
            SyntaxError("Invalid instanceof left operand", lexpr);
        var checked = self.checked;

        string check = lexpr.emit_get(e);
        self.annotate(e);
        e.print(INDENT + "isa ", result, ", ", check, ", ");
        checked.emit(e, self.owner);
        e.say();
    }
}

//*********************************************

class OpConditionalExpr : Expr
{
    var condition;
    var etrue;
    var efalse;

    function OpConditionalExpr(var owner, var start,
            var condition, var etrue, var efalse)
    {
        self.Expr(owner, start);
        self.condition = (new Condition).set(condition);
        self.etrue = etrue;
        self.efalse = efalse;
        return self;
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.etrue = self.etrue.optimize();
        self.efalse = self.efalse.optimize();
        return self;
    }
    function checkresult()
    {
        var etrue = self.etrue;
        if (etrue.isnull())
            return self.efalse.checkresult();
        else
            return etrue.checkresult();
    }
    function emit(var e, string result)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        var etrue = self.etrue;
        string tres = self.checkresult();
        if (etrue.isnull())
            e.emitnull(result);
        else
            etrue.emit(e, result);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        var efalse = self.efalse;
        if (efalse.isnull())
            e.emitnull(result);
        else {
            string tfalse = efalse.checkresult();
            if (tres == REGvar && tfalse != REGvar) {
                string r = efalse.emit_get(e);
                e.emitbox(result, r);
            }
            else
            {
                if (tfalse == REGvar) {
                    var aux = efalse.emit_get(e);
                    e.emitset(result, aux);
                }
                else
                    efalse.emit(e, result);
            }
        }
        e.emitlabel(cond_end);
    }
    function emit_void(var e)
    {
        string cond_end = self.genlabel();
        string cond_false = self.genlabel();
        self.condition.emit_else(e, cond_false);
        self.etrue.emit_void(e);
        e.emitgoto(cond_end);
        e.emitlabel(cond_false);
        self.efalse.emit_void(e);
        e.emitlabel(cond_end);
    }
}

//*********************************************
//           Expressions parser
//*********************************************

const int
    Code_none          =  0,
    Code_paren         =  1,
    Code_bracket       =  2,
    Code_dot           =  3,
    Code_assign        =  4,
    Code_assign_to     =  5,
    Code_add_assign    =  6,
    Code_add           =  7,
    Code_minus         =  8,
    Code_inc           =  9,
    Code_dec           = 10,
    Code_not           = 11,
    Code_equal         = 12,
    Code_not_equal     = 13,
    Code_less          = 14,
    Code_less_equal    = 15,
    Code_greater       = 16,
    Code_greater_equal = 17,
    Code_sub_assign    = 18,
    Code_mul           = 19,
    Code_div           = 20,
    Code_mod           = 21,
    // operators %%, *= and /= not supported in this stage
    Code_same          = 25,
    Code_not_same      = 26,
    Code_instanceof    = 27,
    Code_shiftleft     = 28,
    Code_shiftright    = 29,
    Code_shiftlright   = 30,
    // operator %= not supported in this stage
    Code_delete        = 32,
    Code_exists        = 33,
    Code_bin_not       = 34;

function getOpCode_2(var t)
{
    switch (t.checkop()) {
    case "(": return Code_paren;
    case "[": return Code_bracket;
    case ".": return Code_dot;
    default:  return Code_none;
    }
}

function getOpCode_4(var t)
{
    switch (t.checkop()) {
    case "-":  return Code_minus;
    case "!":  return Code_not;
    case "~":  return Code_bin_not;
    case "++": return Code_inc;
    case "--": return Code_dec;
    default:
        if (t.iskeyword("delete")) return Code_delete;
        else if (t.iskeyword("exists")) return Code_exists;
        else return Code_none;
    }
}

function getOpCode_5(var t)
{
    switch (t.checkop()) {
    case "*":  return Code_mul;
    case "/":  return Code_div;
    case "%":  return Code_mod;
    default:   return Code_none;
    }
}

function getOpCode_7(var t)
{
    switch (t.checkop()) {
    case "<<":  return Code_shiftleft;
    case ">>":  return Code_shiftright;
    case ">>>": return Code_shiftlright;
    default:    return Code_none;
    }
}

function getOpCode_8(var t)
{
    switch (t.checkop()) {
    case "<":  return Code_less;
    case ">":  return Code_greater;
    case "<=": return Code_less_equal;
    case ">=": return Code_greater_equal;
    default:
        if (t.iskeyword("instanceof")) return Code_instanceof;
        else return Code_none;
    }
}

function getOpCode_9(var t)
{
    switch (t.checkop()) {
    case "==":  return Code_equal;
    case "!=":  return Code_not_equal;
    case "===":  return Code_same;
    case "!==":  return Code_not_same;
    default:   return Code_none;
    }
}

function getOpCode_16(var t)
{
    switch (t.checkop()) {
    case "=":  return Code_assign;
    case "=:": return Code_assign_to;
    case "+=": return Code_add_assign;
    case "-=": return Code_sub_assign;
    default:   return Code_none;
    }
}

function parseExpr_0(var tk, var owner)
{
    var t = tk.get();
    var expr;

    switch {
      case t.isop("("):
        expr = parseExpr(tk, owner);
        ExpectOp(")", tk);
        return expr;
      case t.isop("["):
        return new ArrayExpr(tk, owner, t);
      case t.isop("{"):
        return new HashExpr(tk, owner, t);
      case t.isstring():
        return new StringLiteral(owner, t);
      case t.isint():
        return integerValue(owner, t, t.getintvalue());
      case t.iskeyword("new"):
        return parseNew(tk, owner, t);
      case t.iskeyword("function"):
        return new FunctionExpr(tk, owner, t);
      case t.iskeyword("class"):
        return new OpClassExpr(tk, owner, t);
      case t.iskeyword("namespace"):
        return new OpNamespaceExpr(tk, owner, t);
      case t.isidentifier():
        return new IdentifierExpr(owner, t);
      default:
        Expected("expression", t);
    }
}

function parseExpr_2(var tk, var owner)
{
    var subexpr = parseExpr_0(tk, owner);
    var t;
    var start;
    int code;
    while ((code = getOpCode_2(t = tk.get())) != Code_none ) {
        switch (code) {
          case Code_paren:
            subexpr = new CallExpr(tk, owner, t, subexpr);
            break;
          case Code_bracket:
            subexpr = new IndexExpr(tk, owner, t, subexpr);
            break;
          case Code_dot:
            start = t;
            t = tk.get();
            if (t.isop("*")) {
                var right = parseExpr_0(tk, owner);
                subexpr = new MemberRefExpr(owner, t, subexpr, right);
            }
            else
                subexpr = new MemberExpr(owner, start, subexpr, t);
            break;
          default:
            InternalError("Unexpected code in parseExpr_2");
        }
    }
    tk.unget(t);
    return subexpr;
}

function parseExpr_3(var tk, var owner)
{
    var subexpr = parseExpr_2(tk, owner);
    var t = tk.get();
    switch {
      case t.isop("++"):
        return new OpPostIncExpr(owner, t, subexpr);
      case t.isop("--"):
        return new OpPostDecExpr(owner, t, subexpr);
      default:
        tk.unget(t);
        return subexpr;
    }
}

function parseExpr_4(var tk, var owner)
{
    var t = tk.get();
    int code = getOpCode_4(t);
    if (code != Code_none) {
        var subexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_minus:
            return new OpUnaryMinusExpr(owner, t, subexpr);
          case Code_not:
            return new OpNotExpr(owner, t, subexpr);
          case Code_bin_not:
            return new OpBinNotExpr(owner, t, subexpr);
          case Code_inc:
            return new OpPreIncExpr(owner, t, subexpr);
          case Code_dec:
            return new OpPreDecExpr(owner, t, subexpr);
          case Code_delete:
            return new OpDeleteExpr(owner, t, subexpr);
          case Code_exists:
            return new OpExistsExpr(owner, t, subexpr);
          default:
            InternalError("Invalid code in parseExpr_4", t);
        }
    }
    else {
        tk.unget(t);
        return  parseExpr_3(tk, owner);
    }
}

function parseExpr_5(var tk, var owner)
{
    var lexpr = parseExpr_4(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_5(t = tk.get())) != Code_none) {
        var rexpr = parseExpr_4(tk, owner);
        switch (code) {
          case Code_mul:
            lexpr = new OpMulExpr(owner, t, lexpr, rexpr);
            break;
          case Code_div:
            lexpr = new OpDivExpr(owner, t, lexpr, rexpr);
            break;
          case Code_mod:
            lexpr = new OpModExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError("Invalid code in parseExpr_5", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_6(var tk, var owner)
{
    var lexpr = parseExpr_5(tk, owner);
    var t;
    while ((t = tk.get()).isop("+") || t.isop("-")) {
        var rexpr = parseExpr_5(tk, owner);
        var expr;
        if (t.isop("+"))
            expr = new OpAddExpr(owner, t, lexpr, rexpr);
        else
            expr = new OpSubExpr(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_7(var tk, var owner)
{
    var lexpr = parseExpr_6(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_7(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_shiftleft:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftleftExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftrightExpr(owner, t, lexpr, rexpr);
            break;
          case Code_shiftlright:
            rexpr = parseExpr_6(tk, owner);
            lexpr = new OpShiftlrightExpr(owner, t, lexpr, rexpr);
            break;
          default:
            InternalError("Invalid code in parseExpr_7", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_8(var tk, var owner)
{
    var lexpr = parseExpr_7(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_8(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_less:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_less_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpLessEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_greater_equal:
            rexpr = parseExpr_7(tk, owner);
            lexpr = (new OpGreaterEqualExpr).set(owner, t, lexpr, rexpr);
            break;
          case Code_instanceof:
            lexpr = new OpInstanceOfExpr(owner, t, lexpr, tk);
            break;
          default:
            InternalError("Invalid code in parseExpr_9", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_9(var tk, var owner)
{
    var lexpr = parseExpr_8(tk, owner);
    var rexpr;
    var t;
    int code;
    while ((code = getOpCode_9(t = tk.get())) != Code_none) {
        switch (code) {
          case Code_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_equal:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpEqualExpr(owner, t, lexpr, rexpr, false);
            break;
          case Code_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, true);
            break;
          case Code_not_same:
            rexpr = parseExpr_8(tk, owner);
            lexpr = new OpSameExpr(owner, t, lexpr, rexpr, false);
            break;
          default:
            InternalError("Invalid code in parseExpr_8", t);
        }
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_10(var tk, var owner)
{
    var lexpr = parseExpr_9(tk, owner);
    var t;
    while ((t = tk.get()).isop("&")) {
        var rexpr = parseExpr_9(tk, owner);
        lexpr = new OpBinAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_11(var tk, var owner)
{
    var lexpr = parseExpr_10(tk, owner);
    var t;
    while ((t = tk.get()).isop("^")) {
        var rexpr = parseExpr_10(tk, owner);
        lexpr = new OpBinXorExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_12(var tk, var owner)
{
    var lexpr = parseExpr_11(tk, owner);
    var t;
    while ((t = tk.get()).isop("|")) {
        var rexpr = parseExpr_11(tk, owner);
        lexpr = new OpBinOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_13(var tk, var owner)
{
    var lexpr = parseExpr_12(tk, owner);
    var t;
    while ((t = tk.get()).isop("&&")) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolAndExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_14(var tk, var owner)
{
    var lexpr = parseExpr_13(tk, owner);
    var t;
    while ((t = tk.get()).isop("||")) {
        var rexpr = parseExpr_12(tk, owner);
        lexpr = new OpBoolOrExpr(owner, t, lexpr, rexpr);
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr_15(var tk, var owner)
{
    var econd = parseExpr_14(tk, owner);
    var t = tk.get();
    if (t.isop("?")) {
        var etrue = parseExpr_16(tk, owner);
        ExpectOp(":", tk);
        var efalse = parseExpr_16(tk, owner);
        return new OpConditionalExpr(owner, t, econd, etrue, efalse);
    }
    else {
        tk.unget(t);
        return econd;
    }
}

function parseExpr_16(var tk, var owner)
{
    var lexpr = parseExpr_15(tk, owner);
    var t;
    int code;
    while ((code = getOpCode_16(t = tk.get())) != Code_none ) {
        var rexpr = parseExpr_16(tk, owner);
        var expr;
        switch (code) {
          case Code_assign:
            expr = new OpAssignExpr;
            break;
          case Code_assign_to:
            expr = new OpAssignToExpr;
            break;
          case Code_add_assign:
            expr = new OpAddToExpr;
            break;
          case Code_sub_assign:
            expr = new OpSubToExpr;
            break;
          default:
            InternalError("Unexpected code in parseExpr_16", t);
        }
        expr.set(owner, t, lexpr, rexpr);
        lexpr = expr;
    }
    tk.unget(t);
    return lexpr;
}

function parseExpr(var tk, var owner)
{
    return parseExpr_16(tk, owner);
}

//*********************************************
//         Breakable and Continuable
//*********************************************

// Abstract base class for statments that can contain break
// and continue statments. Continuable is always breakable.

class Breakable
{
    var brlabel;

    function genbreaklabel()
    {
        if (self.brlabel != null)
            InternalError("attempt to generate break label twice");
        string label = self.genlabel();
        self.brlabel = label;
        return label;
    }
    function getbreaklabel(var pos)
    {
        var label = self.brlabel;
        if (label == null)
            InternalError("attempt to get break label before creating it");
        return label;
    }
}

class Continuable : Breakable
{
    var cntlabel;

    function gencontinuelabel()
    {
        if (self.cntlabel != null)
            InternalError("attempt to generate continue label twice");
        string label = self.genlabel();
        self.cntlabel = label;
        return label;
    }
    function getcontinuelabel(var pos)
    {
        var label = self.cntlabel;
        if (label == null)
            InternalError("attempt to get continue label before creating it");
        return label;
    }
}

//*********************************************
//            ReturnStatement
//*********************************************

class ReturnStatement : Statement
{
    var values;

    function ReturnStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        var t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.values = new ArgumentList(owner, start, tk, ";");
        }
    }
    function optimize()
    {
        var values = self.values;
        if (values != null)
            values = values.optimize();
        return self;
    }
    function emit(var e)
    {
        var values = self.values;
        int n = values == null ? 0 : int(values.numargs());

        if (n > 0)
            values.getargvalues(e);

        self.annotate(e);
        e.print(INDENT, ".return(");
        if (n > 0)
            values.emitargs(e);
        e.say(")");
    }
}

//*********************************************
//          ConditionalStatement
//*********************************************

class ConditionalStatement : Statement, Condition
{
    function parseconditionshort(var tk)
    {
        self.set(parseExpr(tk, self));
    }
    function parsecondition(var tk)
    {
        ExpectOp("(", tk);
        self.set(parseExpr(tk, self));
        ExpectOp(")", tk);
    }
}

//*********************************************
//            IfStatement
//*********************************************

class IfStatement : ConditionalStatement
{
    var truebranch;
    var falsebranch;
    function IfStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.truebranch = parseStatement(tk, self);
        var t = tk.get();
        if (t.iskeyword("else"))
            self.falsebranch = parseStatement(tk, self);
        else {
            self.falsebranch = new EmptyStatement;
            tk.unget(t);
        }
    }
    function optimize()
    {
        self.optimize_condition();
        self.truebranch = self.truebranch.optimize();
        self.falsebranch = self.falsebranch.optimize();
        switch (self.getvalue()) {
          case CONDistrue:
            return self.truebranch;
          case CONDisfalse:
            return self.falsebranch;
        }
        return self;
    }
    function emit(var e)
    {
        var truebranch = self.truebranch;
        var falsebranch = self.falsebranch;
        string elselabel = self.genlabel();
        string endlabel = self.genlabel();
        self.annotate(e);
        self.emit_else(e, elselabel);
        truebranch.emit(e);
        e.emitgoto(endlabel);
        e.emitlabel(elselabel, "else");
        falsebranch.emit(e);
        e.emitlabel(endlabel, "endif");
    }
}

//*********************************************
//            LoopStatement
//*********************************************

class LoopStatement : Continuable
{
    var body;
    function parsebody(var tk)
    {
        self.body = parseStatement(tk, self);
    }
    function emit_infinite(var e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.emitlabel(continuelabel, "Infinite loop");
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, "Infinite loop end");
    }
}

//*********************************************
//            WhileStatement
//*********************************************

class WhileStatement : LoopStatement, ConditionalStatement
{
    function WhileStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsecondition(tk);
        self.parsebody(tk);
    }
    function optimize()
    {
        self.optimize_condition();
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        string breaklabel = self.genbreaklabel();
        string continuelabel = self.gencontinuelabel();

        self.annotate(e);
        e.emitlabel(continuelabel, "while");
        self.emit_else(e, breaklabel);
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, "endwhile");
    }
}

//*********************************************
//            DoStatement
//*********************************************

class DoStatement : LoopStatement, ConditionalStatement
{
    function DoStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.parsebody(tk);
        ExpectKeyword("while", tk);
        self.parsecondition(tk);
    }
    function optimize()
    {
        self.optimize_condition();
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        var body = self.body;
        int condvalue = self.getvalue();
        switch (condvalue) {
          case CONDistrue:
            self.emit_infinite(e);
            break;
          default:
            string looplabel = self.genlabel();
            string breaklabel = self.genbreaklabel();
            string continuelabel = self.gencontinuelabel();

            self.annotate(e);
            e.emitlabel(looplabel, "do");

            body.emit(e);
            e.emitlabel(continuelabel, "continue");
            if (condvalue != CONDisfalse)
                self.emit_if(e, looplabel, breaklabel);
            e.emitlabel(breaklabel, "enddo");
        }
    }
}

//*********************************************
//            ContinueStatement
//*********************************************

class ContinueStatement : Statement
{
    function ContinueStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        ExpectOp(";", tk);
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        string label = self.getcontinuelabel(self.start);
        e.emitgoto(label, "continue");
    }
}

//*********************************************
//            BreakStatement
//*********************************************

class BreakStatement : Statement
{
    function BreakStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        ExpectOp(";", tk);
    }
    function optimize() { return self; }
    function emit(var e)
    {
        self.annotate(e);
        string label = self.getbreaklabel(self.start);
        e.emitgoto(label, "break");
    }
}

//*********************************************
//            SwitchBaseStatement
//*********************************************

class SwitchBaseStatement : Breakable, Statement
{
    var case_value;
    var case_st;
    var default_st;

    function SwitchBaseStatement(var start, var owner)
    {
        self.Statement(start, owner);
        self.case_value = [];
        self.case_st = [];
        self.default_st = [];
    }
    function parse_switchbody(var tk)
    {
        var t = tk.get();
        switch {
          case t.isop("}"):
            // No cases and no default
            break;
          case t.iskeyword("default"):
            // default without cases
            self.parse_default(tk);
            break;
          case t.iskeyword("case"):
            self.parse_cases(tk);
            break;
          default:
            Expected("switch cases", t);
        }
    }
    function parse_cases(var tk)
    {
        var t;
        do {
            push(self.case_value, parseExpr(tk, self));
            t = tk.get();
            if (! t.isop(":"))
                Expected("':' in case", t);
            var st = [];
            while (! ((t = tk.get()).isop("}") || t.iskeyword("case") || t.iskeyword("default"))) {
                tk.unget(t);
                push(st, parseStatement(tk, self));
            }
            push(self.case_st, st);
        } while (t.iskeyword("case"));
        if (t.iskeyword("default"))
            self.parse_default(tk);
    }
    function parse_default(var tk)
    {
        var t = tk.get();
        if (! t.isop(":"))
            Expected("':' in default", t);
        while (! (t = tk.get()).isop("}")) {
            if (t.iskeyword("case"))
                SyntaxError("case after default", t);
            if (t.iskeyword("default"))
                SyntaxError("default after default", t);
            tk.unget(t);
            push(self.default_st, parseStatement(tk, self));
        }
    }
    function optimize_cases()
    {
        optimize_array(self.case_value);
        for_each(self.case_st, optimize_array);
        optimize_array(self.default_st);
    }
}

//*********************************************
//            SwitchStatement
//*********************************************

class SwitchStatement : SwitchBaseStatement
{
    var condition;

    function SwitchStatement(var start, var tk, var owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.condition = parseExpr(tk, self);
        var t = tk.get();
        if (! t.isop(")"))
            Expected("')' in switch", t);
        t = tk.get();
        if (! t.isop("{"))
            Expected("'{' in switch", t);
        self.parse_switchbody(tk);
    }
    function optimize()
    {
        self.condition = self.condition.optimize();
        self.optimize_cases();
        return self;
    }
    function emit(var e)
    {
        // Get case common type
        // If all cases are literal strings of length 1, convert to
        // the code of the first char
        string type = "";
        for (var value in self.case_value) {
            string t = value.checkresult();
            if (t == REGfloat)
                SyntaxError("Invalid type in case", self);
            if (t == REGstring) {
                if (type == "" || type == "char")
                {
                    if (value.isstringliteral() && length(string_from_literal(value)) == 1)
                        t = "char";
                    else
                        type = REGstring;
                }
            }
            if (type == "")
                type = t;
            else if (type != t)
                type = REGvar;
        }
        // Evaluate condition
        var condition = self.condition;
        var condtype = condition.checkresult();

        // This can happen if there isn't any case. Not likely in hand
        // written code but allowing it may simplify code generators.
        if (type == "")
            type = condtype;

        e.comment("switch");
        string defaultlabel = self.genlabel();
        string reg;
        if (type == "char") {
            if ((condition instanceof CallBuiltinExpr) &&
                        condition.builtin.name() == "chr") {
                var args = condition.args;
                var arg = args[0].arg;
                reg = arg.emit_getint(e);
            }
            else {
                string regs;
                if (condtype != REGstring) {
                    string regcond = condition.emit_get(e);
                    regs = self.tempreg(REGstring);
                    e.emitset(regs, regcond);
                }
                else
                    regs = condition.emit_get(e);
                e.emitif_null(regs, defaultlabel);
                reg = self.tempreg(REGint);
                e.emitarg2("length", reg, regs);
                e.emitarg3("ne", reg, "1", defaultlabel);
                e.emitarg2("ord", reg, regs);
            }
        }
        else if (condtype == type)
            reg = condition.emit_get(e);
        else {
            reg = self.tempreg(type);
            string regcond = condition.emit_get(e);
            e.emitset(reg, regcond);
        }

        // Prpeare labels and check values
        self.genbreaklabel();
        string caselabel[];
        string regval;
        if (type != "char")
            self.tempreg(type);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            string casereg;
            if (type == REGint)
                casereg = caseval.emit_getint(e);
            else if (type == "char") {
                int code = ord(string_from_literal(caseval));
                casereg = code;
            }
            else if (type == caseval.checkresult())
                casereg = caseval.emit_get(e);
            else {
                caseval.emit(e, regval);
                casereg = regval;
            }
            e.say(sformat(INDENT + "if %0 == %1 goto %2", reg, casereg, label));
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; i = i + 1) {
            e.emitlabel(caselabel[i], "case");
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, "default");
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), "switch end");
    }
}

//*********************************************
//            SwitchCaseStatement
//*********************************************

class SwitchCaseStatement : SwitchBaseStatement
{

    function SwitchCaseStatement(var start, var tk, var owner)
    {
        self.SwitchBaseStatement(start, owner);
        self.parse_switchbody(tk);
    }
    function optimize()
    {
        self.optimize_cases();
        return self;
    }
    function emit(var e)
    {
        // Prpeare labels and check values
        self.genbreaklabel();
        string defaultlabel = self.genlabel();
        string caselabel[];

        e.comment("switch-case");
        string reg = self.tempreg(REGint);
        for (var caseval in self.case_value) {
            string label = self.genlabel();
            push(caselabel, label);
            if (caseval.checkresult() == REGint)
                caseval.emit(e, reg);
            else {
                string auxreg = caseval.emit_get(e);
                e.emitset(reg, auxreg);
            }
            e.emitif(reg, label);
        }
        e.emitgoto(defaultlabel);

        // Emit cases
        self.annotate(e);
        var case_st = self.case_st;
        int n = case_st;
        for (int i = 0; i < n; i = i + 1) {
            e.emitlabel(caselabel[i], "case");
            emit_array(e, case_st[i]);
        }
        // Emit default
        e.emitlabel(defaultlabel, "default");
        emit_array(e, self.default_st);

        e.emitlabel(self.getbreaklabel(self.start), "switch end");
    }
}

//*********************************************

function parseSwitch(var start, var tk, var owner)
{
    var t = tk.get();
    if (t.isop("("))
        return new SwitchStatement(start, tk, owner);
    if (t.isop("{"))
        return new SwitchCaseStatement(start, tk, owner);
    Expected("'(' in switch", t);
}

//*********************************************
//            ForStatement
//*********************************************

class ForStatement : LoopStatement, BlockStatement, ConditionalStatement
{
    var initializer;
    var iteration;

    function ForStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        var t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.initializer = parseStatement(tk, self);
        }
        t = tk.get();
        if (! t.isop(";")) {
            tk.unget(t);
            self.parseconditionshort(tk);
            ExpectOp(";", tk);
        }
        self.iteration = parseListOrEmpty(tk, self, parseExpr, ")");
        self.parsebody(tk);
    }
    function optimize()
    {
        var initializer = self.initializer;
        if (initializer != null)
            self.initializer = initializer.optimize();
        if (self.condexpr != null)
            self.optimize_condition();
        optimize_array(self.iteration);
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        var iteration = self.iteration;
        int has_iteration = iteration != null;
        if (self.initializer == null &&
                self.condexpr == null &&
                !(has_iteration)) {
            self.emit_infinite(e);
            return;
        }
        e.comment("for loop");
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        string condlabel = has_iteration ?
                string(self.genlabel()) :
                continuelabel;
        if (self.initializer != null)
            self.initializer.emit(e);

        e.emitlabel(condlabel, "for condition");
        if (self.condexpr != null)
            self.emit_else(e, breaklabel);

        self.body.emit(e);
        if (has_iteration) {
            e.emitlabel(continuelabel, "for iteration");
            for (var it in iteration)
                it.emit_void(e);
        }
        e.emitgoto(condlabel);

        e.emitlabel(breaklabel, "for end");
    }
}

//*********************************************
//            ForeachStatement
//*********************************************

class ForeachStatement : LoopStatement, BlockStatement
{
    var deftype;
    var varname;
    var container;

    function ForeachStatement(var start, var tk, var owner, var name, string type)
    {
        self.BlockStatement(start, owner);
        if (type != "")
            self.deftype = type;
        self.varname = name;
        self.container = parseExpr(tk, self);
        ExpectOp(")", tk);
        self.parsebody(tk);
    }
    function optimize()
    {
        var deftype = self.deftype;
        if (deftype != null)
            self.createvar(self.varname, deftype);
        self.container = self.container.optimize();
        self.body = self.body.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string regcont;
        if (self.container.checkresult() == REGstring) {
            string value = self.container.emit_get(e);
            regcont = self.tempreg(REGvar);
            e.emitbox(regcont, value);
        }
        else
            regcont = self.container.emit_get(e);

        var itvar = self.getvar(self.varname);
        if (itvar == null)
            UndefinedVariable(self.varname, self);

        string iterator = self.createreg(REGvar);
        string continuelabel = self.gencontinuelabel();
        string breaklabel = self.genbreaklabel();
        e.emitif_null(regcont, breaklabel);
        e.emitarg2("iter", iterator, regcont);
        e.emitset(iterator, "0");
        e.emitlabel(continuelabel, "for iteration");
        e.emitunless(iterator, breaklabel);
        e.emitarg2("shift", itvar.getreg(), iterator);
        self.body.emit(e);
        e.emitgoto(continuelabel);
        e.emitlabel(breaklabel, "endfor");
    }
}

//*********************************************

function parseFor(var t, var tk, var owner)
{
    ExpectOp("(", tk);
    var aux = tk.get();
    if (aux.isidentifier()) {
        var in1 = tk.get();
        if (in1.isidentifier()) {
            if (in1.iskeyword("in"))
                return new ForeachStatement(t, tk, owner, aux, "");
            else {
                var in2 = tk.get();
                string type = typetoregcheck(aux.getidentifier());
                if (in2.iskeyword("in") && type != "")
                    return new ForeachStatement(t, tk, owner, in1, type);
                tk.unget(in2);
            }
        }
        tk.unget(in1);
    }
    tk.unget(aux);
    return new ForStatement(t, tk, owner);
}

//*********************************************
//            ThrowStatement
//*********************************************

class ThrowStatement : Statement
{
    var excep;

    function ThrowStatement(var start, var tk, var owner)
    {
        self.Statement(start, owner);
        self.excep = parseExpr(tk, self);
    }
    function optimize()
    {
        self.excep = self.excep.optimize();
        return self;
    }
    function emit(var e)
    {
        var excep = self.excep;
        string reg = excep.emit_get(e);
        self.annotate(e);
        switch (excep.checkresult()) {
          case REGvar:
            // Nothing to do here
            break;
          case REGstring:
            // Build a Exception with default values and the message provided
            string msg = reg;
            reg = self.tempreg(REGvar);
            e.print(sformat(
<<:
    root_new %0, ["parrot";"Exception"]
    %0["message"] = %1
:>>
                , reg, msg));
            break;
          default:
            SyntaxError("Invalid throw argument", self);
        }
        e.emitarg1("throw", reg);
    }
}

//*********************************************
//            TryStatement
//*********************************************

class TryStatement : BlockStatement
{
    var stry;
    var exname;
    var scatch;

    function TryStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);

        self.stry = parseStatement(tk, self);
        var t = tk.get();
        if (! t.iskeyword("catch"))
            ExpectedOp("catch", t);
        t = tk.get();
        if (! t.isop("("))
            Expected("'(' after 'catch'", t);
        t = tk.get();
        if (! t.isop(")")) {
            RequireIdentifier(t);
            self.exname = t;
            t = tk.get();
            if (! t.isop(")"))
                Expected("')' in 'catch'", t);
        }
        self.scatch = parseStatement(tk, self);
    }
    function optimize()
    {
        self.stry = self.stry.optimize();
        if (self.exname != null)
            self.createvar(self.exname, REGvar);
        self.scatch = self.scatch.optimize();
        return self;
    }
    function emit(var e)
    {
        string reghandler = self.tempreg(REGvar);
        string labelhandler = self.genlabel();
        string labelpasthandler = self.genlabel();
        string exreg = self.exname != null ?
            self.getvar(self.exname).getreg() :
            self.tempreg(REGvar);

        self.annotate(e);
        e.comment("try: create handler");
        e.print(sformat(
<<:
    new %0, "ExceptionHandler"
    set_label %0, %1
:>>
            , reghandler, labelhandler));

        e.emitarg1("push_eh", reghandler);
        e.comment("try: begin");
        self.stry.emit(e);
        e.comment("try: end");
        e.say(INDENT, "pop_eh");

        self.annotate(e);
        e.emitgoto(labelpasthandler);

        e.comment("catch");
        e.emitlabel(labelhandler);
        e.say(INDENT, ".get_results(", exreg, ")");
        e.emitarg1("finalize", exreg);
        e.say(INDENT, "pop_eh");
        self.scatch.emit(e);

        e.comment("catch end");
        e.emitlabel(labelpasthandler);
    }
}

//*********************************************
//            DeclareItem
//*********************************************

/*
    Base class for all variable declarations.
*/

class DeclareItem : Statement
{
    var name;
    var regtype;
    var reg;
    var flags;

    function DeclareItem(var start, var owner,
            var name, string regtype, int flags)
    {
        self.Statement(start, owner);
        self.name = name;
        self.regtype = regtype;
        self.flags = flags;
    }
    function optimizedeclare()
    {
        var vdata = self.createvar(self.name, self.regtype, self.flags);
        self.reg = vdata.getreg();
    }
}

//*********************************************
//            VarBaseStatement
//*********************************************

class VarBaseStatement : DeclareItem
{
    function initvarbase(var start, var owner, var name, int flags[optional])
    {
        self.DeclareItem(start, owner, name, REGvar, flags);
    }
}

//*********************************************
//            Declare Statements
//*********************************************

class DeclareBase : DeclareItem
{
    var basetype;
    function DeclareBase(var start, var owner, var name, string basetype, string regtype)
    {
        self.DeclareItem(start, owner, name, regtype, 0);
        self.basetype = basetype;
    }
}

//*********************************************

class DeclareSingleStatement : DeclareBase
{
    var init;

    function DeclareSingleStatement(var start, var owner,
            var name, string basetype, var tk)
    {
        self.DeclareBase(start, owner, name, basetype, basetype);
        var t = tk.get();
        if (t.isop("=")) {
            // Simple initializer
            self.init = parseExpr(tk, self);
        }
        else
            tk.unget(t);
    }
    function optimize()
    {
        self.optimizedeclare();
        var init = self.init;
        if (init != null)
            self.init = init.optimize();
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);
        string name = self.name;
        string reg = self.reg;
        string ireg;
        string basetype = self.basetype;
        var init = self.init;
        e.comment(name, ": ", reg);

        if (init == null || init.isnull())
            e.emitnull(reg);
        else {
            string itype = init.checkresult();
            if (itype == basetype)
                init.emit_init(e, reg);
            else {
                if (init instanceof IndexExpr) {
                    // Use the declared type for the indexing
                    init.emit(e, reg);
                }
                else if (init.isliteral()) {
                    switch (basetype) {
                      case REGint:
                        ireg = int_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      case REGstring:
                        ireg = string_from_literal(init);
                        e.emitset(reg, ireg);
                        break;
                      default:
                        InternalError("Wrong type", self);
                    }
                }
                else {
                    switch (itype) {
                      case REGnone:
                        SyntaxError("Invalid initialization from void value", self);
                      default:
                        ireg = init.emit_get(e);
                    }
                    if (basetype == REGstring && itype == REGvar) {
                        string auxlabel = self.genlabel();
                        e.emitnull(reg);
                        e.emitif_null(ireg, auxlabel);
                        e.emitset(reg, ireg);
                        e.emitlabel(auxlabel);
                    }
                    else
                        e.emitset(reg, ireg);
                }
            }
        }
    }
}

//*********************************************

class DeclareArrayStatement : DeclareBase
{
    var size;
    var initarray;
    var arraytype;

    function DeclareArrayStatement(var start, var owner,
            var name, string basetype, string arraytype,
            var tk)
    {
        self.DeclareBase(start, owner, name, basetype, REGvar);
        self.arraytype = arraytype;
        var t = tk.get();
        if (! t.isop("]")) {
            // Fixed length
            tk.unget(t);
            self.size = parseExpr(tk, self);
            ExpectOp("]", tk);
        }
        t = tk.get();
        if (t.isop("=")) {
            t = tk.get();
            if (! t.isop("["))
                Expected("array initializer", t);
            self.initarray = parseListOrEmpty(tk, self, parseExpr, "]");
        }
        else
            tk.unget(t);
    }
    function optimize()
    {
        self.optimizedeclare();
        if (self.size != null)
            self.size = self.size.optimize();
        optimize_array(self.initarray);
        return self;
    }
    function emit(var e)
    {
        self.annotate(e);

        var reg = self.reg;
        var size = self.size;
        var init = self.initarray;
        var basetype = self.basetype;
        var arraytype = self.arraytype;
        if (size != null) {
            // Fixed size array
            e.say(sformat(INDENT + "new %0, ['Fixed%1Array'], %2",
                    reg, arraytype, size.emit_get(e)));
        }
        else {
            // Variable size array
            e.say(sformat(INDENT + "new %0, ['Resizable%1Array']",
                    reg, arraytype));
        }
        if (init != null) {
            string itemreg = self.tempreg(basetype);
            int n = elements(init);
            if (size == null) {
                if (n != 0) {
                    // Allocate initializers size
                    e.emitset(reg, n);
                }
            }
            int i = 0;
            for (var item in init) {
                item.emit(e, itemreg);
                e.say(sformat(INDENT + "%0[%1] = %2", reg, i, itemreg));
                i = i + 1;
            }
        }
    }
}

//*********************************************

function parseDeclareHelper(var funsingle, var funarray,
        var start, var tk, var owner)
{
    var next;
    var r = null;
    do {
        var name = tk.get();
        RequireIdentifier(name);
        var t = tk.get();
        var item;
        if (t.isop("["))
            item = funarray(start, owner, tk, name);
        else {
            tk.unget(t);
            item = funsingle(start, owner, name, tk);
        }
        r = addtomulti(r, item);
        next = tk.get();
    } while (next.isop(","));
    RequireOp(";", next);
    return r;
}

//*********************************************

class IntStatement : DeclareSingleStatement
{
    function IntStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGint, tk);
    }
}

class IntArrayStatement : DeclareArrayStatement
{
    function IntArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGint, "Integer", tk);
    }
}


function newIntSingle(var start, var owner, var name, var tk)
{
    return new IntStatement(start, owner, name, tk);
}

function newIntArray(var start, var owner, var tk, var name)
{
    return new IntArrayStatement(start, owner, name, tk);
}

function parseInt(var start, var tk, var owner)
{
    return parseDeclareHelper(newIntSingle, newIntArray, start, tk, owner);
}

//*********************************************

class FloatStatement : DeclareSingleStatement
{
    function FloatStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGfloat, tk);
    }
}

class FloatArrayStatement : DeclareArrayStatement
{
    function FloatArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGfloat, "Float", tk);
    }
}


function newFloatSingle(var start, var owner, var name, var tk)
{
    return new FloatStatement(start, owner, name, tk);
}

function newFloatArray(var start, var owner, var tk, var name)
{
    return new FloatArrayStatement(start, owner, name, tk);
}

function parseFloat(var start, var tk, var owner)
{
    return parseDeclareHelper(newFloatSingle, newFloatArray, start, tk, owner);
}

//*********************************************

class StringStatement : DeclareSingleStatement
{
    function StringStatement(var start, var owner, var name, var tk)
    {
        self.DeclareSingleStatement(start, owner, name, REGstring, tk);
    }
}

class StringArrayStatement : DeclareArrayStatement
{
    function StringArrayStatement(var start, var owner, var name, var tk)
    {
        self.DeclareArrayStatement(start, owner, name, REGstring, "String", tk);
    }
}


function newStringSingle(var start, var owner, var name, var tk)
{
    return new StringStatement(start, owner, name, tk);
}

function newStringArray(var start, var owner, var tk, var name)
{
    return new StringArrayStatement(start, owner, name, tk);
}

function parseString(var start, var tk, var owner)
{
    return parseDeclareHelper(newStringSingle, newStringArray, start, tk, owner);
}

//*********************************************
//            ConstStatement
//*********************************************

class ConstStatement : Statement
{
    var type;
    var name;
    var data;
    var value;

    function ConstStatement(var name, var tk, var owner, string type)
    {
        self.Statement(name, owner);
        self.type = type;
        self.name = name;
        self.value = parseExpr(tk, self);
        self.data = self.createconst(name, type);
    }
    function optimize()
    {
        var value = self.value;
        value = value.optimize();
        if (! value.hascompilevalue()) {
            SyntaxError("Value for const is not evaluable at compile time",
                self);
        }
        self.data.setvalue(value);
        return self;
    }
    function checkresult()
    {
        InternalError("Direct use of const", self.start);
    }
    function emit(var e)
    {
        var val = self.data.getvalue();
        string sval;
        switch (self.type) {
          case REGint:    sval = val.getIntegerValue(); break;
          case REGfloat:  sval = val.getFloatValue(); break;
          case REGstring: sval = val.getPirString(); break;
          default: __ASSERT__(false);
        }
        e.comment("Constant '", self.name, "' set to: ", sval);
    }
}

function parseConst(var start, var tk, var owner)
{
    var t = tk.get();
    string type = t.isidentifier() ? typetoregcheck(t.getidentifier()) : "";
    if (type != REGint && type != REGfloat && type != REGstring)
        SyntaxError("Invalid type for const", t);

    var multi = null;
    do {
        var name = tk.get();
        RequireIdentifier(name);
        ExpectOp("=", tk);
        multi = addtomulti(multi, new ConstStatement(name, tk, owner, type));
    } while ((t = tk.get()).isop(","));
    RequireOp(";", t);
    return multi;
}

//*********************************************
//            VarStatement
//*********************************************

class VarStatement : VarBaseStatement
{
    var init;
    function VarStatement(var start, var tk, var owner, var name, int flags)
    {
        self.initvarbase(start, owner, name, flags);
        var t = tk.get();
        if (t.isop("=")) {
            self.init = parseExpr(tk, self);
            t = tk.get();
        }
        RequireOp(";", t);
    }
    function optimize_init()
    {
        if (self.init != null)
            self.init = self.init.optimize();
        return self;
    }
    function optimize()
    {
        self.optimizedeclare();
        return self.optimize_init();
    }
    function emit(var e)
    {
        self.annotate(e);
        string name =  self.name;
        string reg = self.reg;
        var init = self.init;
        e.comment("var ", name, ": ", reg);
        if (init != null)
            if (init.isnull())
                init = null;
        if (init != null) {
            switch (init.checkresult()) {
              case REGvar:
                init.emit_init(e, reg);
                break;
              case REGstring:
              case REGint:
              case REGfloat:
                string value = init.emit_get(e);
                e.emitbox(reg, value);
                break;
              case REGnone:
                SyntaxError("Can't use void function as initializer", self);
              default:
                SyntaxError("Invalid var initializer", self);
            }
        }
        else
            e.emitnull(reg);
    }
}

class ResizableVarStatement : VarStatement
{
    function ResizableVarStatement(var start, var tk, var owner, var name)
    {
        self.initvarbase(start, owner, name);
        ExpectOp(";", tk);
    }
    function emit(var e)
    {
        self.annotate(e);
        string reg = self.reg;
        e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'ResizablePMCArray'", reg));
    }
}

class FixedVarStatement : VarStatement
{
    var exprsize;

    function FixedVarStatement(var start, var tk, var owner, var name)
    {
        self.initvarbase(start, owner, name);
        self.exprsize = parseExpr(tk, self);
        ExpectOp("]", tk);
        ExpectOp(";", tk);
    }
    function optimize()
    {
        self.exprsize = self.exprsize.optimize();
        return self.optimize_init();
    }
    function emit(var e)
    {
        string regsize = self.exprsize.emit_get(e);
        self.annotate(e);
        string reg = self.reg;
        e.comment(sformat("var %0[] : %1", self.name, reg));
        e.say(sformat(INDENT + "new %0, 'FixedPMCArray', %1", reg, regsize));
    }
}

function parseVar(var start, var tk, var owner, int flags[optional])
{
    var name = tk.get();
    RequireIdentifier(name);
    var t = tk.get();
    if (t.isop("[")) {
        t = tk.get();
        if (t.isop("]"))
            return new ResizableVarStatement(start, tk, owner, name);
        else {
            tk.unget(t);
            return new FixedVarStatement(start, tk, owner, name);
        }
    }
    else {
        tk.unget(t);
        return new VarStatement(start, tk, owner, name, flags);
    }
}

function parseVolatile(var start, var tk, var owner)
{
    var t = tk.get();
    if (!t.iskeyword("var"))
        SyntaxError("invalid volatile type", t);

    return parseVar(start, tk, owner, VAR_is_volatile);
}

//*********************************************
//            CompoundStatement
//*********************************************

class CompoundStatement : MultiStatementBase, BlockStatement
{
    var end;

    function CompoundStatement(var start, var tk, var owner)
    {
        self.BlockStatement(start, owner);
        self.statements = [];
        var t;
        while (! (t = tk.get()).isop("}")) {
            tk.unget(t);
            var c = parseStatement(tk, self);
            if (c == null)
                InternalError("Unexpected null statement");
            push(self.statements, c);
        }
        self.end = t;
    }
    function getend() { return self.end; }
    function emit(var e)
    {
        e.comment("{");
        for (var st in self.statements) {
            st.emit(e);
            self.freetemps();
        }
        e.comment("}");
    }
}

//*********************************************
//            RegisterStore
//*********************************************

class RegisterStore
{
    var type;
    var nreg;
    var tempreg;
    var freereg;
    function RegisterStore(string type)
    {
        self.type = type;
        // Registers number 0 are reserved for temporary usage in builtins.
        self.nreg = 1;
        string tempreg[];
        string freereg[];
        self.tempreg = tempreg;
        self.freereg = freereg;
    }
    function createreg()
    {
        int n = int(self.nreg) + 1;
        string reg = n;
        self.nreg = n;
        return "$" + string(self.type) + reg;
    }
    function tempreg()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        string reg;
        if (elements(freereg) != 0)
            reg = freereg.pop();
        else
            reg = self.createreg();
        push(tempreg, reg);
        return reg;
    }
    function freetemps()
    {
        var freereg = self.freereg;
        var tempreg = self.tempreg;
        int n = elements(tempreg);
        for (int i = n - 1; i >= 0; i = i - 1) {
            string s = tempreg[i];
            push(freereg, s);
        }
        string newtempreg[];
        self.tempreg = newtempreg;
    }
}

//*********************************************
//            FunctionParameter
//*********************************************

class ParameterModifierList : ModifierList
{
    function ParameterModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function emitmodifiers(var e, var start, string paramname)
    {
        var named = null;
        var slurpy = null;
        var modarglist = self.getlist();
        for (var mod in modarglist) {
            string modname = mod.getname();
            switch (modname) {
              case "named":
                named = mod;
                break;
              case "slurpy":
                slurpy = mod;
                break;
              default:
                e.print(" :", modname);
            }
        }
        switch {
          case named != null && slurpy != null:
            // Special case for named slurpy: named refers
            // to the slurpy content, not to the param himself.
            // TODO: check that named has no arguments,
            // or use a different way.
            e.print(" :named :slurpy");
            break;
          case named != null:
            string setname;
            switch (named.numargs()) {
              case 0:
                setname = "'" + paramname + "'";
                break;
              case 1:
                var argmod = named.getarg(0);
                if (! argmod.isstringliteral())
                    SyntaxError("Invalid modifier", start);
                setname = argmod.getPirString();
                break;
              default:
                SyntaxError("Invalid modifier", start);
            }
            e.print(" :named(", setname, ")");
            break;
          case slurpy != null:
            e.print(" :slurpy");
            break;
        }
    }
}

class FunctionParameter
{
    var func;
    var name;
    var modifiers;
    var type;
    function FunctionParameter(var func, var tk)
    {
        self.func = func;
        var t = tk.get();
        string type = typetoregcheck(t.checkkeyword());
        if (type == "")
            Expected("parameter type", t);
        self.type = type;
        t = tk.get();
        RequireIdentifier(t);
        string argname = "__ARG_" + string(func.generateparamnum());
        func.createvarnamed(t, type, argname);

        self.name = t;
        t = tk.get();
        if (t.isop("["))
            self.modifiers = new ParameterModifierList(tk, func.owner);
        else
            tk.unget(t);
    }
    function emit(var e)
    {
        var func = self.func;
        string paramname = self.name;
        var param = func.getvar(paramname);
        string ptype = typetopirname(param.gettype());
        e.print(INDENT + INDENT + ".param ", ptype, " ", param.getreg());
        var modarg = self.modifiers;
        if (modarg != null)
            modarg.emitmodifiers(e, func.start, paramname);
        e.say("");
    }
    function get_type()
    {
        return self.type;
    }

}

function parseParameter(var tk, var owner)
{
    return new FunctionParameter(owner, tk);
}

//*********************************************
//            FunctionBase
//*********************************************

function emit_subid(string subid)
{
    return ".const 'Sub' " + subid + " = \"" + subid + "\"\n";
}

class FunctionModifierList : ModifierList
{
    function FunctionModifierList(var tk, var owner)
    {
        self.ModifierList(tk, owner);
    }
    function emit(var e)
    {
        for (var m in self.getlist()) {
            string name = m.getname();
            int nargmods = m.numargs();
            e.print(" :", name);
            if (nargmods > 0) {
                e.print("(");
                for (int iargmod = 0; iargmod < nargmods; iargmod = iargmod + 1) {
                    var argmod = m.getarg(iargmod);
                    if (!argmod.isstringliteral())
                        SyntaxError("Invalid modifier", argmod);
                    e.print(argmod.getPirString());
                    if (iargmod < nargmods - 1)
                        e.print(", ");
                }
                e.print(")");
            }
        }
    }
}

class FunctionBase : BlockStatement
{
    var name;
    var subid;
    var modifiers;
    var params;
    var body;
    var regstI;
    var regstN;
    var regstS;
    var regstP;
    var nlabel;
    var localfun;
    var lexicals;
    var usedlexicals;
    var usedsubids;
    var outer;

    function FunctionBase(var start, var owner)
    {
        self.BlockStatement(start, owner);
        self.nlabel = 0;
        self.regstI = new RegisterStore(REGint);
        self.regstN = new RegisterStore(REGfloat);
        self.regstS = new RegisterStore(REGstring);
        self.regstP = new RegisterStore(REGvar);
    }

    function getouter() { return self; }
    function makesubid()
    {
        // Return the subid for this function, creating if it doesn't have one
        var subid = self.subid;
        if (subid == null)
            self.subid = subid = self.generatesubid();
        return subid;
    }
    function usesubid(string id)
    {
        var used = self.usedsubids;
        if (used == null)
            self.usedsubids = used = {};
        used[id] = 1;
    }

    function same_scope_as(var other)
    {
        int r = self === other;
        return r;
    }
    function parse_parameters(var tk)
    {
        var t = tk.get();
        if (! t.isop(")")) {
            tk.unget(t);
            self.params = parseList(tk, self, parseParameter, ")");
        }
    }

    function addlocalfunction(var fn)
    {
        var localfun = self.localfun;
        if (localfun == null)
            self.localfun = [ fn ];
        else
            push(localfun, fn);
    }
    function usenamespace(var ns)
    {
        __ASSERT__(ns != null);
        var usedns = self.usednamespaces;
        if (usedns == null)
            self.usednamespaces = [ ns ];
        else {
            if (find_same(usedns, ns) != null)
                return;
            push(usedns, ns);
        }
    }
    function scopesearch(var key, int flags)
    {
        for (var ns in self.usednamespaces) {
            var found = ns.scopesearch(key, flags);
            if (found != null)
                return found;
        }
        return self.owner.scopesearch(key, flags);
    }

    function optimize()
    {
        var modifiers = self.modifiers;
        if (modifiers != null) {
            if (modifiers.pick("multi") != null)
                SyntaxError("multi functions not allowed in stage 1", self);
        }
        for (var used in self.usednamespaces)
            used.fixnamespaces();
        self.body = self.body.optimize();
        return self;
    }

    function setusedlex(string lexname, string regname)
    {
        var lexicals = self.usedlexicals;
        if (lexicals == null)
            self.usedlexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function setlex(string lexname, string regname)
    {
        var lexicals = self.lexicals;
        if (lexicals == null)
            self.lexicals = lexicals = {};
        lexicals[regname] = lexname;
    }
    function createlex(var vardata)
    {
        // Get the lexname for a variable, creating it on the fly
        // when needed.
        string lexname = vardata.getlex();
        if (lexname == null) {
            lexname = "'__WLEX_" + string(self.generatelexnum()) + "'";
            vardata.createlex(lexname);
        }
        return lexname;
    }

    function createreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in createreg: " + type);
        }
        string reg = store.createreg();
        return reg;
    }
    function tempreg(string type)
    {
        var store;
        switch (type) {
          case REGint:
            store = self.regstI; break;
          case REGfloat:
            store = self.regstN; break;
          case REGstring:
            store = self.regstS; break;
          case REGvar:
            store = self.regstP; break;
          default:
            InternalError("Invalid type in tempreg: " + type);
        }
        string reg = store.tempreg();
        return reg;
    }
    function freetemps()
    {
        for (var st in [ self.regstI, self.regstN, self.regstS, self.regstP ] )
            st.freetemps();
    }
    function genlabel()
    {
        int n = int(self.nlabel) + 1;
        self.nlabel = n;
        return "__label_" + string(n);
    }
    function getbreaklabel(var pos)
    {
        SyntaxError("break not allowed here", pos);
    }
    function getcontinuelabel(var pos)
    {
        SyntaxError("continue not allowed here", pos);
    }

    function emit(var e)
    {
        string name = self.name;
        e.say();
        e.print(".sub ");
        if (self.isanonymous())
            e.print("'' :anon");
        else
            e.print ("'", name, "'");
        if (self.subid != null)
            e.print(" :subid('", self.subid, "')");

        var outer = self.outer;
        if (outer != null && self.usedlexicals != null) {
            var outerid = outer.subid;
            if (outerid != null)
                e.print(" :outer('", outerid, "')");
        }

        // Modifiers
        if (self.ismethod())
            e.print(" :method");
        var modifiers = self.modifiers;
        if (modifiers != null)
            modifiers.emit(e);
        else {
            if (name == "main")
                e.print(" :main");
        }
        e.say();

        // Parameters
        emit_array(e, self.params);

        var lexicals = self.lexicals;
        var usedlexicals = self.usedlexicals;
        if (lexicals != null || usedlexicals != null) {
            e.annotate(self.start);
            // lexicals declared in this function and its inner scopes
            for (string l in lexicals)
                e.say(sformat(".lex %0, %1", lexicals[l], l));
            // lexicals from outers used inside
            for (string l in usedlexicals) {
                if (substr(l, 0, 1) != "$")
                    e.say(INDENT + ".local pmc " + l);
                e.emitfind_lex(l, usedlexicals[l]);
            }
        }

        e.print(join("", transform(self.usedsubids, [], emit_subid)));

        var body = self.body;
        if (body.isempty())
            e.comment("Empty body");
        else {
            e.comment("Body");
            body.emit(e);
            e.annotate(body.getend());
        }
        e.say("\n.end # ", name, "\n");

        // Local functions
        for (var fn in self.localfun)
            fn.emit(e);
    }
}

//*********************************************
//            FunctionStatement
//*********************************************

function get_pir_type(var param)
{
    return typetopirname(param.get_type());
}

class FunctionStatement : FunctionBase
{
    var paramnum;
    var lexnum;

    function FunctionStatement(var start, var tk, var owner, int is_inline[optional])
    {
        self.FunctionBase(start, owner);
        self.paramnum = 0;
        self.lexnum = 0;
        self.parse(tk, is_inline);
    }

    function isanonymous() { return false; }
    function generateparamnum()
    {
        // Get a number to assign unique internal names to params.
        int n = int(self.paramnum) + 1;
        self.paramnum = n;
        return n;
    }
    function generatelexnum()
    {
        // Get a number to assign unique internal names to lexicals.
        int n = int(self.lexnum) + 1;
        self.lexnum = n;
        return n;
    }
    function ismethod() { return false; }

    function parse(var tk, int is_inline[optional])
    {
        var name = tk.get();
        self.name = name;
        var t = tk.get();
        if (t.isop("[")) {
            self.modifiers = new FunctionModifierList(tk, self.owner);
            t = tk.get();
        }
        RequireOp("(", t);
        self.parse_parameters(tk);

        var path = self.owner.getpath().createchild(name.getidentifier());
        createPredefConstString(self, "__FUNCTION__", path.fullname());

        t = tk.get();
        if (t.iskeyword("return") && is_inline) {
            t = tk.get();
            t = tk.get();
        }
        if (!t.isop("{"))
            ExpectedOp("{", t);
        self.body = new CompoundStatement(t, tk, self);
        return self;
    }
}

//*********************************************
//            LocalFunctionStatement
//*********************************************

class LocalFunctionStatement : FunctionBase
{
    function LocalFunctionStatement(var start, var tk, var owner)
    {
        self.FunctionBase(start, owner);
        self.outer = owner.getouter();
        self.outer.makesubid();
        var subid = self.makesubid();
        self.name = subid;
        self.parse_parameters(tk);
        var t = tk.get();
        RequireOp("{", t);
        self.body = new CompoundStatement(t, tk, self);
        owner.addlocalfunction(self);
    }
    function isanonymous() { return true; }
    function ismethod() { return false; }
    function needclosure()
    {
        if (self.lexicals != null || self.usedlexicals != null)
            return true;
        for (var fn in self.localfun)
            if (fn.needclosure())
                return true;
        return false;
    }
    function getsubid()
    {
        return self.subid;
    }
    function generateparamnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.generateparamnum();
    }
    function generatelexnum()
    {
        // Forward to the outer to avoid duplicate names.
        return self.outer.generatelexnum();
    }
    function checkvarlexical(var name, var vardata)
    {
        /*
            If the var data is a lexical in some outer scope, create a
            local variable and set it as a used lexical.
            Otherwise, return it unchanged.
        */
        if (vardata.isconst())
            return vardata;
        string reg = vardata.getreg();
        //TEMPORARY WORKAROUND
        if (substr(reg, 0, 6) == "WSubId") {
            self.usesubid(reg);
            return vardata;
        }
        var scope = vardata.getscope();
        var ownerscope = scope.getouter();
        var outer = self.outer;
        if (ownerscope instanceof FunctionBase) {
            if (ownerscope.same_scope_as(outer)) {
                string lexname = scope.makelexical(vardata);
                int flags = vardata.getflags() | VAR_is_lexical;
                string type = vardata.gettype();
                if (type != REGvar)
                    flags = flags | VAR_is_volatile;
                var localvar = self.createvar(name, vardata.gettype(), flags);
                localvar.setlex(lexname);
                self.setusedlex(lexname, localvar.getreg());
                return localvar;
            }
        }
        return vardata;
    }
    function getvar(var name)
    {
        var localvar = self.getlocalvar(name);
        if (localvar == null)
            localvar = self.getusedvar(name);
        if (localvar == null) {
            // Not found in function scope, search external scopes
            // and check lexicals.
            localvar = self.owner.getvar(name);
            if (localvar == null) {
                // Special case for self in methods
                if (name == SELF) {
                    var ownerscope = self.outer;
                    if (self.outer.ismethod()) {
                        string lexself = ownerscope.makelexicalself();
                        localvar = self.createvar(name, REGvar);
                        string reg = localvar.getreg();
                        self.setusedlex(lexself, reg);
                    }
                }
            }
            else
                localvar = self.checkvarlexical(name, localvar);
        }
        if (localvar != null && !(localvar instanceof VarData))
            InternalError("Incorrect data for variable in LocalFunction");
        return localvar;
    }
}

//*********************************************
//            MethodStatement
//*********************************************

class MethodStatement : FunctionStatement
{
    function MethodStatement(var t, var tk, var owner)
    {
        self.FunctionStatement(t, tk, owner);
    }
    function ismethod() { return true; }
}

//*********************************************
//            MultiAssignStatement
//*********************************************

class SigParameter
{
    var owner;
    var name;
    var type;
    var modifiers;
    function SigParameter(var tk, var owner)
    {
        self.owner = owner;
        var name = tk.get();
        if (! name.isidentifier())
            ExpectedIdentifier(name);
        var t = tk.get();
        if (t.isidentifier()) {
            string type = typetoregcheck(name.checkkeyword());
            self.type = type;
            name = t;
            t = tk.get();
        }
        self.name = name;
        if (t.isop("["))
            self.modifiers = new ParameterModifierList(tk, self);
        else
            tk.unget(t);
    }
    function optimize()
    {
        var type = self.type;
        if (type != null)
            self.owner.createvar(self.name, type);
        return self;
    }
    function emit(var e)
    {
        var name = self.name;
        var data = self.owner.getvar(name);
        if (data == null)
            UndefinedVariable(name, name);
        var reg = data.getreg();
        e.print(reg);
        var modifiers = self.modifiers;
        if (modifiers != null)
            modifiers.emitmodifiers(e, name, name);
    }
}

function parseSigParameter(var tk, var owner)
{
    return new SigParameter(tk, owner);
}

class SigParameterList
{
    var params;
    function SigParameterList(var tk, var owner)
    {
        self.params = parseList(tk, owner, parseSigParameter, ")");
    }
    function optimize()
    {
        optimize_array(self.params);
    }
    function emit(var e)
    {
        e.print("(");
        string sep = "";
        for (var param in self.params) {
            e.print(sep);
            param.emit(e);
            sep = ", ";
        }
        e.print(")");
    }
}

class MultiAssignStatement : Statement
{
    var params;
    var expr;
    function MultiAssignStatement(var start, var owner, var params, var expr)
    {
        self.Statement(start, owner);
        self.params = params;
        self.expr = expr;
    }
    function optimize()
    {
        self.expr = self.expr.optimize();
        self.params.optimize();
        return self;
    }
    function emit(var e)
    {
        var expr = self.expr;
        if (! (expr instanceof CallExpr))
            SyntaxError("multi assignment used with non function call", expr);
        var call = expr.emitcall(e);
        expr.prepareargs(e);
        e.print(INDENT);
        self.params.emit(e);
        e.print(" = ", call);
        expr.emitargs(e);
        e.say();
    }
}

//*********************************************
//            Class specifier
//*********************************************

const int
    CLASSSPECIFIER_invalid   = 0,
    CLASSSPECIFIER_str       = 1, // Literal name
    CLASSSPECIFIER_parrotkey = 2, // Parrot key
    CLASSSPECIFIER_id        = 3; // Identifier, maybe qualified

function warn_class_unknown(var e, string name, var pos)
{
    e.warn("class " + name + " not found at compile time", pos);
}

class ClassSpecifier : CommonBase
{
    function ClassSpecifier(var owner, var start)
    {
        self.initbase(start, owner);
    }
    function reftype() { return CLASSSPECIFIER_invalid; }

    function annotate(var e)
    {
        e.annotate(self.start);
    }
}

class ClassSpecifierStr : ClassSpecifier
{
    var name;
    function ClassSpecifierStr(var owner, var name)
    {
        self.ClassSpecifier(owner, name);
        self.name = name;
    }
    function reftype() { return CLASSSPECIFIER_str; }

    function emit(var e, var ns)
    {
        string basestr = self.name.getPirString();
        e.print(basestr);
    }
}

class ClassSpecifierParrotKey : ClassSpecifier
{
    var key;
    function ClassSpecifierParrotKey(var tk, var owner, var start)
    {
        self.ClassSpecifier(owner, start);
        var key = [];
        var t = tk.get();
        if (!t.isstring())
            Expected("literal string", t);
        push(key, t.rawstring());
        t = tk.get();
        if (! t.isop("]")) {
            switch (t.checkop()) {
              case ",":
                break;
              default:
                Unexpected("token in class key", t);
            }
            do {
                t = tk.get();
                if (!t.isstring())
                    Expected("literal string", t);
                push(key, t.rawstring());
            } while ((t = tk.get()).isop(","));
            RequireOp("]", t);
        }
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_parrotkey; }

    function checknskey(var from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }
    function emit(var e, var ns)
    {
        e.print(getparrotkey(self.key));
    }
}

class ClassSpecifierId : ClassSpecifier
{
    var key;
    function ClassSpecifierId(var tk, var owner, var id)
    {
        self.ClassSpecifier(owner, id);
        var key = [ string(id) ];
        var t;
        while ((t = tk.get()).isop(".")) {
            t = tk.get();
            push(key, string(t));
        }
        tk.unget(t);
        self.key = key;
    }
    function reftype() { return CLASSSPECIFIER_id; }

    function last()
    {
        var key = self.key;
        return key[-1];
    }
    function checknskey(var from)
    {
        var nskey = from.scopesearch(self.key, SEARCH_CLASS);
        return nskey != null ? nskey.getpath() : null;
    }

    function emit(var e, var ns)
    {
        var key = ns.scopesearch(self.key, SEARCH_CLASS);
        if (key == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.print(getparrotkey(self.key));
        }
        else e.print(key.getclasskey());
    }
    function emit_new(var e, var from, string regnew)
    {
        var nskey = self.checknskey(from);
        if (nskey == null) {
            warn_class_unknown(e, join(".", self.key) , self.start);
            e.say("new ", regnew, ", ", getparrotkey(self.key));
        }
        else {
            nskey.emit_new(e, from, regnew);
        }
    }
}

//*********************************************
//            ClassStatement
//*********************************************

class ClassBase : CommonBase
{
    var name;
    var classns;
    function ClassBase(var start, var name, var parent)
    {
        self.initbase(start, parent);
        self.name = name;
        var classns = parent.getpath().createchild(name.getidentifier());
        self.classns = classns;
    }
    function getpath()
    {
        return self.classns;
    }
    function getclasskey()
    {
        return self.classns.getparrotkey();
    }
}

class FunctionContainer
{
    var functions;
    function FunctionContainer()
    {
        self.functions = {};
    }
    function addfunction(var newfunc)
    {
        __ASSERT__((newfunc instanceof Builtin) ||
                   (newfunc instanceof FunctionStatement));
        var functions = self.functions;
        __ASSERT__(newfunc.name instanceof TokenIdentifier);
        string name = newfunc.name.getidentifier();
        var func = functions[name];
        if (func == null)
            functions[name] = newfunc;
        else
            SyntaxError("multi functions not allowed in stage 1", newfunc);
    }
    function find(string name)
    {
        var functions = self.functions;
        return functions[name];
    }
}

class ClassStatement : ClassBase, VarContainer
{
    var parent;
    var bases;
    var constants;
    var items;
    var members;
    var funcont;

    function ClassStatement(var start, var name, var parent, var tk)
    {
        self.ClassBase(start, name, parent);
        self.VarContainer();
        self.funcont = new FunctionContainer();
        self.parent = parent;
        var items = [];
        self.items = items;
        var members = [];
        self.members = members;

        var t = tk.get();
        if (t.isop(":")) {
            self.bases = parseList(tk, self, parseClassSpecifier);
            t = tk.get();
        }
        RequireOp("{", t);

        createPredefConstString(self, "__CLASS__", self.classns.fullname());

        for (t = tk.get(); !t.isop("}"); t = tk.get()) {
            switch (t.checkkeyword()) {
              case "function":
                var f = new MethodStatement(t, tk, self);
                self.addmethod(f);
                push(items, f);
                break;
              case "var":
                var name = tk.get();
                if (! name.isidentifier())
                   Expected("member identifier", name);
                push(members, name);
                t = tk.get();
                if (! t.isop(";"))
                    Expected("';' in member declaration", t);
                break;
              case "const":
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              default:
                Unexpected("item in class", t);
            }
        }
    }
    function addmethod(var func)
    {
        __ASSERT__(func instanceof MethodStatement);
        self.funcont.addfunction(func);
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function checkclass(string name)
    {
        return self.parent.checkclass(name);
    }
    function scopesearch(var key, int flags)
    {
        return self.parent.scopesearch(key, flags);
    }
    function use_builtin(string name)
    {
        return self.owner.use_builtin(name);
    }
    function optimize()
    {
        optimize_array(self.items);
        return self;
    }
    function emit(var e)
    {
        self.classns.emitnamespace(e);
        emit_array(e, self.items);

        e.say(".sub Winxed_class_init :anon :load :init");

        e.say(INDENT, "newclass $P0, ", self.getclasskey() );
        int n = 1;
        for (var base in self.bases) {
            base.annotate(e);
            string reg = "$P" + n;
            n = n + 1;
            e.print(INDENT, "get_class ", reg, ", ");
            base.emit(e, self.parent);
            e.say();
            e.say(INDENT, "addparent $P0, ", reg);
        }
        for (var member in self.members) {
            e.annotate(member);
            e.say(INDENT, "addattribute $P0, '", member, "'");
        }

        e.say(".end");
    }
}

class DeclareClassStatement : ClassBase
{
    function DeclareClassStatement(var start, var name, var parent)
    {
        self.ClassBase(start, name, parent);
    }
    function optimize()
    {
        return self;
    }
    function emit(var e)
    {
    }
}

function parseClass(var start, var tk, var parent)
{
    var name = tk.get();
    var t = tk.get();
    if (t.isop(";"))
        parent.declareclass(new DeclareClassStatement(start, name, parent));
    else {
        tk.unget(t);
        parent.addclass(new ClassStatement(start, name, parent, tk));
    }
}

//*********************************************
//        Namespace classes and functions
//*********************************************

function open_include(string filename, var start)
{
    var interp = getinterp();

    // Search for the file in the parrot include paths
    const int IGLOBALS_LIB_PATHS = 9;
    const int PARROT_LIB_PATH_INCLUDE = 0;
    var libpaths = interp[IGLOBALS_LIB_PATHS];
    var paths = libpaths[PARROT_LIB_PATH_INCLUDE];
    var file;
    for (string path in paths) {
        string filepath = path + filename;
        try {
            file = open(filepath, "r");
            if (file != null && ! file.is_closed())
                break;
        }
        catch () {
        }
    }
    if (file == null || file.is_closed())
        SyntaxError("File not found", start);
    file.encoding("utf8");
    return file;
}

function include_parrot(var start, var tk, var ns)
{
    var tfile = tk.get();
    if (!tfile.isstring())
        Expected("literal string", tfile);
    ExpectOp(";", tk);

    var sfile = start.file;
    int sline = start.line;
    string filename = tfile.rawstring();
    var file = open_include(filename, start);

    // Parse lines like this: .macro_const CONST_NAME value
    // Assume only integer values for a now
    const string MACRO_CONST = ".macro_const";
    for (string line = file.readline(); !file.eof(); line = file.readline()) {
        if (substr(line, 0, length(MACRO_CONST)) == MACRO_CONST) {
            int pos = length(MACRO_CONST);
            string c;
            while ((c = substr(line, pos, 1)) == " " || c == "\t")
                pos = pos + 1;
            int pos2 = pos;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                pos2 = pos2 + 1;
            if (pos2 == pos)
                continue;
            string name = substr(line, pos, pos2 - pos);
            while ((c = substr(line, pos2, 1)) == " " || c == "\t")
                pos2 = pos2 + 1;
            pos = pos2;
            while ((c = substr(line, pos2, 1)) != " " && c != "\t" &&
                    c != "\n" && c != "\r" && c != "")
                pos2 = pos2 + 1;
            if (pos2 == pos)
                continue;
            string value = substr(line, pos, pos2- pos);

            int ivalue;
            if (substr(value, 0, 2) == "0x" || substr(value, 0, 2) == "0X")
                ivalue = substr(value, 2).to_int(16);
            else
                ivalue = value;
            var tokname = new TokenIdentifier(sfile, sline, name);
            var cst = ns.createconst(tokname, REGint, VAR_is_extern);
            cst.setvalue(integerValue(ns, tokname, ivalue));
        }
    }

    file.close();
}

//*********************************************

function parsensUsing(var start, var tk, var ns)
{
    var t = tk.get();
    if (t.iskeyword("namespace")) {
        usingNamespace(start, tk, ns);
        ExpectOp(";", tk);
        return;
    }
    if (! t.iskeyword("extern")) {
        tk.unget(t);
        var key = parseDotted(tk);
        int nelems = elements(key);
        if (nelems < 1)
            SyntaxError("Unsupported at namespace level", t);
        ExpectOp(";", tk);
        ns.use(key);
        return;
    }
    t = tk.get();
    switch {
      case t.isstring():
        tk.warn("using extern 'file'; is deprecated, use $loadlib instead.",
                t);
        string reqlib = t;
        ns.addlib(reqlib);
        ExpectOp(";", tk);
        break;
      case t.isidentifier():
        tk.unget(t);
        var module = parseDotted(tk);
        var names = parseListOrEmpty(tk, null, parseIdentifier, ";");
        if (names != null)
            ns.addextern(module, names);
        ns.addload(toModuleFilename(module));
        break;
      default:
        Expected("string literal or identifier", t);
    }
}

//*********************************************

function emit_push_symbols(string name)
{
    return INDENT + "push symbols, '" + name + "'\n";
}

class External
{
    var module;
    var names;
    function External(var module, var names)
    {
        self.module = module;
        self.names = names;
    }
    function emit(var e)
    {
        // Import external symbols in the current namespace

        e.say(<<:
.sub 'importextern' :anon :load :init
    .local pmc ex, curns, srcns, symbols
    ex = new ["Exporter"]
    curns = get_namespace
    symbols = new ["ResizableStringArray"]
:>>
        );

        e.emitget_root_namespace("srcns",
                "['parrot'; '" + string(join("'; '", self.module)) + "']");

        e.print(join("", transform(self.names, [], emit_push_symbols)));
        e.say(<<:
    ex.'destination'(curns)
    ex.'import'(srcns :named('source'), curns :named('destination'), symbols :named('globals'))
.end
:>>
        );
    }
}

class NamespacePath
{
    var path;

    function NamespacePath()
    {
        string path[];
        self.path = path;
    }
    function createchild(string name)
    {
        var child = new NamespacePath;
        var path = clone(self.path);
        push(path, name);
        child.path = path;
        return child;
    }
    function fullname()
    {
        string name = join(".", self.path);
        return name;
    }
    function getparrotkey()
    {
        var path = self.path;
        string r;
        if (elements(path) != 0)
            r = "[ '" + string(join("'; '", path)) + "' ]";
        return r;
    }
    function emitnamespace(var e)
    {
        var path = self.path;
        e.print(".namespace [ ");
        if (elements(path) != 0)
            e.print("'", join("'; '", path), "' ");
        e.say("]");
    }
    function emit_new(var e, var fromns, string regnew, string reginit[optional])
    {
        e.print(sformat(INDENT + "new %0, %1",
                regnew, self.getparrotkey()));
        if (reginit != null && reginit != "")
            e.print(reginit);
        e.say();
    }
    function emit_get_namespace(var e, var fromns, string result)
    {
        e.emitget_hll_namespace(result, self.getparrotkey());
    }
    function emit_get_class(var e, var fromns, string result)
    {
        e.say(sformat(INDENT + "get_class %0, %1",
                result, self.getparrotkey()));
    }
    function emit_get_global(var e, var fromns, string result, string name)
    {
        e.emitget_hll_global(result, name, self.getparrotkey());
    }
}

//*********************************************
//            NamespaceBase
//*********************************************

class NamespaceBase : VarContainer
{
    var nspath;
    var externals;
    var namespaces;
    var classes;
    var funcont;
    var items;
    var owner;

    function NamespaceBase(var nspath, var previous)
    {
        self.VarContainer();
        self.nspath = nspath;
        if (previous == null) {
            self.namespaces = [];
            self.usednamespaces = [];
            self.classes = [];
            self.funcont = new FunctionContainer();
            createPredefConstString(self, "__NAMESPACE__", nspath.fullname());
        }
        else {
            self.locals = previous.locals;
            self.namespaces = previous.namespaces;
            self.usednamespaces = previous.usednamespaces;
            self.classes = previous.classes;
            self.funcont = previous.funcont;
        }
        self.items = [];
    }
    function addfunction(var newfunc)
    {
        self.funcont.addfunction(newfunc);
    }
    function fixnamespaces()
    {
        var ns;
        for (ns in self.namespaces)
            ns.fixnamespaces();
        for (ns in self.usednamespaces)
            for (var used in ns.usednamespaces)
                self.usenamespace(used);
    }
    function getpath()
    {
        return self.nspath;
    }
    function usenamespace(var nsused)
    {
        if (nsused === self)
            return;
        var usednamespaces = self.usednamespaces;
        if (find_same(usednamespaces, nsused) != null)
            return;
        push(usednamespaces, nsused);
    }
    function use(var key)
    {
        var sym = self.scopesearch(key, 0);
        if (sym != null) {
            if (sym instanceof FunctionStatement)
                self.addfunction(sym);
        }
        else {
            string name = key.pop();
            var ns = self.scopesearch(key, SEARCH_NAMESPACE);
            if (ns != null) {
                sym = ns.getvar(name);
                if (sym != null)
                    self.createvarused(name, sym);
            }
        }
    }
    function getusedns(string name)
    {
        for (var ns in self.usednamespaces)
            if (ns.name == name)
                return ns;
        return null;
    }
    function getlocalns(string name)
    {
        for (var ns in self.namespaces)
            if (ns.name == name)
                return ns;
        return self.getusedns(name);
    }

    function addextern(var module, var names)
    {
        var ext = new External(module, names);
        var externals = self.externals;
        if (externals == null)
            self.externals = externals = [ ext ];
        else
            push(externals, ext);
    }

    function checkclass_base(string name)
    {
        var cl;
        for (cl in self.classes)
            if (cl.name == name)
                return cl;
        for (var ns in self.usednamespaces)
            if ((cl = ns.checkclass_base(name)) != null)
                return cl;
        return null;
    }
    function findsymbolbyname(string name)
    {
        var sym = self.checkclass_base(name);
        if (sym != null)
            return sym;
        var funcont = self.funcont;
        return funcont.find(name);
    }
    function scopesearchlocal(var key, int flags, int offset)
    {
        // Look for a symbol by its key in this namespace
        // and its childs.
        int keylen = elements(key);
        string name;
        var sym;
        var ns;
        switch (keylen - offset) {
          case 0:
            break;
          case 1:
            name = key[keylen - 1];
            switch (flags) {
              case SEARCH_NAMESPACE:
                return self.getlocalns(name);
              case SEARCH_CLASS:
                return self.checkclass_base(name);
              default:
                // The key contains the name, look by name
                if ((sym = self.findsymbolbyname(name)) != null)
                    return sym;
                for (ns in self.usednamespaces)
                    if ((sym = ns.findsymbolbyname(name)) != null)
                        return sym;
            }
            break;
          default:
            // The key is multi: look for a child namespace named
            // as the first key item, and look into it with the
            // remaining.
            name = key[offset];
            ns = self.getlocalns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
            ns = self.getusedns(name);
            if (ns != null &&
                    (sym = ns.scopesearchlocal(key, flags, offset + 1)) != null)
                return sym;
        }
        return null;
    }
    function childnamespace(var start, string name, var modifier)
    {
        var existns = self.getlocalns(name);
        var child = new NamespaceStatement(self, start, existns, name, modifier);
        push(self.namespaces, child);
        push(self.items, child);
        return child;
    }
    function declareclass(var statement)
    {
        push(self.classes, statement);
    }
    function addclass(var statement)
    {
        push(self.classes, statement);
        push(self.items, statement);
    }
    function parsenamespace(var start, var tk)
    {
        var t = tk.get();
        string name = t;
        t = tk.get();

        var modifier;
        if (t.isop("[")) {
            modifier = new ModifierList(tk, self);
            t = tk.get();
        }

        RequireOp("{", t);
        var child = self.childnamespace(start, name, modifier);
        child.parse(tk);
    }
    function parse(var tk)
    {
        var items = self.items;
        var t;
        for (t = tk.get(); !(t.iseof() || t.isop("}")); t = tk.get())
        {
            switch (t.checkkeyword()) {
              case "namespace":
                self.parsenamespace(t, tk);
                break;
              case "const":
                var cst = parseConst(t, tk, self);
                push(items, cst);
                break;
              case "function":
                var f = new FunctionStatement(t, tk, self);
                self.addfunction(f);
                push(items, f);
                break;
              case "inline":
                var fin = new FunctionStatement(t, tk, self, true);
                self.addfunction(fin);
                push(items, fin);
                break;
              case "class":
                parseClass(t, tk, self);
                break;
              case "using":
                parsensUsing(t, tk, self);
                break;
              case "$include_const":
                include_parrot(t, tk, self);
                break;
              case "$load":
                t = tk.get();
                if (! t.isstring())
                    Expected("string literal", t);
                ExpectOp(";", tk);
                self.addload((new StringLiteral(self, t)).getPirString());
                break;
              case "$loadlib":
                t = tk.get();
                if (! t.isstring())
                    Expected("string literal", t);
                ExpectOp(";", tk);
                self.addlib((new StringLiteral(self, t)).getPirString());
                break;
              default:
                Unexpected("token", t);
            }
        }
        if (t.iseof())
            self.unclosed_ns();
        else
            self.close_ns(t);
    }
    function optimize_base()
    {
        optimize_array(self.items);
    }
    function emit_base(var e)
    {
        var path = self.getpath();

        int activate = true;

        var externals = self.externals;
        if (externals != null) {
            path.emitnamespace(e);
            activate = false;
            emit_array(e, externals);
        }

        for (var item in self.items) {
            if ((item instanceof NamespaceStatement) ||
                    (item instanceof ClassStatement))
                activate = true;
            else
                if (activate) {
                    path.emitnamespace(e);
                    activate = false;
                }
            item.emit(e);
        }
    }
}

//*********************************************
//            NamespaceStatement
//*********************************************

class NamespaceStatement : NamespaceBase
{
    var parent;
    var start;
    var name;
    var modifier;

    function NamespaceStatement(var parent, var start, var previous,
            string name, var modifier)
    {
        self.modifier = modifier;
        if (modifier != null) {
            if (modifier.pick("HLL") != null)
                SyntaxError("HLL modifier not supported in stage 1", self.start);
        }
        var nspath = parent.getpath().createchild(name);
        self.NamespaceBase(nspath, previous);

        self.parent = parent;
        self.start = start;
        self.owner = parent;
        self.name = name;
    }
    function dowarnings()
    {
        return self.parent.dowarnings();
    }
    function generatesubid()
    {
        return self.owner.generatesubid();
    }
    function use_builtin(string name)
    {
        self.owner.use_builtin(name);
    }
    function addlib(string libname)
    {
        self.parent.addlib(libname);
    }
    function addload(string loadname)
    {
        self.parent.addload(loadname);
    }
    function checkclass(string name)
    {
        var cl = self.checkclass_base(name);
        if (cl == null)
            return self.parent.checkclass(name);
        return cl;
    }
    function scopesearch(var key, int flags, int offset[optional])
    {
        var sym = self.scopesearchlocal(key, flags, offset);
        if (sym == null && offset <= 0)
            return self.parent.scopesearch(key, flags, offset);
        return sym;
    }
    function unclosed_ns()
    {
       SyntaxError("unclosed namespace", self.start);
    }
    function close_ns(var t)
    {
        // Do nothing
    }
    function optimize()
    {
        var modifier = self.modifier;
        if (modifier != null)
            self.modifier = modifier.optimize();
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        self.emit_base(e);
    }
}

//*********************************************
//            RootNamespace
//*********************************************

function emit_loadlib(string libname)
{
    return ".loadlib " + libname;
}

function emit_loadbytecode(string loadname)
{
    return INDENT + "load_bytecode " + loadname;
}

class RootNamespace : NamespaceBase
{
    var unit;
    var bultins_used;
    var libs;
    var loads;
    var subidgen;

    function RootNamespace(var unit)
    {
        self.NamespaceBase(new NamespacePath(), null);
        self.unit = unit;
        self.bultins_used = {};
        self.subidgen = 0;
    }
    function use_builtin(string name)
    {
        var bultins_used = self.bultins_used;
        bultins_used[name] = true;
    }

    function generatesubid()
    {
        int idgen = int(self.subidgen) + 1;
        self.subidgen = idgen;
        return "WSubId_" + string(idgen);
    }

    function addlib(string libname)
    {
        var libs = self.libs;
        if (libs == null)
            self.libs = libs = {};
        libs[libname] = 1;
    }
    function addload(string name)
    {
        var loads = self.loads;
        if (loads == null)
            self.loads = loads = {};
        loads[name] = 1;
    }
    function checkclass(string name)
    {
        return self.checkclass_base(name);
    }
    function scopesearch(var key, int flags, int offset[optional])
    {
        return self.scopesearchlocal(key, flags, offset);
    }
    function unclosed_ns()
    {
        // Do nothing
    }
    function close_ns(var t)
    {
         SyntaxError("Cannot close root namespace", t);
    }
    function dowarnings()
    {
        return self.unit.dowarnings();
    }
    function optimize()
    {
        self.optimize_base();
        return self;
    }
    function emit(var e)
    {
        var bultins_used = self.bultins_used;

        // Load trans opcodes if some of its corresponding builtins are used
        for (string trfun in
                    split(" ", "acos asin atan cos exp ln sin tan pow"))
            if (bultins_used[trfun] != null) {
                self.addlib("'trans_ops'");
                break;
            }

        var libs = self.libs;
        if (libs != null)
            e.say(join("\n", transform(libs, [], emit_loadlib)));

        var loads = self.loads;
        if (loads != null) {
            e.say(sformat(
<<:
.sub initial_load_bytecode :anon :load :init
%0
.end
:>>
                , join("\n", transform(loads, [], emit_loadbytecode))));
        }
        if (libs != null || loads != null)
            e.comment("end libs");

        self.emit_base(e);
    }
    function emitinclude(var e)
    {
        var locals = self.locals;
        for (string localname in locals) {
            var data = locals[localname];
            if (!(data instanceof VarData) ||
                    data.gettype() != REGint ||
                    data.getflags() & VAR_is_extern)
                continue;
            var value = data.getvalue();
            e.say(".macro_const ", localname, " ", value.getIntegerValue());
        }
    }
}

//*********************************************
//           Compiler classes
//*********************************************

class Builtin
{
    var name;
    var variants;
    function Builtin(string name, var variant)
    {
        self.name = new TokenIdentifier("__builtins__", 0, name);
        self.variants = [ variant ];
    }
    function getname()
    {
        return self.name;
    }
    function addvariant(var variant)
    {
        push(self.variants, variant);
    }
}

const string EVAL_NAME = "__eval__";

class BuiltinBuilder
{
    var entries;
    function BuiltinBuilder()
    {
        self.entries = {};
    }
    function add(var builtin)
    {
        var entries = self.entries;
        string name = builtin.name;
        if (entries[name] != null)
            entries[name].addvariant(builtin);
        else
            entries[name] = new Builtin(name, builtin);
    }
    function put(var ns)
    {
        var entries = self.entries;
        for (string s in entries)
            ns.addfunction(entries[s]);
    }
}

class WinxedCompileUnit
{
    var rootns;
    var warnings;

    function WinxedCompileUnit(int nowarn, int debug)
    {
        self.warnings = ! nowarn;
        var rootns = new RootNamespace(self);

        // Store predefined constants in the root namespace.

        createPredefConstInt(rootns, "false", 0);
        createPredefConstInt(rootns, "true", 1);

        // Tricky way of setting __STAGE__: stage 1 is built with
        // stage 0 and stage 2 is built with stage 1. Increment
        // the current stage and we are done.
        createPredefConstString(rootns, "__STAGE__",
                string(int(__STAGE__) + 1));

        createPredefConstInt(rootns, "__DEBUG__", debug);

        // Propagate value for exception type.
        createPredefConstInt(rootns, "__WINXED_ERROR__", __WINXED_ERROR__);

        // Builtins
        var builtins_ns = rootns.childnamespace(new TokenEof("__builtins__"),
                "Winxed_Builtins", null);
        var builder = new BuiltinBuilder();
        getbuiltins(builder);
        builder.put(builtins_ns);

        rootns.usenamespace(builtins_ns);

        self.rootns = rootns;
    }
    function dowarnings()
    {
        return int(self.warnings);
    }
    function parse(var tk)
    {
        self.rootns.parse(tk);
        self.rootns.fixnamespaces();
    }
    function optimize()
    {
        self.rootns = self.rootns.optimize();
    }
    function emit(var e)
    {
        e.comment("THIS IS A GENERATED FILE! DO NOT EDIT!");
        e.comment("Begin generated code");
        e.say("");

        self.rootns.emit(e);

        e.comment("End generated code");
    }
    function emitinclude(var e)
    {
        e.comment("DO NOT EDIT THIS FILE");
        e.comment("Generated automatically from Winxed sources");

        self.rootns.emitinclude(e);

        e.comment("End");
    }
}

//*********************************************

function main [main](var args)
{
    int nargs = elements(args);
    int iarg;
    int debug = 0;
    int nowarn = 0;
    var obj;
    string evalexpr;
    for (iarg = 1; iarg < nargs; iarg = iarg + 1) {
        var opt = args[iarg];
        if (opt == null)
            break;
        if (opt == "-c")
            /* Ignored */;
        else if (opt == "-o") {
            iarg = iarg + 1;
            obj = args[iarg];
        }
        else if (opt == "-e") {
            iarg = iarg + 1;
            evalexpr = args[iarg];
        }
        else if (opt == "--debug")
            debug = 1;
        else if (opt == "--nowarn")
            nowarn = 1;
        else
            break;
    }
    if (obj == null)
        throw "invalid obj";
    string objname = obj;
    var src = args[iarg];
    if (src == null)
        throw "invalid src";
    string srcname = src;

    var handlein;
    if (evalexpr == null)
        handlein = open(srcname, "r");
    else
    {
        evalexpr = "function main[main](var argv){" + evalexpr + ";}";
        handlein = new ["StringHandle"];
        handlein.open(srcname, "w");
        handlein.encoding("utf8");
        handlein.print(evalexpr);
        handlein.close();
        handlein.open(srcname, "r");
    }
    handlein.encoding("utf8");
    var tk = new Tokenizer(handlein, srcname, nowarn);
    var winxed = new WinxedCompileUnit(nowarn, debug);
    winxed.parse(tk);
    handlein.close();
    winxed.optimize();

    var output;
    if (objname == "-")
        output = getstdout();
    else
        output = open(objname, "w");
    var emit = new Emit(output, nowarn);
    winxed.emit(emit);
    emit.close();
    if (objname != "-")
        output.close();
    exit(0);
}

// End
